/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NO_LONG_LONG: ::std::os::raw::c_uint = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const __DARWIN_CLK_TCK: ::std::os::raw::c_uint = 100;
pub const CHAR_BIT: ::std::os::raw::c_uint = 8;
pub const MB_LEN_MAX: ::std::os::raw::c_uint = 6;
pub const CLK_TCK: ::std::os::raw::c_uint = 100;
pub const SCHAR_MAX: ::std::os::raw::c_uint = 127;
pub const SCHAR_MIN: ::std::os::raw::c_int = -128;
pub const UCHAR_MAX: ::std::os::raw::c_uint = 255;
pub const CHAR_MAX: ::std::os::raw::c_uint = 127;
pub const CHAR_MIN: ::std::os::raw::c_int = -128;
pub const USHRT_MAX: ::std::os::raw::c_uint = 65535;
pub const SHRT_MAX: ::std::os::raw::c_uint = 32767;
pub const SHRT_MIN: ::std::os::raw::c_int = -32768;
pub const UINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_MIN: ::std::os::raw::c_int = -2147483648;
pub const ULONG_MAX: ::std::os::raw::c_int = -1;
pub const LONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const LONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const ULLONG_MAX: ::std::os::raw::c_int = -1;
pub const LLONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const LLONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const LONG_BIT: ::std::os::raw::c_uint = 64;
pub const SSIZE_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const WORD_BIT: ::std::os::raw::c_uint = 32;
pub const SIZE_T_MAX: ::std::os::raw::c_int = -1;
pub const UQUAD_MAX: ::std::os::raw::c_int = -1;
pub const QUAD_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const QUAD_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const ARG_MAX: ::std::os::raw::c_uint = 262144;
pub const CHILD_MAX: ::std::os::raw::c_uint = 266;
pub const GID_MAX: ::std::os::raw::c_uint = 2147483647;
pub const LINK_MAX: ::std::os::raw::c_uint = 32767;
pub const MAX_CANON: ::std::os::raw::c_uint = 1024;
pub const MAX_INPUT: ::std::os::raw::c_uint = 1024;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 16;
pub const UID_MAX: ::std::os::raw::c_uint = 2147483647;
pub const OPEN_MAX: ::std::os::raw::c_uint = 10240;
pub const PATH_MAX: ::std::os::raw::c_uint = 1024;
pub const PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const EQUIV_CLASS_MAX: ::std::os::raw::c_uint = 2;
pub const EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const NZERO: ::std::os::raw::c_uint = 20;
pub const _POSIX_ARG_MAX: ::std::os::raw::c_uint = 4096;
pub const _POSIX_CHILD_MAX: ::std::os::raw::c_uint = 25;
pub const _POSIX_LINK_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MAX_CANON: ::std::os::raw::c_uint = 255;
pub const _POSIX_MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const _POSIX_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX_NGROUPS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_OPEN_MAX: ::std::os::raw::c_uint = 20;
pub const _POSIX_PATH_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const _POSIX_SSIZE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_STREAM_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _POSIX2_BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX2_EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX2_LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_AIO_MAX: ::std::os::raw::c_uint = 1;
pub const _POSIX_DELAYTIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_MQ_OPEN_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MQ_PRIO_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_RTSIG_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_SEM_VALUE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_SIGQUEUE_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_CLOCKRES_MIN: ::std::os::raw::c_uint = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const _POSIX_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 128;
pub const _POSIX_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const PTHREAD_KEYS_MAX: ::std::os::raw::c_uint = 512;
pub const PTHREAD_STACK_MIN: ::std::os::raw::c_uint = 8192;
pub const _POSIX_HOST_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_SS_REPL_MAX: ::std::os::raw::c_uint = 4;
pub const _POSIX_SYMLINK_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_SYMLOOP_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: ::std::os::raw::c_uint = 30;
pub const _POSIX_TRACE_NAME_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TRACE_SYS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TTY_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const OFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const OFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const PASS_MAX: ::std::os::raw::c_uint = 128;
pub const NL_ARGMAX: ::std::os::raw::c_uint = 9;
pub const NL_LANGMAX: ::std::os::raw::c_uint = 14;
pub const NL_MSGMAX: ::std::os::raw::c_uint = 32767;
pub const NL_NMAX: ::std::os::raw::c_uint = 1;
pub const NL_SETMAX: ::std::os::raw::c_uint = 255;
pub const NL_TEXTMAX: ::std::os::raw::c_uint = 2048;
pub const _XOPEN_IOV_MAX: ::std::os::raw::c_uint = 16;
pub const IOV_MAX: ::std::os::raw::c_uint = 1024;
pub const _XOPEN_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _XOPEN_PATH_MAX: ::std::os::raw::c_uint = 1024;
pub const true_: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const E_OK: ::std::os::raw::c_uint = 0;
pub const E_SYS: ::std::os::raw::c_int = -5;
pub const E_NOSPT: ::std::os::raw::c_int = -9;
pub const E_RSFN: ::std::os::raw::c_int = -10;
pub const E_RSATR: ::std::os::raw::c_int = -11;
pub const E_PAR: ::std::os::raw::c_int = -17;
pub const E_ID: ::std::os::raw::c_int = -18;
pub const E_CTX: ::std::os::raw::c_int = -25;
pub const E_MACV: ::std::os::raw::c_int = -26;
pub const E_OACV: ::std::os::raw::c_int = -27;
pub const E_ILUSE: ::std::os::raw::c_int = -28;
pub const E_NOMEM: ::std::os::raw::c_int = -33;
pub const E_NOID: ::std::os::raw::c_int = -34;
pub const E_NORES: ::std::os::raw::c_int = -35;
pub const E_OBJ: ::std::os::raw::c_int = -41;
pub const E_NOEXS: ::std::os::raw::c_int = -42;
pub const E_QOVR: ::std::os::raw::c_int = -43;
pub const E_RLWAI: ::std::os::raw::c_int = -49;
pub const E_TMOUT: ::std::os::raw::c_int = -50;
pub const E_DLT: ::std::os::raw::c_int = -51;
pub const E_CLS: ::std::os::raw::c_int = -52;
pub const E_WBLK: ::std::os::raw::c_int = -57;
pub const E_BOVR: ::std::os::raw::c_int = -58;
pub const TMO_POL: ::std::os::raw::c_uint = 0;
pub const TMO_FEVR: ::std::os::raw::c_int = -1;
pub const TMO_NBLK: ::std::os::raw::c_int = -2;
pub const TACP_KERNEL: ::std::os::raw::c_uint = 0;
pub const TACP_SHARED: ::std::os::raw::c_int = -1;
pub const SIO_RDY_SND: ::std::os::raw::c_uint = 1;
pub const SIO_RDY_RCV: ::std::os::raw::c_uint = 2;
pub const TNUM_PORT: ::std::os::raw::c_uint = 4;
pub const SIO_PORT_UART: ::std::os::raw::c_uint = 1;
pub const SIO_PORT_BT: ::std::os::raw::c_uint = 2;
pub const SIO_PORT_LCD: ::std::os::raw::c_uint = 3;
pub const SIO_PORT_SPP_MASTER_TEST: ::std::os::raw::c_uint = 4;
pub const SERIAL_RCV_BUFSZ2: ::std::os::raw::c_uint = 8192;
pub const SERIAL_SND_BUFSZ2: ::std::os::raw::c_uint = 8192;
pub const CORE_CLK_MHZ: ::std::os::raw::c_uint = 300;
pub const OSCIN_MHZ: ::std::os::raw::c_uint = 24;
pub const ARM_PAGE_TABLE_RATIO: ::std::os::raw::c_uint = 20;
pub const PERIOD_UART_SENSOR_CYC: ::std::os::raw::c_uint = 10000;
pub const STACK_SIZE: ::std::os::raw::c_uint = 4096;
pub const KERNEL_HEAP_SIZE: ::std::os::raw::c_uint = 1048576;
pub const APP_HEAP_SIZE: ::std::os::raw::c_uint = 1048576;
pub const BT_SND_BUF_SIZE: ::std::os::raw::c_uint = 2048;
pub const BT_HIGH_PRI_TIME_SLICE: ::std::os::raw::c_uint = 1;
pub const BT_LOW_PRI_TIME_SLICE: ::std::os::raw::c_uint = 19;
pub const BT_USE_EDMA_MODE: ::std::os::raw::c_uint = 1;
pub const TMAX_APP_TSK_NUM: ::std::os::raw::c_uint = 32;
pub const TMAX_APP_SEM_NUM: ::std::os::raw::c_uint = 16;
pub const TMAX_APP_FLG_NUM: ::std::os::raw::c_uint = 16;
pub const TMAX_APP_DTQ_NUM: ::std::os::raw::c_uint = 16;
pub const TMAX_APP_PDQ_NUM: ::std::os::raw::c_uint = 16;
pub const TMAX_APP_MTX_NUM: ::std::os::raw::c_uint = 16;
pub const TMAX_APP_TEXT_SIZE: ::std::os::raw::c_uint = 1048576;
pub const TMAX_APP_DATA_SIZE: ::std::os::raw::c_uint = 1048576;
pub const TMAX_APP_BINARY_SIZE: ::std::os::raw::c_uint = 1048576;
pub const LCD_FRAME_RATE: ::std::os::raw::c_uint = 25;
pub const FORCE_SHUTDOWN_TIMEOUT: ::std::os::raw::c_uint = 500;
pub const TMAX_EV3_CYC_NUM: ::std::os::raw::c_uint = 16;
pub const SUART1_INT: ::std::os::raw::c_uint = 3;
pub const SUART2_INT: ::std::os::raw::c_uint = 4;
pub const TCNT_SYSLOG_BUFFER: ::std::os::raw::c_uint = 1024;
pub const T64P0_TINT12: ::std::os::raw::c_uint = 21;
pub const T64P1_TINT12: ::std::os::raw::c_uint = 23;
pub const UART0_INT: ::std::os::raw::c_uint = 25;
pub const UART1_INT: ::std::os::raw::c_uint = 53;
pub const UART2_INT: ::std::os::raw::c_uint = 61;
pub const GPIO_B0INT: ::std::os::raw::c_uint = 42;
pub const GPIO_B1INT: ::std::os::raw::c_uint = 43;
pub const GPIO_B2INT: ::std::os::raw::c_uint = 44;
pub const GPIO_B3INT: ::std::os::raw::c_uint = 45;
pub const GPIO_B4INT: ::std::os::raw::c_uint = 46;
pub const GPIO_B5INT: ::std::os::raw::c_uint = 47;
pub const GPIO_B6INT: ::std::os::raw::c_uint = 48;
pub const GPIO_B7INT: ::std::os::raw::c_uint = 49;
pub const GPIO_B8INT: ::std::os::raw::c_uint = 50;
pub const TMIN_INTNO: ::std::os::raw::c_uint = 0;
pub const TMAX_INTNO: ::std::os::raw::c_uint = 100;
pub const TMIN_INTPRI: ::std::os::raw::c_int = -31;
pub const TMAX_INTPRI: ::std::os::raw::c_int = -1;
pub const TIC_NUME: ::std::os::raw::c_uint = 1;
pub const TIC_DENO: ::std::os::raw::c_uint = 10;
pub const GPIO_ED_PIN0: ::std::os::raw::c_uint = 1;
pub const GPIO_ED_PIN1: ::std::os::raw::c_uint = 2;
pub const GPIO_ED_PIN2: ::std::os::raw::c_uint = 4;
pub const GPIO_ED_PIN3: ::std::os::raw::c_uint = 8;
pub const GPIO_ED_PIN4: ::std::os::raw::c_uint = 16;
pub const GPIO_ED_PIN5: ::std::os::raw::c_uint = 32;
pub const GPIO_ED_PIN6: ::std::os::raw::c_uint = 64;
pub const GPIO_ED_PIN7: ::std::os::raw::c_uint = 128;
pub const GPIO_ED_PIN8: ::std::os::raw::c_uint = 256;
pub const GPIO_ED_PIN9: ::std::os::raw::c_uint = 512;
pub const GPIO_ED_PIN10: ::std::os::raw::c_uint = 1024;
pub const GPIO_ED_PIN11: ::std::os::raw::c_uint = 2048;
pub const GPIO_ED_PIN12: ::std::os::raw::c_uint = 4096;
pub const GPIO_ED_PIN13: ::std::os::raw::c_uint = 8192;
pub const GPIO_ED_PIN14: ::std::os::raw::c_uint = 16384;
pub const GPIO_ED_PIN15: ::std::os::raw::c_uint = 32768;
pub const GPIO_DE_PIN0: ::std::os::raw::c_uint = 65536;
pub const GPIO_DE_PIN1: ::std::os::raw::c_uint = 131072;
pub const GPIO_DE_PIN2: ::std::os::raw::c_uint = 262144;
pub const GPIO_DE_PIN3: ::std::os::raw::c_uint = 524288;
pub const GPIO_DE_PIN4: ::std::os::raw::c_uint = 1048576;
pub const GPIO_DE_PIN5: ::std::os::raw::c_uint = 2097152;
pub const GPIO_DE_PIN6: ::std::os::raw::c_uint = 4194304;
pub const GPIO_DE_PIN7: ::std::os::raw::c_uint = 8388608;
pub const GPIO_DE_PIN8: ::std::os::raw::c_uint = 16777216;
pub const GPIO_DE_PIN9: ::std::os::raw::c_uint = 33554432;
pub const GPIO_DE_PIN10: ::std::os::raw::c_uint = 67108864;
pub const GPIO_DE_PIN11: ::std::os::raw::c_uint = 134217728;
pub const GPIO_DE_PIN12: ::std::os::raw::c_uint = 268435456;
pub const GPIO_DE_PIN13: ::std::os::raw::c_uint = 536870912;
pub const GPIO_DE_PIN14: ::std::os::raw::c_uint = 1073741824;
pub const GPIO_DE_PIN15: ::std::os::raw::c_uint = 2147483648;
pub const PLL_DIV_EN: ::std::os::raw::c_uint = 32768;
pub const PLL_DIV_RATIO: ::std::os::raw::c_uint = 31;
pub const UART_LSR_RXFIFOE: ::std::os::raw::c_uint = 128;
pub const UART_LSR_TEMT: ::std::os::raw::c_uint = 64;
pub const UART_LSR_THRE: ::std::os::raw::c_uint = 32;
pub const UART_LSR_BI: ::std::os::raw::c_uint = 16;
pub const UART_LSR_FE: ::std::os::raw::c_uint = 8;
pub const UART_LSR_PE: ::std::os::raw::c_uint = 4;
pub const UART_LSR_OE: ::std::os::raw::c_uint = 2;
pub const UART_LSR_DR: ::std::os::raw::c_uint = 1;
pub const SPIFLG_TX: ::std::os::raw::c_uint = 512;
pub const SPIFLG_RX: ::std::os::raw::c_uint = 256;
pub const SPIFLG_OE: ::std::os::raw::c_uint = 64;
pub const SPIFLG_BE: ::std::os::raw::c_uint = 16;
pub const SPIFLG_DESYNC: ::std::os::raw::c_uint = 8;
pub const SPIFLG_PE: ::std::os::raw::c_uint = 4;
pub const SPIFLG_TOUT: ::std::os::raw::c_uint = 2;
pub const SPIFLG_DE: ::std::os::raw::c_uint = 1;
pub const SPIBUF_RXEMPTY: ::std::os::raw::c_uint = 2147483648;
pub const SPIBUF_RXOVR: ::std::os::raw::c_uint = 1073741824;
pub const SPIBUF_TXFULL: ::std::os::raw::c_uint = 536870912;
pub const SPIBUF_BITERR: ::std::os::raw::c_uint = 268435456;
pub const SPIBUF_DESYNC: ::std::os::raw::c_uint = 134217728;
pub const SPIBUF_PARERR: ::std::os::raw::c_uint = 67108864;
pub const SPIBUF_TIMEOUT: ::std::os::raw::c_uint = 33554432;
pub const SPIBUF_DLENERR: ::std::os::raw::c_uint = 16777216;
pub const SPIINT0_DMAREQEN: ::std::os::raw::c_uint = 65536;
pub const SPIINT0_TXINTENA: ::std::os::raw::c_uint = 512;
pub const SPIINT0_RXINTENA: ::std::os::raw::c_uint = 256;
pub const SPILVL_TXINTLVL: ::std::os::raw::c_uint = 512;
pub const SPILVL_RXINTLVL: ::std::os::raw::c_uint = 256;
pub const PLL0_SYSCLK2_HZ: ::std::os::raw::c_uint = 150000000;
pub const CP15_CONTROL_XP_BIT: ::std::os::raw::c_uint = 8388608;
pub const CP15_CONTROL_V_BIT: ::std::os::raw::c_uint = 8192;
pub const CP15_CONTROL_I_BIT: ::std::os::raw::c_uint = 4096;
pub const CP15_CONTROL_C_BIT: ::std::os::raw::c_uint = 4;
pub const CP15_CONTROL_M_BIT: ::std::os::raw::c_uint = 1;
pub const CP15_AUXILIARY_SA_BIT: ::std::os::raw::c_uint = 64;
pub const CP15_AUXILIARY_EX_BIT: ::std::os::raw::c_uint = 128;
pub const CP15_CPUID_BIT: ::std::os::raw::c_uint = 3;
pub const CP15_TTB0_RGN_S: ::std::os::raw::c_uint = 2;
pub const CP15_TTB0_RGN_WBWA: ::std::os::raw::c_uint = 8;
pub const TMIN_FNCD: ::std::os::raw::c_int = -241;
pub const TFN_ACT_TSK: ::std::os::raw::c_int = -5;
pub const TFN_IACT_TSK: ::std::os::raw::c_int = -6;
pub const TFN_CAN_ACT: ::std::os::raw::c_int = -7;
pub const TFN_EXT_TSK: ::std::os::raw::c_int = -8;
pub const TFN_TER_TSK: ::std::os::raw::c_int = -9;
pub const TFN_CHG_PRI: ::std::os::raw::c_int = -10;
pub const TFN_GET_PRI: ::std::os::raw::c_int = -11;
pub const TFN_GET_INF: ::std::os::raw::c_int = -12;
pub const TFN_SLP_TSK: ::std::os::raw::c_int = -13;
pub const TFN_TSLP_TSK: ::std::os::raw::c_int = -14;
pub const TFN_WUP_TSK: ::std::os::raw::c_int = -15;
pub const TFN_IWUP_TSK: ::std::os::raw::c_int = -16;
pub const TFN_CAN_WUP: ::std::os::raw::c_int = -17;
pub const TFN_REL_WAI: ::std::os::raw::c_int = -18;
pub const TFN_IREL_WAI: ::std::os::raw::c_int = -19;
pub const TFN_DIS_WAI: ::std::os::raw::c_int = -21;
pub const TFN_IDIS_WAI: ::std::os::raw::c_int = -22;
pub const TFN_ENA_WAI: ::std::os::raw::c_int = -23;
pub const TFN_IENA_WAI: ::std::os::raw::c_int = -24;
pub const TFN_SUS_TSK: ::std::os::raw::c_int = -25;
pub const TFN_RSM_TSK: ::std::os::raw::c_int = -26;
pub const TFN_DLY_TSK: ::std::os::raw::c_int = -27;
pub const TFN_RAS_TEX: ::std::os::raw::c_int = -29;
pub const TFN_IRAS_TEX: ::std::os::raw::c_int = -30;
pub const TFN_DIS_TEX: ::std::os::raw::c_int = -31;
pub const TFN_ENA_TEX: ::std::os::raw::c_int = -32;
pub const TFN_SNS_TEX: ::std::os::raw::c_int = -33;
pub const TFN_REF_TEX: ::std::os::raw::c_int = -34;
pub const TFN_SIG_SEM: ::std::os::raw::c_int = -37;
pub const TFN_ISIG_SEM: ::std::os::raw::c_int = -38;
pub const TFN_WAI_SEM: ::std::os::raw::c_int = -39;
pub const TFN_POL_SEM: ::std::os::raw::c_int = -40;
pub const TFN_TWAI_SEM: ::std::os::raw::c_int = -41;
pub const TFN_SET_FLG: ::std::os::raw::c_int = -45;
pub const TFN_ISET_FLG: ::std::os::raw::c_int = -46;
pub const TFN_CLR_FLG: ::std::os::raw::c_int = -47;
pub const TFN_WAI_FLG: ::std::os::raw::c_int = -48;
pub const TFN_POL_FLG: ::std::os::raw::c_int = -49;
pub const TFN_TWAI_FLG: ::std::os::raw::c_int = -50;
pub const TFN_SND_DTQ: ::std::os::raw::c_int = -53;
pub const TFN_PSND_DTQ: ::std::os::raw::c_int = -54;
pub const TFN_IPSND_DTQ: ::std::os::raw::c_int = -55;
pub const TFN_TSND_DTQ: ::std::os::raw::c_int = -56;
pub const TFN_FSND_DTQ: ::std::os::raw::c_int = -57;
pub const TFN_IFSND_DTQ: ::std::os::raw::c_int = -58;
pub const TFN_RCV_DTQ: ::std::os::raw::c_int = -59;
pub const TFN_PRCV_DTQ: ::std::os::raw::c_int = -60;
pub const TFN_TRCV_DTQ: ::std::os::raw::c_int = -61;
pub const TFN_SND_PDQ: ::std::os::raw::c_int = -65;
pub const TFN_PSND_PDQ: ::std::os::raw::c_int = -66;
pub const TFN_IPSND_PDQ: ::std::os::raw::c_int = -67;
pub const TFN_TSND_PDQ: ::std::os::raw::c_int = -68;
pub const TFN_RCV_PDQ: ::std::os::raw::c_int = -69;
pub const TFN_PRCV_PDQ: ::std::os::raw::c_int = -70;
pub const TFN_TRCV_PDQ: ::std::os::raw::c_int = -71;
pub const TFN_SND_MBX: ::std::os::raw::c_int = -73;
pub const TFN_RCV_MBX: ::std::os::raw::c_int = -74;
pub const TFN_PRCV_MBX: ::std::os::raw::c_int = -75;
pub const TFN_TRCV_MBX: ::std::os::raw::c_int = -76;
pub const TFN_LOC_MTX: ::std::os::raw::c_int = -77;
pub const TFN_PLOC_MTX: ::std::os::raw::c_int = -78;
pub const TFN_TLOC_MTX: ::std::os::raw::c_int = -79;
pub const TFN_UNL_MTX: ::std::os::raw::c_int = -80;
pub const TFN_SND_MBF: ::std::os::raw::c_int = -81;
pub const TFN_PSND_MBF: ::std::os::raw::c_int = -82;
pub const TFN_TSND_MBF: ::std::os::raw::c_int = -83;
pub const TFN_RCV_MBF: ::std::os::raw::c_int = -84;
pub const TFN_PRCV_MBF: ::std::os::raw::c_int = -85;
pub const TFN_TRCV_MBF: ::std::os::raw::c_int = -86;
pub const TFN_GET_MPF: ::std::os::raw::c_int = -89;
pub const TFN_PGET_MPF: ::std::os::raw::c_int = -90;
pub const TFN_TGET_MPF: ::std::os::raw::c_int = -91;
pub const TFN_REL_MPF: ::std::os::raw::c_int = -92;
pub const TFN_GET_TIM: ::std::os::raw::c_int = -93;
pub const TFN_GET_UTM: ::std::os::raw::c_int = -94;
pub const TFN_REF_OVR: ::std::os::raw::c_int = -96;
pub const TFN_STA_CYC: ::std::os::raw::c_int = -97;
pub const TFN_STP_CYC: ::std::os::raw::c_int = -98;
pub const TFN_STA_ALM: ::std::os::raw::c_int = -101;
pub const TFN_ISTA_ALM: ::std::os::raw::c_int = -102;
pub const TFN_STP_ALM: ::std::os::raw::c_int = -103;
pub const TFN_ISTP_ALM: ::std::os::raw::c_int = -104;
pub const TFN_STA_OVR: ::std::os::raw::c_int = -105;
pub const TFN_ISTA_OVR: ::std::os::raw::c_int = -106;
pub const TFN_STP_OVR: ::std::os::raw::c_int = -107;
pub const TFN_ISTP_OVR: ::std::os::raw::c_int = -108;
pub const TFN_SAC_SYS: ::std::os::raw::c_int = -109;
pub const TFN_REF_SYS: ::std::os::raw::c_int = -110;
pub const TFN_ROT_RDQ: ::std::os::raw::c_int = -111;
pub const TFN_IROT_RDQ: ::std::os::raw::c_int = -112;
pub const TFN_GET_DID: ::std::os::raw::c_int = -113;
pub const TFN_GET_TID: ::std::os::raw::c_int = -115;
pub const TFN_IGET_TID: ::std::os::raw::c_int = -116;
pub const TFN_LOC_CPU: ::std::os::raw::c_int = -117;
pub const TFN_ILOC_CPU: ::std::os::raw::c_int = -118;
pub const TFN_UNL_CPU: ::std::os::raw::c_int = -119;
pub const TFN_IUNL_CPU: ::std::os::raw::c_int = -120;
pub const TFN_DIS_DSP: ::std::os::raw::c_int = -121;
pub const TFN_ENA_DSP: ::std::os::raw::c_int = -122;
pub const TFN_SNS_CTX: ::std::os::raw::c_int = -123;
pub const TFN_SNS_LOC: ::std::os::raw::c_int = -124;
pub const TFN_SNS_DSP: ::std::os::raw::c_int = -125;
pub const TFN_SNS_DPN: ::std::os::raw::c_int = -126;
pub const TFN_SNS_KER: ::std::os::raw::c_int = -127;
pub const TFN_EXT_KER: ::std::os::raw::c_int = -128;
pub const TFN_ATT_MEM: ::std::os::raw::c_int = -129;
pub const TFN_DET_MEM: ::std::os::raw::c_int = -130;
pub const TFN_SAC_MEM: ::std::os::raw::c_int = -131;
pub const TFN_PRB_MEM: ::std::os::raw::c_int = -132;
pub const TFN_REF_MEM: ::std::os::raw::c_int = -133;
pub const TFN_ATT_PMA: ::std::os::raw::c_int = -135;
pub const TFN_CFG_INT: ::std::os::raw::c_int = -137;
pub const TFN_DIS_INT: ::std::os::raw::c_int = -138;
pub const TFN_ENA_INT: ::std::os::raw::c_int = -139;
pub const TFN_REF_INT: ::std::os::raw::c_int = -140;
pub const TFN_CHG_IPM: ::std::os::raw::c_int = -141;
pub const TFN_GET_IPM: ::std::os::raw::c_int = -142;
pub const TFN_XSNS_DPN: ::std::os::raw::c_int = -145;
pub const TFN_XSNS_XPN: ::std::os::raw::c_int = -146;
pub const TFN_REF_CFG: ::std::os::raw::c_int = -149;
pub const TFN_REF_VER: ::std::os::raw::c_int = -150;
pub const TFN_INI_SEM: ::std::os::raw::c_int = -162;
pub const TFN_INI_FLG: ::std::os::raw::c_int = -163;
pub const TFN_INI_DTQ: ::std::os::raw::c_int = -164;
pub const TFN_INI_PDQ: ::std::os::raw::c_int = -165;
pub const TFN_INI_MBX: ::std::os::raw::c_int = -166;
pub const TFN_INI_MTX: ::std::os::raw::c_int = -167;
pub const TFN_INI_MBF: ::std::os::raw::c_int = -168;
pub const TFN_INI_MPF: ::std::os::raw::c_int = -169;
pub const TFN_REF_TSK: ::std::os::raw::c_int = -177;
pub const TFN_REF_SEM: ::std::os::raw::c_int = -178;
pub const TFN_REF_FLG: ::std::os::raw::c_int = -179;
pub const TFN_REF_DTQ: ::std::os::raw::c_int = -180;
pub const TFN_REF_PDQ: ::std::os::raw::c_int = -181;
pub const TFN_REF_MBX: ::std::os::raw::c_int = -182;
pub const TFN_REF_MTX: ::std::os::raw::c_int = -183;
pub const TFN_REF_MBF: ::std::os::raw::c_int = -184;
pub const TFN_REF_MPF: ::std::os::raw::c_int = -185;
pub const TFN_REF_CYC: ::std::os::raw::c_int = -186;
pub const TFN_REF_ALM: ::std::os::raw::c_int = -187;
pub const TFN_REF_ISR: ::std::os::raw::c_int = -188;
pub const TFN_REF_SPN: ::std::os::raw::c_int = -189;
pub const TFN_ACRE_TSK: ::std::os::raw::c_int = -193;
pub const TFN_ACRE_SEM: ::std::os::raw::c_int = -194;
pub const TFN_ACRE_FLG: ::std::os::raw::c_int = -195;
pub const TFN_ACRE_DTQ: ::std::os::raw::c_int = -196;
pub const TFN_ACRE_PDQ: ::std::os::raw::c_int = -197;
pub const TFN_ACRE_MBX: ::std::os::raw::c_int = -198;
pub const TFN_ACRE_MTX: ::std::os::raw::c_int = -199;
pub const TFN_ACRE_MBF: ::std::os::raw::c_int = -200;
pub const TFN_ACRE_MPF: ::std::os::raw::c_int = -201;
pub const TFN_ACRE_CYC: ::std::os::raw::c_int = -202;
pub const TFN_ACRE_ALM: ::std::os::raw::c_int = -203;
pub const TFN_ACRE_ISR: ::std::os::raw::c_int = -204;
pub const TFN_ACRE_SPN: ::std::os::raw::c_int = -205;
pub const TFN_DEL_TSK: ::std::os::raw::c_int = -209;
pub const TFN_DEL_SEM: ::std::os::raw::c_int = -210;
pub const TFN_DEL_FLG: ::std::os::raw::c_int = -211;
pub const TFN_DEL_DTQ: ::std::os::raw::c_int = -212;
pub const TFN_DEL_PDQ: ::std::os::raw::c_int = -213;
pub const TFN_DEL_MBX: ::std::os::raw::c_int = -214;
pub const TFN_DEL_MTX: ::std::os::raw::c_int = -215;
pub const TFN_DEL_MBF: ::std::os::raw::c_int = -216;
pub const TFN_DEL_MPF: ::std::os::raw::c_int = -217;
pub const TFN_DEL_CYC: ::std::os::raw::c_int = -218;
pub const TFN_DEL_ALM: ::std::os::raw::c_int = -219;
pub const TFN_DEL_ISR: ::std::os::raw::c_int = -220;
pub const TFN_DEL_SPN: ::std::os::raw::c_int = -221;
pub const TFN_SAC_TSK: ::std::os::raw::c_int = -225;
pub const TFN_SAC_SEM: ::std::os::raw::c_int = -226;
pub const TFN_SAC_FLG: ::std::os::raw::c_int = -227;
pub const TFN_SAC_DTQ: ::std::os::raw::c_int = -228;
pub const TFN_SAC_PDQ: ::std::os::raw::c_int = -229;
pub const TFN_SAC_MTX: ::std::os::raw::c_int = -231;
pub const TFN_SAC_MBF: ::std::os::raw::c_int = -232;
pub const TFN_SAC_MPF: ::std::os::raw::c_int = -233;
pub const TFN_SAC_CYC: ::std::os::raw::c_int = -234;
pub const TFN_SAC_ALM: ::std::os::raw::c_int = -235;
pub const TFN_SAC_ISR: ::std::os::raw::c_int = -236;
pub const TFN_SAC_SPN: ::std::os::raw::c_int = -237;
pub const TFN_DEF_TEX: ::std::os::raw::c_int = -241;
pub const TFN_DEF_OVR: ::std::os::raw::c_int = -242;
pub const TFN_DEF_INH: ::std::os::raw::c_int = -243;
pub const TFN_DEF_EXC: ::std::os::raw::c_int = -244;
pub const TFN_DEF_SVC: ::std::os::raw::c_int = -245;
pub const TFN_MACT_TSK: ::std::os::raw::c_int = -257;
pub const TFN_IMACT_TSK: ::std::os::raw::c_int = -258;
pub const TFN_MIG_TSK: ::std::os::raw::c_int = -259;
pub const TFN_MSTA_CYC: ::std::os::raw::c_int = -261;
pub const TFN_MSTA_ALM: ::std::os::raw::c_int = -263;
pub const TFN_IMSTA_ALM: ::std::os::raw::c_int = -264;
pub const TFN_MROT_RDQ: ::std::os::raw::c_int = -265;
pub const TFN_IMROT_RDQ: ::std::os::raw::c_int = -266;
pub const TFN_GET_PID: ::std::os::raw::c_int = -267;
pub const TFN_IGET_PID: ::std::os::raw::c_int = -268;
pub const TFN_LOC_SPN: ::std::os::raw::c_int = -273;
pub const TFN_ILOC_SPN: ::std::os::raw::c_int = -274;
pub const TFN_TRY_SPN: ::std::os::raw::c_int = -275;
pub const TFN_ITRY_SPN: ::std::os::raw::c_int = -276;
pub const TFN_UNL_SPN: ::std::os::raw::c_int = -277;
pub const TFN_IUNL_SPN: ::std::os::raw::c_int = -278;
pub const SERVICE_CALL_NUM: ::std::os::raw::c_uint = 1;
pub const TDOM_SELF: ::std::os::raw::c_uint = 0;
pub const TDOM_KERNEL: ::std::os::raw::c_int = -1;
pub const TDOM_NONE: ::std::os::raw::c_int = -2;
pub const TSK_SELF: ::std::os::raw::c_uint = 0;
pub const TSK_NONE: ::std::os::raw::c_uint = 0;
pub const TPRI_SELF: ::std::os::raw::c_uint = 0;
pub const TPRI_INI: ::std::os::raw::c_uint = 0;
pub const TIPM_ENAALL: ::std::os::raw::c_uint = 0;
pub const TMIN_TPRI: ::std::os::raw::c_uint = 1;
pub const TMAX_TPRI: ::std::os::raw::c_uint = 16;
pub const TMIN_DPRI: ::std::os::raw::c_uint = 1;
pub const TMAX_DPRI: ::std::os::raw::c_uint = 16;
pub const TMIN_ISRPRI: ::std::os::raw::c_uint = 1;
pub const TMAX_ISRPRI: ::std::os::raw::c_uint = 16;
pub const TMAX_OVRTIM: ::std::os::raw::c_int = -1;
pub const TMAX_MAXSEM: ::std::os::raw::c_uint = 4294967295;
pub const TFN_SYSLOG_WRI_LOG: ::std::os::raw::c_uint = 1;
pub const TFN_SYSLOG_FWRI_LOG: ::std::os::raw::c_uint = 2;
pub const TFN_SYSLOG_REA_LOG: ::std::os::raw::c_uint = 3;
pub const TFN_SYSLOG_MSK_LOG: ::std::os::raw::c_uint = 4;
pub const TFN_SYSLOG_REF_LOG: ::std::os::raw::c_uint = 5;
pub const TFN_SERIAL_OPN_POR: ::std::os::raw::c_uint = 7;
pub const TFN_SERIAL_CLS_POR: ::std::os::raw::c_uint = 8;
pub const TFN_SERIAL_REA_DAT: ::std::os::raw::c_uint = 9;
pub const TFN_SERIAL_WRI_DAT: ::std::os::raw::c_uint = 10;
pub const TFN_SERIAL_CTL_POR: ::std::os::raw::c_uint = 11;
pub const TFN_SERIAL_REF_POR: ::std::os::raw::c_uint = 12;
pub const TFN_LOGTASK_FLUSH: ::std::os::raw::c_uint = 14;
pub const TFN_TEST_CHECK_POINT: ::std::os::raw::c_uint = 16;
pub const TFN_TEST_CHECK_ASSERT_ERROR: ::std::os::raw::c_uint = 17;
pub const TFN_TEST_CHECK_ERCD_ERROR: ::std::os::raw::c_uint = 18;
pub const TFN_TEST_SET_BIT_FUNC: ::std::os::raw::c_uint = 19;
pub const TFN_TEST_SYSLOG_FLUSH: ::std::os::raw::c_uint = 20;
pub const TFN_TEST_TEST_FINISH: ::std::os::raw::c_uint = 21;
pub const TMAX_LOGINFO: ::std::os::raw::c_uint = 6;
pub const __MAC_10_0: ::std::os::raw::c_uint = 1000;
pub const __MAC_10_1: ::std::os::raw::c_uint = 1010;
pub const __MAC_10_2: ::std::os::raw::c_uint = 1020;
pub const __MAC_10_3: ::std::os::raw::c_uint = 1030;
pub const __MAC_10_4: ::std::os::raw::c_uint = 1040;
pub const __MAC_10_5: ::std::os::raw::c_uint = 1050;
pub const __MAC_10_6: ::std::os::raw::c_uint = 1060;
pub const __MAC_10_7: ::std::os::raw::c_uint = 1070;
pub const __MAC_10_8: ::std::os::raw::c_uint = 1080;
pub const __MAC_10_9: ::std::os::raw::c_uint = 1090;
pub const __MAC_10_10: ::std::os::raw::c_uint = 101000;
pub const __MAC_10_10_2: ::std::os::raw::c_uint = 101002;
pub const __MAC_10_10_3: ::std::os::raw::c_uint = 101003;
pub const __MAC_10_11: ::std::os::raw::c_uint = 101100;
pub const __MAC_10_11_2: ::std::os::raw::c_uint = 101102;
pub const __MAC_10_11_3: ::std::os::raw::c_uint = 101103;
pub const __MAC_10_11_4: ::std::os::raw::c_uint = 101104;
pub const __MAC_10_12: ::std::os::raw::c_uint = 101200;
pub const __MAC_10_12_1: ::std::os::raw::c_uint = 101201;
pub const __MAC_10_12_2: ::std::os::raw::c_uint = 101202;
pub const __MAC_10_12_4: ::std::os::raw::c_uint = 101204;
pub const __MAC_10_13: ::std::os::raw::c_uint = 101300;
pub const __MAC_10_13_1: ::std::os::raw::c_uint = 101301;
pub const __MAC_10_13_2: ::std::os::raw::c_uint = 101302;
pub const __MAC_10_13_4: ::std::os::raw::c_uint = 101304;
pub const __IPHONE_2_0: ::std::os::raw::c_uint = 20000;
pub const __IPHONE_2_1: ::std::os::raw::c_uint = 20100;
pub const __IPHONE_2_2: ::std::os::raw::c_uint = 20200;
pub const __IPHONE_3_0: ::std::os::raw::c_uint = 30000;
pub const __IPHONE_3_1: ::std::os::raw::c_uint = 30100;
pub const __IPHONE_3_2: ::std::os::raw::c_uint = 30200;
pub const __IPHONE_4_0: ::std::os::raw::c_uint = 40000;
pub const __IPHONE_4_1: ::std::os::raw::c_uint = 40100;
pub const __IPHONE_4_2: ::std::os::raw::c_uint = 40200;
pub const __IPHONE_4_3: ::std::os::raw::c_uint = 40300;
pub const __IPHONE_5_0: ::std::os::raw::c_uint = 50000;
pub const __IPHONE_5_1: ::std::os::raw::c_uint = 50100;
pub const __IPHONE_6_0: ::std::os::raw::c_uint = 60000;
pub const __IPHONE_6_1: ::std::os::raw::c_uint = 60100;
pub const __IPHONE_7_0: ::std::os::raw::c_uint = 70000;
pub const __IPHONE_7_1: ::std::os::raw::c_uint = 70100;
pub const __IPHONE_8_0: ::std::os::raw::c_uint = 80000;
pub const __IPHONE_8_1: ::std::os::raw::c_uint = 80100;
pub const __IPHONE_8_2: ::std::os::raw::c_uint = 80200;
pub const __IPHONE_8_3: ::std::os::raw::c_uint = 80300;
pub const __IPHONE_8_4: ::std::os::raw::c_uint = 80400;
pub const __IPHONE_9_0: ::std::os::raw::c_uint = 90000;
pub const __IPHONE_9_1: ::std::os::raw::c_uint = 90100;
pub const __IPHONE_9_2: ::std::os::raw::c_uint = 90200;
pub const __IPHONE_9_3: ::std::os::raw::c_uint = 90300;
pub const __IPHONE_10_0: ::std::os::raw::c_uint = 100000;
pub const __IPHONE_10_1: ::std::os::raw::c_uint = 100100;
pub const __IPHONE_10_2: ::std::os::raw::c_uint = 100200;
pub const __IPHONE_10_3: ::std::os::raw::c_uint = 100300;
pub const __IPHONE_11_0: ::std::os::raw::c_uint = 110000;
pub const __IPHONE_11_1: ::std::os::raw::c_uint = 110100;
pub const __IPHONE_11_2: ::std::os::raw::c_uint = 110200;
pub const __IPHONE_11_3: ::std::os::raw::c_uint = 110300;
pub const __TVOS_9_0: ::std::os::raw::c_uint = 90000;
pub const __TVOS_9_1: ::std::os::raw::c_uint = 90100;
pub const __TVOS_9_2: ::std::os::raw::c_uint = 90200;
pub const __TVOS_10_0: ::std::os::raw::c_uint = 100000;
pub const __TVOS_10_0_1: ::std::os::raw::c_uint = 100001;
pub const __TVOS_10_1: ::std::os::raw::c_uint = 100100;
pub const __TVOS_10_2: ::std::os::raw::c_uint = 100200;
pub const __TVOS_11_0: ::std::os::raw::c_uint = 110000;
pub const __TVOS_11_1: ::std::os::raw::c_uint = 110100;
pub const __TVOS_11_2: ::std::os::raw::c_uint = 110200;
pub const __TVOS_11_3: ::std::os::raw::c_uint = 110300;
pub const __WATCHOS_1_0: ::std::os::raw::c_uint = 10000;
pub const __WATCHOS_2_0: ::std::os::raw::c_uint = 20000;
pub const __WATCHOS_2_1: ::std::os::raw::c_uint = 20100;
pub const __WATCHOS_2_2: ::std::os::raw::c_uint = 20200;
pub const __WATCHOS_3_0: ::std::os::raw::c_uint = 30000;
pub const __WATCHOS_3_1: ::std::os::raw::c_uint = 30100;
pub const __WATCHOS_3_1_1: ::std::os::raw::c_uint = 30101;
pub const __WATCHOS_3_2: ::std::os::raw::c_uint = 30200;
pub const __WATCHOS_4_0: ::std::os::raw::c_uint = 40000;
pub const __WATCHOS_4_1: ::std::os::raw::c_uint = 40100;
pub const __WATCHOS_4_2: ::std::os::raw::c_uint = 40200;
pub const __WATCHOS_4_3: ::std::os::raw::c_uint = 40300;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: ::std::os::raw::c_uint = 101304;
pub const __DARWIN_WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const _FORTIFY_SOURCE: ::std::os::raw::c_uint = 2;
pub const RENAME_SECLUDE: ::std::os::raw::c_uint = 1;
pub const RENAME_SWAP: ::std::os::raw::c_uint = 2;
pub const RENAME_EXCL: ::std::os::raw::c_uint = 4;
pub const __SLBF: ::std::os::raw::c_uint = 1;
pub const __SNBF: ::std::os::raw::c_uint = 2;
pub const __SRD: ::std::os::raw::c_uint = 4;
pub const __SWR: ::std::os::raw::c_uint = 8;
pub const __SRW: ::std::os::raw::c_uint = 16;
pub const __SEOF: ::std::os::raw::c_uint = 32;
pub const __SERR: ::std::os::raw::c_uint = 64;
pub const __SMBF: ::std::os::raw::c_uint = 128;
pub const __SAPP: ::std::os::raw::c_uint = 256;
pub const __SSTR: ::std::os::raw::c_uint = 512;
pub const __SOPT: ::std::os::raw::c_uint = 1024;
pub const __SNPT: ::std::os::raw::c_uint = 2048;
pub const __SOFF: ::std::os::raw::c_uint = 4096;
pub const __SMOD: ::std::os::raw::c_uint = 8192;
pub const __SALC: ::std::os::raw::c_uint = 16384;
pub const __SIGN: ::std::os::raw::c_uint = 32768;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 1024;
pub const EOF: ::std::os::raw::c_int = -1;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 20;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 1024;
pub const TMP_MAX: ::std::os::raw::c_uint = 308915776;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const L_ctermid: ::std::os::raw::c_uint = 1024;
pub const __CTERMID_DEFINED: ::std::os::raw::c_uint = 1;
pub const _USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 2;
pub const TMAX_FILENAME_LEN: ::std::os::raw::c_uint = 255;
pub const EV3_LCD_WIDTH: ::std::os::raw::c_uint = 178;
pub const EV3_LCD_HEIGHT: ::std::os::raw::c_uint = 128;
pub const IR_RED_UP_BUTTON: ::std::os::raw::c_uint = 1;
pub const IR_RED_DOWN_BUTTON: ::std::os::raw::c_uint = 2;
pub const IR_BLUE_UP_BUTTON: ::std::os::raw::c_uint = 4;
pub const IR_BLUE_DOWN_BUTTON: ::std::os::raw::c_uint = 8;
pub const IR_BEACON_BUTTON: ::std::os::raw::c_uint = 16;
pub const SOUND_MANUAL_STOP: ::std::os::raw::c_int = -1;
pub const NOTE_C4: f64 = 261.63;
pub const NOTE_CS4: f64 = 277.18;
pub const NOTE_D4: f64 = 293.66;
pub const NOTE_DS4: f64 = 311.13;
pub const NOTE_E4: f64 = 329.63;
pub const NOTE_F4: f64 = 349.23;
pub const NOTE_FS4: f64 = 369.99;
pub const NOTE_G4: f64 = 392.;
pub const NOTE_GS4: f64 = 415.3;
pub const NOTE_A4: f64 = 440.;
pub const NOTE_AS4: f64 = 466.16;
pub const NOTE_B4: f64 = 493.88;
pub const NOTE_C5: f64 = 523.25;
pub const NOTE_CS5: f64 = 554.37;
pub const NOTE_D5: f64 = 587.33;
pub const NOTE_DS5: f64 = 622.25;
pub const NOTE_E5: f64 = 659.25;
pub const NOTE_F5: f64 = 698.46;
pub const NOTE_FS5: f64 = 739.99;
pub const NOTE_G5: f64 = 783.99;
pub const NOTE_GS5: f64 = 830.61;
pub const NOTE_A5: f64 = 880.;
pub const NOTE_AS5: f64 = 932.33;
pub const NOTE_B5: f64 = 987.77;
pub const NOTE_C6: f64 = 1046.5;
pub const NOTE_CS6: f64 = 1108.73;
pub const NOTE_D6: f64 = 1174.66;
pub const NOTE_DS6: f64 = 1244.51;
pub const NOTE_E6: f64 = 1318.51;
pub const NOTE_F6: f64 = 1396.91;
pub const NOTE_FS6: f64 = 1479.98;
pub const NOTE_G6: f64 = 1567.98;
pub const NOTE_GS6: f64 = 1661.22;
pub const NOTE_A6: f64 = 1760.;
pub const NOTE_AS6: f64 = 1864.66;
pub const NOTE_B6: f64 = 1975.53;
pub const TNUM_DOMID: ::std::os::raw::c_uint = 1;
pub const TNUM_TSKID: ::std::os::raw::c_uint = 60;
pub const TNUM_SEMID: ::std::os::raw::c_uint = 30;
pub const TNUM_FLGID: ::std::os::raw::c_uint = 20;
pub const TNUM_DTQID: ::std::os::raw::c_uint = 80;
pub const TNUM_PDQID: ::std::os::raw::c_uint = 16;
pub const TNUM_MTXID: ::std::os::raw::c_uint = 21;
pub const TNUM_MPFID: ::std::os::raw::c_uint = 4;
pub const TNUM_CYCID: ::std::os::raw::c_uint = 21;
pub const TNUM_ALMID: ::std::os::raw::c_uint = 1;
pub const TNUM_ISRID: ::std::os::raw::c_uint = 1;
pub const TDOM_APP: ::std::os::raw::c_uint = 1;
pub const LOGTASK: ::std::os::raw::c_uint = 1;
pub const BRICK_BTN_TSK: ::std::os::raw::c_uint = 2;
pub const LCD_REFRESH_TSK: ::std::os::raw::c_uint = 3;
pub const CONSOLE_BTN_TSK: ::std::os::raw::c_uint = 4;
pub const BT_TSK: ::std::os::raw::c_uint = 5;
pub const BT_QOS_TSK: ::std::os::raw::c_uint = 6;
pub const USBMSC_TSK: ::std::os::raw::c_uint = 7;
pub const EV3_INIT_TASK: ::std::os::raw::c_uint = 8;
pub const PLATFORM_BUSY_TASK: ::std::os::raw::c_uint = 9;
pub const EV3RT_LOGTASK: ::std::os::raw::c_uint = 10;
pub const APP_TERM_TASK: ::std::os::raw::c_uint = 11;
pub const ZMODEM_RECV_TASK: ::std::os::raw::c_uint = 12;
pub const SERIAL_RCV_SEM1: ::std::os::raw::c_uint = 1;
pub const SERIAL_SND_SEM1: ::std::os::raw::c_uint = 2;
pub const SERIAL_RCV_SEM2: ::std::os::raw::c_uint = 3;
pub const SERIAL_SND_SEM2: ::std::os::raw::c_uint = 4;
pub const SERIAL_RCV_SEM3: ::std::os::raw::c_uint = 5;
pub const SERIAL_SND_SEM3: ::std::os::raw::c_uint = 6;
pub const SERIAL_RCV_SEM4: ::std::os::raw::c_uint = 7;
pub const SERIAL_SND_SEM4: ::std::os::raw::c_uint = 8;
pub const MMCSD_MOD_SEM: ::std::os::raw::c_uint = 9;
pub const FATFS_SEM: ::std::os::raw::c_uint = 10;
pub const LCD_DMA_DONE_SEM: ::std::os::raw::c_uint = 11;
pub const SUART1_SEM: ::std::os::raw::c_uint = 12;
pub const SUART2_SEM: ::std::os::raw::c_uint = 13;
pub const SND_DEV_SEM: ::std::os::raw::c_uint = 14;
pub const BTN_CLICK_FLG: ::std::os::raw::c_uint = 1;
pub const CONSOLE_BTN_CLICK_FLG: ::std::os::raw::c_uint = 2;
pub const USBMSC_EVT_FLG: ::std::os::raw::c_uint = 3;
pub const APP_STATUS_FLAG: ::std::os::raw::c_uint = 4;
pub const DISKIO_MTX: ::std::os::raw::c_uint = 1;
pub const EV3RT_CONSOLE_MTX: ::std::os::raw::c_uint = 2;
pub const EV3RT_CONSOLE_LOG_MTX: ::std::os::raw::c_uint = 3;
pub const BT_DB_MTX: ::std::os::raw::c_uint = 4;
pub const DMLOADER_MTX: ::std::os::raw::c_uint = 5;
pub const BT_SIO_CYC: ::std::os::raw::c_uint = 1;
pub const DBSIO_TEST_SPP_MASTER_SIO_CYC: ::std::os::raw::c_uint = 2;
pub const BRICK_BTN_CYC: ::std::os::raw::c_uint = 3;
pub const BT_DMA_CYC: ::std::os::raw::c_uint = 4;
pub const EV3_BATTERY_MONITOR_CYC: ::std::os::raw::c_uint = 5;
pub const SND_STOP_ALM: ::std::os::raw::c_uint = 1;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __mbstate8: __BindgenUnionField<[::std::os::raw::c_char; 128usize]>,
    pub _mbstateL: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_pthread_handler_rec ) ));
    assert_eq! (::std::mem::align_of::<__darwin_pthread_handler_rec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_pthread_handler_rec )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) .
                __routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! (
                __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __arg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __arg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __next
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __next )
                ));
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_attr_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_attr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_cond_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_cond_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_condattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __sig as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutexattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutexattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_once_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_once_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_once_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __opaque )
                ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlockattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>() , 8192usize , concat
               ! ( "Size of: " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __sig as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __cleanup_stack
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __cleanup_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __opaque as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __opaque ) ));
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type rsize_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type ldsymbol_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TOPPERS_dummy_t {
    pub TOPPERS_dummy_field: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TOPPERS_dummy_t() {
    assert_eq!(::std::mem::size_of::<TOPPERS_dummy_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TOPPERS_dummy_t ) ));
    assert_eq! (::std::mem::align_of::<TOPPERS_dummy_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( TOPPERS_dummy_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TOPPERS_dummy_t ) ) . TOPPERS_dummy_field
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TOPPERS_dummy_t ) ,
                "::" , stringify ! ( TOPPERS_dummy_field ) ));
}
impl Clone for TOPPERS_dummy_t {
    fn clone(&self) -> Self { *self }
}
pub type TOPPERS_fp_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: TOPPERS_dummy_t)>;
pub type bool_t = ::std::os::raw::c_int;
pub type int_t = ::std::os::raw::c_int;
pub type uint_t = ::std::os::raw::c_uint;
pub type long_t = ::std::os::raw::c_long;
pub type ulong_t = ::std::os::raw::c_ulong;
pub type FN = int_t;
pub type ER = int_t;
pub type ID = int_t;
pub type ATR = uint_t;
pub type STAT = uint_t;
pub type MODE = uint_t;
pub type PRI = int_t;
pub type SIZE = usize;
pub type TMO = int_t;
pub type RELTIM = uint_t;
pub type SYSTIM = ulong_t;
pub type SYSUTM = ulong_t;
pub type FP = TOPPERS_fp_t;
pub type ER_BOOL = int_t;
pub type ER_ID = int_t;
pub type ER_UINT = int_t;
pub type MB_T = usize;
pub type ACPTN = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct acvct {
    pub acptn1: ACPTN,
    pub acptn2: ACPTN,
    pub acptn3: ACPTN,
    pub acptn4: ACPTN,
}
#[test]
fn bindgen_test_layout_acvct() {
    assert_eq!(::std::mem::size_of::<acvct>() , 16usize , concat ! (
               "Size of: " , stringify ! ( acvct ) ));
    assert_eq! (::std::mem::align_of::<acvct>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( acvct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const acvct ) ) . acptn1 as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( acvct ) , "::" ,
                stringify ! ( acptn1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const acvct ) ) . acptn2 as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( acvct ) , "::" ,
                stringify ! ( acptn2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const acvct ) ) . acptn3 as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( acvct ) , "::" ,
                stringify ! ( acptn3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const acvct ) ) . acptn4 as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( acvct ) , "::" ,
                stringify ! ( acptn4 ) ));
}
impl Clone for acvct {
    fn clone(&self) -> Self { *self }
}
pub type ACVCT = acvct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sio_port_control_block {
    _unused: [u8; 0],
}
pub type SIOPCB = sio_port_control_block;
extern "C" {
    pub fn sio_initialize_low();
}
extern "C" {
    pub fn sio_opn_por(siopid: ID, exinf: isize) -> *mut SIOPCB;
}
extern "C" {
    pub fn sio_cls_por(p_siopcb: *mut SIOPCB);
}
extern "C" {
    pub fn uart_sio_isr(exinf: isize);
}
extern "C" {
    pub fn uart_sio_cyc(exinf: isize);
}
extern "C" {
    pub fn sio_snd_chr(siopcb: *mut SIOPCB, c: ::std::os::raw::c_char)
     -> bool_t;
}
extern "C" {
    pub fn sio_rcv_chr(siopcb: *mut SIOPCB) -> int_t;
}
extern "C" {
    pub fn sio_ena_cbr(siopcb: *mut SIOPCB, cbrtn: uint_t);
}
extern "C" {
    pub fn sio_dis_cbr(siopcb: *mut SIOPCB, cbrtn: uint_t);
}
extern "C" {
    pub fn sio_irdy_snd(exinf: isize);
}
extern "C" {
    pub fn sio_irdy_rcv(exinf: isize);
}
extern "C" {
    pub fn bt_rcv_handler(data: *const u8, size: u16);
}
extern "C" {
    pub fn bt_sio_cyc(exinf: isize);
}
extern "C" {
    /**
 * Fetch the send buffer of Bluetooth into @buf.
 * The send buffer will be cleared (switched).
 * @param buf   a pointer to store base address of fetched send buffer.
 * @param bytes a pointer to store data size of fetched send buffer.
 */
    pub fn bt_fetch_snd_buf(buf: *mut *mut u8, bytes: *mut u32);
}
extern "C" {
    /**
 * Send a character to the LCD console
 */
    pub fn lcd_console_send_character(c: ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "SIO_PORT_DEFAULT"]
    pub static mut SIO_PORT_DEFAULT: ::std::os::raw::c_int;
}
extern "C" {
    pub fn svc_perror(file: *const ::std::os::raw::c_char, line: int_t,
                      expr: *const ::std::os::raw::c_char, ercd: ER);
}
extern "C" {
    pub fn pru_suart_isr(portline: isize);
}
#[repr(C)]
pub struct st_aintc {
    pub REVID: ::std::os::raw::c_ulong,
    pub CR: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 2usize],
    pub GER: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 2usize],
    pub GNLR: ::std::os::raw::c_ulong,
    pub SISR: ::std::os::raw::c_ulong,
    pub SICR: ::std::os::raw::c_ulong,
    pub EISR: ::std::os::raw::c_ulong,
    pub EICR: ::std::os::raw::c_ulong,
    pub Reserved3: ::std::os::raw::c_ulong,
    pub HIEISR: ::std::os::raw::c_ulong,
    pub HIEICR: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 5usize],
    pub VBR: ::std::os::raw::c_ulong,
    pub VSR: ::std::os::raw::c_ulong,
    pub VNR: ::std::os::raw::c_ulong,
    pub Reserved5: [::std::os::raw::c_ulong; 9usize],
    pub GPIR: ::std::os::raw::c_ulong,
    pub GPVR: ::std::os::raw::c_ulong,
    pub Reserved6: [::std::os::raw::c_ulong; 94usize],
    pub SRSR1: ::std::os::raw::c_ulong,
    pub SRSR2: ::std::os::raw::c_ulong,
    pub SRSR3: ::std::os::raw::c_ulong,
    pub SRSR4: ::std::os::raw::c_ulong,
    pub Reserved7: [::std::os::raw::c_ulong; 28usize],
    pub SECR1: ::std::os::raw::c_ulong,
    pub SECR2: ::std::os::raw::c_ulong,
    pub SECR3: ::std::os::raw::c_ulong,
    pub SECR4: ::std::os::raw::c_ulong,
    pub Reserved8: [::std::os::raw::c_ulong; 28usize],
    pub ESR1: ::std::os::raw::c_ulong,
    pub ESR2: ::std::os::raw::c_ulong,
    pub ESR3: ::std::os::raw::c_ulong,
    pub ESR4: ::std::os::raw::c_ulong,
    pub Reserved9: [::std::os::raw::c_ulong; 28usize],
    pub ECR1: ::std::os::raw::c_ulong,
    pub ECR2: ::std::os::raw::c_ulong,
    pub ECR3: ::std::os::raw::c_ulong,
    pub ECR4: ::std::os::raw::c_ulong,
    pub Reserved10: [::std::os::raw::c_ulong; 28usize],
    pub CMR: [::std::os::raw::c_uchar; 104usize],
    pub Reserved11: [::std::os::raw::c_ulong; 294usize],
    pub HIPIR1: ::std::os::raw::c_ulong,
    pub HIPIR2: ::std::os::raw::c_ulong,
    pub Reserved12: [::std::os::raw::c_ulong; 510usize],
    pub HINLR1: ::std::os::raw::c_ulong,
    pub HINLR2: ::std::os::raw::c_ulong,
    pub Reserved13: [::std::os::raw::c_ulong; 254usize],
    pub HIER: ::std::os::raw::c_ulong,
    pub Reserved14: [::std::os::raw::c_ulong; 63usize],
    pub HIPVR1: ::std::os::raw::c_ulong,
    pub HIPVR2: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_aintc() {
    assert_eq!(::std::mem::size_of::<st_aintc>() , 11176usize , concat ! (
               "Size of: " , stringify ! ( st_aintc ) ));
    assert_eq! (::std::mem::align_of::<st_aintc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_aintc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . REVID as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . CR as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( CR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved1 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . GER as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( GER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved2 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . GNLR as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( GNLR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SISR as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SISR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SICR as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SICR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . EISR as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( EISR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . EICR as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( EICR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved3 as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HIEISR as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HIEISR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HIEICR as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HIEICR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved4 as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . VBR as * const _ as usize
                } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( VBR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . VSR as * const _ as usize
                } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( VSR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . VNR as * const _ as usize
                } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( VNR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved5 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . GPIR as * const _ as usize
                } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( GPIR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . GPVR as * const _ as usize
                } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( GPVR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved6 as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SRSR1 as * const _ as
                usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SRSR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SRSR2 as * const _ as
                usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SRSR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SRSR3 as * const _ as
                usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SRSR3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SRSR4 as * const _ as
                usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SRSR4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved7 as * const _ as
                usize } , 1056usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SECR1 as * const _ as
                usize } , 1280usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SECR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SECR2 as * const _ as
                usize } , 1288usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SECR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SECR3 as * const _ as
                usize } , 1296usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SECR3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SECR4 as * const _ as
                usize } , 1304usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SECR4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved8 as * const _ as
                usize } , 1312usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . ESR1 as * const _ as usize
                } , 1536usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( ESR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . ESR2 as * const _ as usize
                } , 1544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( ESR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . ESR3 as * const _ as usize
                } , 1552usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( ESR3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . ESR4 as * const _ as usize
                } , 1560usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( ESR4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved9 as * const _ as
                usize } , 1568usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . ECR1 as * const _ as usize
                } , 1792usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( ECR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . ECR2 as * const _ as usize
                } , 1800usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( ECR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . ECR3 as * const _ as usize
                } , 1808usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( ECR3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . ECR4 as * const _ as usize
                } , 1816usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( ECR4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved10 as * const _ as
                usize } , 1824usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . CMR as * const _ as usize
                } , 2048usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( CMR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved11 as * const _ as
                usize } , 2152usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HIPIR1 as * const _ as
                usize } , 4504usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HIPIR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HIPIR2 as * const _ as
                usize } , 4512usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HIPIR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved12 as * const _ as
                usize } , 4520usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HINLR1 as * const _ as
                usize } , 8600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HINLR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HINLR2 as * const _ as
                usize } , 8608usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HINLR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved13 as * const _ as
                usize } , 8616usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HIER as * const _ as usize
                } , 10648usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HIER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved14 as * const _ as
                usize } , 10656usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HIPVR1 as * const _ as
                usize } , 11160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HIPVR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HIPVR2 as * const _ as
                usize } , 11168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HIPVR2 ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_gpio {
    pub DIR: ::std::os::raw::c_ulong,
    pub OUT_DATA: ::std::os::raw::c_ulong,
    pub SET_DATA: ::std::os::raw::c_ulong,
    pub CLR_DATA: ::std::os::raw::c_ulong,
    pub IN_DATA: ::std::os::raw::c_ulong,
    pub SET_RIS_TRIG: ::std::os::raw::c_ulong,
    pub CLR_RIS_TRIG: ::std::os::raw::c_ulong,
    pub SET_FAL_TRIG: ::std::os::raw::c_ulong,
    pub CLR_FAL_TRIG: ::std::os::raw::c_ulong,
    pub INTSTAT: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_gpio() {
    assert_eq!(::std::mem::size_of::<st_gpio>() , 80usize , concat ! (
               "Size of: " , stringify ! ( st_gpio ) ));
    assert_eq! (::std::mem::align_of::<st_gpio>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_gpio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . DIR as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( DIR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . OUT_DATA as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( OUT_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . SET_DATA as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( SET_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . CLR_DATA as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( CLR_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . IN_DATA as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( IN_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . SET_RIS_TRIG as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( SET_RIS_TRIG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . CLR_RIS_TRIG as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( CLR_RIS_TRIG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . SET_FAL_TRIG as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( SET_FAL_TRIG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . CLR_FAL_TRIG as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( CLR_FAL_TRIG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . INTSTAT as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( INTSTAT ) ));
}
impl Clone for st_gpio {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_hpi {
    pub REVID: ::std::os::raw::c_ulong,
    pub PWREMU_MGMT: ::std::os::raw::c_ulong,
    pub Reserved1: ::std::os::raw::c_ulong,
    pub GPIO_EN: ::std::os::raw::c_ulong,
    pub GPIO_DIR1: ::std::os::raw::c_ulong,
    pub GPIO_DAT1: ::std::os::raw::c_ulong,
    pub GPIO_DIR2: ::std::os::raw::c_ulong,
    pub GPIO_DAT2: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 4usize],
    pub HPIC: ::std::os::raw::c_ulong,
    pub HPIAW: ::std::os::raw::c_ulong,
    pub HPIAR: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_hpi() {
    assert_eq!(::std::mem::size_of::<st_hpi>() , 120usize , concat ! (
               "Size of: " , stringify ! ( st_hpi ) ));
    assert_eq! (::std::mem::align_of::<st_hpi>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_hpi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . REVID as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . PWREMU_MGMT as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( PWREMU_MGMT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . Reserved1 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . GPIO_EN as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( GPIO_EN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . GPIO_DIR1 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( GPIO_DIR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . GPIO_DAT1 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( GPIO_DAT1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . GPIO_DIR2 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( GPIO_DIR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . GPIO_DAT2 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( GPIO_DAT2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . Reserved2 as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . HPIC as * const _ as usize }
                , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( HPIC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . HPIAW as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( HPIAW ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . HPIAR as * const _ as usize
                } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( HPIAR ) ));
}
impl Clone for st_hpi {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct st_pll0 {
    pub REVID: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 56usize],
    pub RSTYPE: ::std::os::raw::c_ulong,
    pub RSCTRL: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 5usize],
    pub PLLCTL: ::std::os::raw::c_ulong,
    pub OCSEL: ::std::os::raw::c_ulong,
    pub Reserved3: [::std::os::raw::c_ulong; 2usize],
    pub PLLM: ::std::os::raw::c_ulong,
    pub PREDIV: ::std::os::raw::c_ulong,
    pub PLLDIV1: ::std::os::raw::c_ulong,
    pub PLLDIV2: ::std::os::raw::c_ulong,
    pub PLLDIV3: ::std::os::raw::c_ulong,
    pub OSCDIV: ::std::os::raw::c_ulong,
    pub POSTDIV: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 3usize],
    pub PLLCMD: ::std::os::raw::c_ulong,
    pub PLLSTAT: ::std::os::raw::c_ulong,
    pub ALNCTL: ::std::os::raw::c_ulong,
    pub DCHANGE: ::std::os::raw::c_ulong,
    pub CKEN: ::std::os::raw::c_ulong,
    pub CKSTAT: ::std::os::raw::c_ulong,
    pub SYSTAT: ::std::os::raw::c_ulong,
    pub Reserved5: [::std::os::raw::c_ulong; 3usize],
    pub PLLDIV4: ::std::os::raw::c_ulong,
    pub PLLDIV5: ::std::os::raw::c_ulong,
    pub PLLDIV6: ::std::os::raw::c_ulong,
    pub PLLDIV7: ::std::os::raw::c_ulong,
    pub Reserved6: [::std::os::raw::c_ulong; 32usize],
    pub EMUCNT0: ::std::os::raw::c_ulong,
    pub EMUCNT1: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_pll0() {
    assert_eq!(::std::mem::size_of::<st_pll0>() , 1008usize , concat ! (
               "Size of: " , stringify ! ( st_pll0 ) ));
    assert_eq! (::std::mem::align_of::<st_pll0>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_pll0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . REVID as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . Reserved1 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . RSTYPE as * const _ as
                usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( RSTYPE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . RSCTRL as * const _ as
                usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( RSCTRL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . Reserved2 as * const _ as
                usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLCTL as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLCTL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . OCSEL as * const _ as usize
                } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( OCSEL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . Reserved3 as * const _ as
                usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLM as * const _ as usize
                } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLM ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PREDIV as * const _ as
                usize } , 552usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PREDIV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLDIV1 as * const _ as
                usize } , 560usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLDIV1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLDIV2 as * const _ as
                usize } , 568usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLDIV2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLDIV3 as * const _ as
                usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLDIV3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . OSCDIV as * const _ as
                usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( OSCDIV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . POSTDIV as * const _ as
                usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( POSTDIV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . Reserved4 as * const _ as
                usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLCMD as * const _ as
                usize } , 624usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLCMD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLSTAT as * const _ as
                usize } , 632usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . ALNCTL as * const _ as
                usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( ALNCTL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . DCHANGE as * const _ as
                usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( DCHANGE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . CKEN as * const _ as usize
                } , 656usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( CKEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . CKSTAT as * const _ as
                usize } , 664usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( CKSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . SYSTAT as * const _ as
                usize } , 672usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( SYSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . Reserved5 as * const _ as
                usize } , 680usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( Reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLDIV4 as * const _ as
                usize } , 704usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLDIV4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLDIV5 as * const _ as
                usize } , 712usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLDIV5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLDIV6 as * const _ as
                usize } , 720usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLDIV6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLDIV7 as * const _ as
                usize } , 728usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLDIV7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . Reserved6 as * const _ as
                usize } , 736usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( Reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . EMUCNT0 as * const _ as
                usize } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( EMUCNT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . EMUCNT1 as * const _ as
                usize } , 1000usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( EMUCNT1 ) ));
}
#[repr(C)]
pub struct st_pll1 {
    pub REVID: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 63usize],
    pub PLLCTL: ::std::os::raw::c_ulong,
    pub OCSEL: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 2usize],
    pub PLLM: ::std::os::raw::c_ulong,
    pub Reserved3: ::std::os::raw::c_ulong,
    pub PLLDIV1: ::std::os::raw::c_ulong,
    pub PLLDIV2: ::std::os::raw::c_ulong,
    pub PLLDIV3: ::std::os::raw::c_ulong,
    pub OSCDIV: ::std::os::raw::c_ulong,
    pub POSTDIV: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 3usize],
    pub PLLCMD: ::std::os::raw::c_ulong,
    pub PLLSTAT: ::std::os::raw::c_ulong,
    pub ALNCTL: ::std::os::raw::c_ulong,
    pub DCHANGE: ::std::os::raw::c_ulong,
    pub CKEN: ::std::os::raw::c_ulong,
    pub CKSTAT: ::std::os::raw::c_ulong,
    pub SYSTAT: ::std::os::raw::c_ulong,
    pub Reserved5: [::std::os::raw::c_ulong; 39usize],
    pub EMUCNT0: ::std::os::raw::c_ulong,
    pub EMUCNT1: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_pll1() {
    assert_eq!(::std::mem::size_of::<st_pll1>() , 1008usize , concat ! (
               "Size of: " , stringify ! ( st_pll1 ) ));
    assert_eq! (::std::mem::align_of::<st_pll1>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_pll1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . REVID as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . Reserved1 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . PLLCTL as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( PLLCTL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . OCSEL as * const _ as usize
                } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( OCSEL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . Reserved2 as * const _ as
                usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . PLLM as * const _ as usize
                } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( PLLM ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . Reserved3 as * const _ as
                usize } , 552usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . PLLDIV1 as * const _ as
                usize } , 560usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( PLLDIV1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . PLLDIV2 as * const _ as
                usize } , 568usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( PLLDIV2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . PLLDIV3 as * const _ as
                usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( PLLDIV3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . OSCDIV as * const _ as
                usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( OSCDIV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . POSTDIV as * const _ as
                usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( POSTDIV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . Reserved4 as * const _ as
                usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . PLLCMD as * const _ as
                usize } , 624usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( PLLCMD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . PLLSTAT as * const _ as
                usize } , 632usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( PLLSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . ALNCTL as * const _ as
                usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( ALNCTL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . DCHANGE as * const _ as
                usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( DCHANGE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . CKEN as * const _ as usize
                } , 656usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( CKEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . CKSTAT as * const _ as
                usize } , 664usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( CKSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . SYSTAT as * const _ as
                usize } , 672usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( SYSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . Reserved5 as * const _ as
                usize } , 680usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( Reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . EMUCNT0 as * const _ as
                usize } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( EMUCNT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . EMUCNT1 as * const _ as
                usize } , 1000usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( EMUCNT1 ) ));
}
#[repr(C)]
pub struct st_syscfg0 {
    pub REVID: ::std::os::raw::c_ulong,
    pub Reserved1: ::std::os::raw::c_ulong,
    pub DIEIDR0: ::std::os::raw::c_ulong,
    pub DIEIDR1: ::std::os::raw::c_ulong,
    pub DIEIDR2: ::std::os::raw::c_ulong,
    pub DIEIDR3: ::std::os::raw::c_ulong,
    pub DEVIDR0: ::std::os::raw::c_ulong,
    pub BOOTCFG: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 5usize],
    pub KICK0R: ::std::os::raw::c_ulong,
    pub KICK1R: ::std::os::raw::c_ulong,
    pub HOST0CFG: ::std::os::raw::c_ulong,
    pub Reserved3: [::std::os::raw::c_ulong; 40usize],
    pub IRAWSTAT: ::std::os::raw::c_ulong,
    pub IENSTAT: ::std::os::raw::c_ulong,
    pub IENSET: ::std::os::raw::c_ulong,
    pub IENCLR: ::std::os::raw::c_ulong,
    pub EOI: ::std::os::raw::c_ulong,
    pub FLTADDRR: ::std::os::raw::c_ulong,
    pub FLTSTAT: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 5usize],
    pub MSTPRI0: ::std::os::raw::c_ulong,
    pub MSTPRI1: ::std::os::raw::c_ulong,
    pub MSTPRI2: ::std::os::raw::c_ulong,
    pub Reserved5: ::std::os::raw::c_ulong,
    pub PINMUX0: ::std::os::raw::c_ulong,
    pub PINMUX1: ::std::os::raw::c_ulong,
    pub PINMUX2: ::std::os::raw::c_ulong,
    pub PINMUX3: ::std::os::raw::c_ulong,
    pub PINMUX4: ::std::os::raw::c_ulong,
    pub PINMUX5: ::std::os::raw::c_ulong,
    pub PINMUX6: ::std::os::raw::c_ulong,
    pub PINMUX7: ::std::os::raw::c_ulong,
    pub PINMUX8: ::std::os::raw::c_ulong,
    pub PINMUX9: ::std::os::raw::c_ulong,
    pub PINMUX10: ::std::os::raw::c_ulong,
    pub PINMUX11: ::std::os::raw::c_ulong,
    pub PINMUX12: ::std::os::raw::c_ulong,
    pub PINMUX13: ::std::os::raw::c_ulong,
    pub PINMUX14: ::std::os::raw::c_ulong,
    pub PINMUX15: ::std::os::raw::c_ulong,
    pub PINMUX16: ::std::os::raw::c_ulong,
    pub PINMUX17: ::std::os::raw::c_ulong,
    pub PINMUX18: ::std::os::raw::c_ulong,
    pub PINMUX19: ::std::os::raw::c_ulong,
    pub SUSPSRC: ::std::os::raw::c_ulong,
    pub CHIPSIG: ::std::os::raw::c_ulong,
    pub CHIPSIG_CLR: ::std::os::raw::c_ulong,
    pub CFGCHIP0: ::std::os::raw::c_ulong,
    pub CFGCHIP1: ::std::os::raw::c_ulong,
    pub CFGCHIP2: ::std::os::raw::c_ulong,
    pub CFGCHIP3: ::std::os::raw::c_ulong,
    pub CFGCHIP4: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_syscfg0() {
    assert_eq!(::std::mem::size_of::<st_syscfg0>() , 800usize , concat ! (
               "Size of: " , stringify ! ( st_syscfg0 ) ));
    assert_eq! (::std::mem::align_of::<st_syscfg0>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_syscfg0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . REVID as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . Reserved1 as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . DIEIDR0 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( DIEIDR0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . DIEIDR1 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( DIEIDR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . DIEIDR2 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( DIEIDR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . DIEIDR3 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( DIEIDR3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . DEVIDR0 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( DEVIDR0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . BOOTCFG as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( BOOTCFG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . Reserved2 as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . KICK0R as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( KICK0R ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . KICK1R as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( KICK1R ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . HOST0CFG as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( HOST0CFG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . Reserved3 as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . IRAWSTAT as * const _ as
                usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( IRAWSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . IENSTAT as * const _ as
                usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( IENSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . IENSET as * const _ as
                usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( IENSET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . IENCLR as * const _ as
                usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( IENCLR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . EOI as * const _ as
                usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( EOI ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . FLTADDRR as * const _ as
                usize } , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( FLTADDRR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . FLTSTAT as * const _ as
                usize } , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( FLTSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . Reserved4 as * const _
                as usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . MSTPRI0 as * const _ as
                usize } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( MSTPRI0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . MSTPRI1 as * const _ as
                usize } , 552usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( MSTPRI1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . MSTPRI2 as * const _ as
                usize } , 560usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( MSTPRI2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . Reserved5 as * const _
                as usize } , 568usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( Reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX0 as * const _ as
                usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX1 as * const _ as
                usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX2 as * const _ as
                usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX3 as * const _ as
                usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX4 as * const _ as
                usize } , 608usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX5 as * const _ as
                usize } , 616usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX6 as * const _ as
                usize } , 624usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX7 as * const _ as
                usize } , 632usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX8 as * const _ as
                usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX9 as * const _ as
                usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX10 as * const _ as
                usize } , 656usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX11 as * const _ as
                usize } , 664usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX12 as * const _ as
                usize } , 672usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX13 as * const _ as
                usize } , 680usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX14 as * const _ as
                usize } , 688usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX15 as * const _ as
                usize } , 696usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX16 as * const _ as
                usize } , 704usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX17 as * const _ as
                usize } , 712usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX17 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX18 as * const _ as
                usize } , 720usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX18 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX19 as * const _ as
                usize } , 728usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX19 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . SUSPSRC as * const _ as
                usize } , 736usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( SUSPSRC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . CHIPSIG as * const _ as
                usize } , 744usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( CHIPSIG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . CHIPSIG_CLR as * const _
                as usize } , 752usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( CHIPSIG_CLR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . CFGCHIP0 as * const _ as
                usize } , 760usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( CFGCHIP0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . CFGCHIP1 as * const _ as
                usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( CFGCHIP1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . CFGCHIP2 as * const _ as
                usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( CFGCHIP2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . CFGCHIP3 as * const _ as
                usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( CFGCHIP3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . CFGCHIP4 as * const _ as
                usize } , 792usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( CFGCHIP4 ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_syscfg1 {
    pub VTPIO_CTL: ::std::os::raw::c_ulong,
    pub DDR_SLEW: ::std::os::raw::c_ulong,
    pub DEEPSLEEP: ::std::os::raw::c_ulong,
    pub PUPD_ENA: ::std::os::raw::c_ulong,
    pub PUPD_SEL: ::std::os::raw::c_ulong,
    pub RXACTIVE: ::std::os::raw::c_ulong,
    pub PWRDN: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_syscfg1() {
    assert_eq!(::std::mem::size_of::<st_syscfg1>() , 56usize , concat ! (
               "Size of: " , stringify ! ( st_syscfg1 ) ));
    assert_eq! (::std::mem::align_of::<st_syscfg1>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_syscfg1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg1 ) ) . VTPIO_CTL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg1 ) , "::" ,
                stringify ! ( VTPIO_CTL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg1 ) ) . DDR_SLEW as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg1 ) , "::" ,
                stringify ! ( DDR_SLEW ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg1 ) ) . DEEPSLEEP as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg1 ) , "::" ,
                stringify ! ( DEEPSLEEP ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg1 ) ) . PUPD_ENA as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg1 ) , "::" ,
                stringify ! ( PUPD_ENA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg1 ) ) . PUPD_SEL as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg1 ) , "::" ,
                stringify ! ( PUPD_SEL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg1 ) ) . RXACTIVE as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg1 ) , "::" ,
                stringify ! ( RXACTIVE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg1 ) ) . PWRDN as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg1 ) , "::" ,
                stringify ! ( PWRDN ) ));
}
impl Clone for st_syscfg1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct st_psc {
    pub REVID: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 5usize],
    pub INTEVAL: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 9usize],
    pub MERRPR0: ::std::os::raw::c_ulong,
    pub Reserved3: [::std::os::raw::c_ulong; 3usize],
    pub MERRCR0: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 3usize],
    pub PERRPR: ::std::os::raw::c_ulong,
    pub Reserved5: ::std::os::raw::c_ulong,
    pub PERRCR: ::std::os::raw::c_ulong,
    pub Reserved6: [::std::os::raw::c_ulong; 45usize],
    pub PTCMD: ::std::os::raw::c_ulong,
    pub Reserved7: ::std::os::raw::c_ulong,
    pub PTSTAT: ::std::os::raw::c_ulong,
    pub Reserved8: [::std::os::raw::c_ulong; 53usize],
    pub PDSTAT0: ::std::os::raw::c_ulong,
    pub PDSTAT1: ::std::os::raw::c_ulong,
    pub Reserved9: [::std::os::raw::c_ulong; 62usize],
    pub PDCTL0: ::std::os::raw::c_ulong,
    pub PDCTL1: ::std::os::raw::c_ulong,
    pub Reserved10: [::std::os::raw::c_ulong; 62usize],
    pub PDCFG0: ::std::os::raw::c_ulong,
    pub PDCFG1: ::std::os::raw::c_ulong,
    pub Reserved11: [::std::os::raw::c_ulong; 254usize],
    pub MDSTAT: [::std::os::raw::c_ulong; 32usize],
    pub Reserved12: [::std::os::raw::c_ulong; 157usize],
    pub MDCTL: [::std::os::raw::c_ulong; 32usize],
}
#[test]
fn bindgen_test_layout_st_psc() {
    assert_eq!(::std::mem::size_of::<st_psc>() , 5864usize , concat ! (
               "Size of: " , stringify ! ( st_psc ) ));
    assert_eq! (::std::mem::align_of::<st_psc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_psc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . REVID as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved1 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . INTEVAL as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( INTEVAL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved2 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . MERRPR0 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( MERRPR0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved3 as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . MERRCR0 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( MERRCR0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved4 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PERRPR as * const _ as usize
                } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PERRPR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved5 as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PERRCR as * const _ as usize
                } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PERRCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved6 as * const _ as
                usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PTCMD as * const _ as usize
                } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PTCMD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved7 as * const _ as
                usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PTSTAT as * const _ as usize
                } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PTSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved8 as * const _ as
                usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PDSTAT0 as * const _ as
                usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PDSTAT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PDSTAT1 as * const _ as
                usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PDSTAT1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved9 as * const _ as
                usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PDCTL0 as * const _ as usize
                } , 1536usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PDCTL0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PDCTL1 as * const _ as usize
                } , 1544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PDCTL1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved10 as * const _ as
                usize } , 1552usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PDCFG0 as * const _ as usize
                } , 2048usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PDCFG0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PDCFG1 as * const _ as usize
                } , 2056usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PDCFG1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved11 as * const _ as
                usize } , 2064usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . MDSTAT as * const _ as usize
                } , 4096usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( MDSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved12 as * const _ as
                usize } , 4352usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . MDCTL as * const _ as usize
                } , 5608usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( MDCTL ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_emif {
    pub MIDR: ::std::os::raw::c_ulong,
    pub AWCC: ::std::os::raw::c_ulong,
    pub SDCR: ::std::os::raw::c_ulong,
    pub SDRCR: ::std::os::raw::c_ulong,
    pub CE2CFG: ::std::os::raw::c_ulong,
    pub CE3CFG: ::std::os::raw::c_ulong,
    pub CE4CFG: ::std::os::raw::c_ulong,
    pub CE5CFG: ::std::os::raw::c_ulong,
    pub SDTIMR: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 6usize],
    pub SDSRETR: ::std::os::raw::c_ulong,
    pub INTRAW: ::std::os::raw::c_ulong,
    pub INTMSK: ::std::os::raw::c_ulong,
    pub INTMSKSET: ::std::os::raw::c_ulong,
    pub INTMSKCLR: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 4usize],
    pub NANDFCR: ::std::os::raw::c_ulong,
    pub NANDFSR: ::std::os::raw::c_ulong,
    pub PMCR: ::std::os::raw::c_ulong,
    pub Reserved3: ::std::os::raw::c_ulong,
    pub NANDF1ECC: ::std::os::raw::c_ulong,
    pub NANDF2ECC: ::std::os::raw::c_ulong,
    pub NANDF3ECC: ::std::os::raw::c_ulong,
    pub NANDF4ECC: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 15usize],
    pub NAND4BITECCLOAD: ::std::os::raw::c_ulong,
    pub NAND4BITECC1: ::std::os::raw::c_ulong,
    pub NAND4BITECC2: ::std::os::raw::c_ulong,
    pub NAND4BITECC3: ::std::os::raw::c_ulong,
    pub NAND4BITECC4: ::std::os::raw::c_ulong,
    pub NANDERRADD1: ::std::os::raw::c_ulong,
    pub NANDERRADD2: ::std::os::raw::c_ulong,
    pub NANDERRVAL1: ::std::os::raw::c_ulong,
    pub NANDERRVAL2: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_emif() {
    assert_eq!(::std::mem::size_of::<st_emif>() , 448usize , concat ! (
               "Size of: " , stringify ! ( st_emif ) ));
    assert_eq! (::std::mem::align_of::<st_emif>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_emif ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . MIDR as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( MIDR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . AWCC as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( AWCC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . SDCR as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( SDCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . SDRCR as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( SDRCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . CE2CFG as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( CE2CFG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . CE3CFG as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( CE3CFG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . CE4CFG as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( CE4CFG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . CE5CFG as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( CE5CFG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . SDTIMR as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( SDTIMR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . Reserved1 as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . SDSRETR as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( SDSRETR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . INTRAW as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( INTRAW ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . INTMSK as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( INTMSK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . INTMSKSET as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( INTMSKSET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . INTMSKCLR as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( INTMSKCLR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . Reserved2 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDFCR as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDFCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDFSR as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDFSR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . PMCR as * const _ as usize
                } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( PMCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . Reserved3 as * const _ as
                usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDF1ECC as * const _ as
                usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDF1ECC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDF2ECC as * const _ as
                usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDF2ECC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDF3ECC as * const _ as
                usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDF3ECC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDF4ECC as * const _ as
                usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDF4ECC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . Reserved4 as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NAND4BITECCLOAD as * const
                _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NAND4BITECCLOAD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NAND4BITECC1 as * const _
                as usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NAND4BITECC1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NAND4BITECC2 as * const _
                as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NAND4BITECC2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NAND4BITECC3 as * const _
                as usize } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NAND4BITECC3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NAND4BITECC4 as * const _
                as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NAND4BITECC4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDERRADD1 as * const _ as
                usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDERRADD1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDERRADD2 as * const _ as
                usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDERRADD2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDERRVAL1 as * const _ as
                usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDERRVAL1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDERRVAL2 as * const _ as
                usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDERRVAL2 ) ));
}
impl Clone for st_emif {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_ddr {
    pub REVID: ::std::os::raw::c_ulong,
    pub SDRSTAT: ::std::os::raw::c_ulong,
    pub SDCR: ::std::os::raw::c_ulong,
    pub SDRCR: ::std::os::raw::c_ulong,
    pub SDTIMR1: ::std::os::raw::c_ulong,
    pub SDTIMR2: ::std::os::raw::c_ulong,
    pub Reserved1: ::std::os::raw::c_ulong,
    pub SDCR2: ::std::os::raw::c_ulong,
    pub PBBPR: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 7usize],
    pub PC1: ::std::os::raw::c_ulong,
    pub PC2: ::std::os::raw::c_ulong,
    pub PCC: ::std::os::raw::c_ulong,
    pub PCMRS: ::std::os::raw::c_ulong,
    pub PCT: ::std::os::raw::c_ulong,
    pub Reserved3: [::std::os::raw::c_ulong; 3usize],
    pub DRPYRCR: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 23usize],
    pub IRR: ::std::os::raw::c_ulong,
    pub IMR: ::std::os::raw::c_ulong,
    pub IMSR: ::std::os::raw::c_ulong,
    pub IMCR: ::std::os::raw::c_ulong,
    pub Reserved5: [::std::os::raw::c_ulong; 5usize],
    pub DRPYC1R: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_ddr() {
    assert_eq!(::std::mem::size_of::<st_ddr>() , 464usize , concat ! (
               "Size of: " , stringify ! ( st_ddr ) ));
    assert_eq! (::std::mem::align_of::<st_ddr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_ddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . REVID as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . SDRSTAT as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( SDRSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . SDCR as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( SDCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . SDRCR as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( SDRCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . SDTIMR1 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( SDTIMR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . SDTIMR2 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( SDTIMR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . Reserved1 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . SDCR2 as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( SDCR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . PBBPR as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( PBBPR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . Reserved2 as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . PC1 as * const _ as usize }
                , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( PC1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . PC2 as * const _ as usize }
                , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( PC2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . PCC as * const _ as usize }
                , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( PCC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . PCMRS as * const _ as usize
                } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( PCMRS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . PCT as * const _ as usize }
                , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( PCT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . Reserved3 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . DRPYRCR as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( DRPYRCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . Reserved4 as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . IRR as * const _ as usize }
                , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( IRR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . IMR as * const _ as usize }
                , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( IMR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . IMSR as * const _ as usize }
                , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( IMSR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . IMCR as * const _ as usize }
                , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( IMCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . Reserved5 as * const _ as
                usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( Reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . DRPYC1R as * const _ as
                usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( DRPYC1R ) ));
}
impl Clone for st_ddr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_uart {
    pub RBR_THR: ::std::os::raw::c_ulong,
    pub IER: ::std::os::raw::c_ulong,
    pub IIR_FCR: ::std::os::raw::c_ulong,
    pub LCR: ::std::os::raw::c_ulong,
    pub MCR: ::std::os::raw::c_ulong,
    pub LSR: ::std::os::raw::c_ulong,
    pub MSR: ::std::os::raw::c_ulong,
    pub SCR: ::std::os::raw::c_ulong,
    pub DLL: ::std::os::raw::c_ulong,
    pub DLH: ::std::os::raw::c_ulong,
    pub REVID1: ::std::os::raw::c_ulong,
    pub REVID2: ::std::os::raw::c_ulong,
    pub PWREMU_MGMT: ::std::os::raw::c_ulong,
    pub MDR: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_uart() {
    assert_eq!(::std::mem::size_of::<st_uart>() , 112usize , concat ! (
               "Size of: " , stringify ! ( st_uart ) ));
    assert_eq! (::std::mem::align_of::<st_uart>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_uart ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . RBR_THR as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( RBR_THR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . IER as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( IER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . IIR_FCR as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( IIR_FCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . LCR as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( LCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . MCR as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( MCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . LSR as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( LSR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . MSR as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( MSR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . SCR as * const _ as usize }
                , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( SCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . DLL as * const _ as usize }
                , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( DLL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . DLH as * const _ as usize }
                , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( DLH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . REVID1 as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( REVID1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . REVID2 as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( REVID2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . PWREMU_MGMT as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( PWREMU_MGMT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . MDR as * const _ as usize }
                , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( MDR ) ));
}
impl Clone for st_uart {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_spi {
    pub SPIGCR0: ::std::os::raw::c_ulong,
    pub SPIGCR1: ::std::os::raw::c_ulong,
    pub SPIINT0: ::std::os::raw::c_ulong,
    pub SPILVL: ::std::os::raw::c_ulong,
    pub SPIFLG: ::std::os::raw::c_ulong,
    pub SPIPC0: ::std::os::raw::c_ulong,
    pub SPIPC1: ::std::os::raw::c_ulong,
    pub SPIPC2: ::std::os::raw::c_ulong,
    pub SPIPC3: ::std::os::raw::c_ulong,
    pub SPIPC4: ::std::os::raw::c_ulong,
    pub SPIPC5: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 3usize],
    pub SPIDAT0: ::std::os::raw::c_ulong,
    pub SPIDAT1: ::std::os::raw::c_ulong,
    pub SPIBUF: ::std::os::raw::c_ulong,
    pub SPIEMU: ::std::os::raw::c_ulong,
    pub SPIDELAY: ::std::os::raw::c_ulong,
    pub SPIDEF: ::std::os::raw::c_ulong,
    pub SPIFMT0: ::std::os::raw::c_ulong,
    pub SPIFMT1: ::std::os::raw::c_ulong,
    pub SPIFMT2: ::std::os::raw::c_ulong,
    pub SPIFMT3: ::std::os::raw::c_ulong,
    pub Reserved2: ::std::os::raw::c_ulong,
    pub INTVEC1: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_spi() {
    assert_eq!(::std::mem::size_of::<st_spi>() , 208usize , concat ! (
               "Size of: " , stringify ! ( st_spi ) ));
    assert_eq! (::std::mem::align_of::<st_spi>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_spi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIGCR0 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIGCR0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIGCR1 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIGCR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIINT0 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIINT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPILVL as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPILVL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIFLG as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIFLG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIPC0 as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIPC0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIPC1 as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIPC1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIPC2 as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIPC2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIPC3 as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIPC3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIPC4 as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIPC4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIPC5 as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIPC5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . Reserved1 as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIDAT0 as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIDAT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIDAT1 as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIDAT1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIBUF as * const _ as usize
                } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIBUF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIEMU as * const _ as usize
                } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIEMU ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIDELAY as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIDELAY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIDEF as * const _ as usize
                } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIDEF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIFMT0 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIFMT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIFMT1 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIFMT1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIFMT2 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIFMT2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIFMT3 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIFMT3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . Reserved2 as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . INTVEC1 as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( INTVEC1 ) ));
}
impl Clone for st_spi {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct st_edma_cc {
    pub REVID: ::std::os::raw::c_ulong,
    pub CCCFG: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 126usize],
    pub QCHMAP0: ::std::os::raw::c_ulong,
    pub QCHMAP1: ::std::os::raw::c_ulong,
    pub QCHMAP2: ::std::os::raw::c_ulong,
    pub QCHMAP3: ::std::os::raw::c_ulong,
    pub QCHMAP4: ::std::os::raw::c_ulong,
    pub QCHMAP5: ::std::os::raw::c_ulong,
    pub QCHMAP6: ::std::os::raw::c_ulong,
    pub QCHMAP7: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 8usize],
    pub DMAQNUM0: ::std::os::raw::c_ulong,
    pub DMAQNUM1: ::std::os::raw::c_ulong,
    pub DMAQNUM2: ::std::os::raw::c_ulong,
    pub DMAQNUM3: ::std::os::raw::c_ulong,
    pub Reserved3: [::std::os::raw::c_ulong; 4usize],
    pub QDMAQNUM: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 8usize],
    pub QUEPRI: ::std::os::raw::c_ulong,
    pub Reserved5: [::std::os::raw::c_ulong; 30usize],
    pub EMR: ::std::os::raw::c_ulong,
    pub Reserved6: ::std::os::raw::c_ulong,
    pub EMCR: ::std::os::raw::c_ulong,
    pub Reserved7: ::std::os::raw::c_ulong,
    pub QEMR: ::std::os::raw::c_ulong,
    pub QEMCR: ::std::os::raw::c_ulong,
    pub CCERR: ::std::os::raw::c_ulong,
    pub CCERRCLR: ::std::os::raw::c_ulong,
    pub EEVAL: ::std::os::raw::c_ulong,
    pub Reserved8: [::std::os::raw::c_ulong; 7usize],
    pub DRAE0: ::std::os::raw::c_ulong,
    pub Reserved9: ::std::os::raw::c_ulong,
    pub DRAE1: ::std::os::raw::c_ulong,
    pub Reserved10: ::std::os::raw::c_ulong,
    pub DRAE2: ::std::os::raw::c_ulong,
    pub Reserved11: ::std::os::raw::c_ulong,
    pub DRAE3: ::std::os::raw::c_ulong,
    pub Reserved12: [::std::os::raw::c_ulong; 9usize],
    pub QRAE0: ::std::os::raw::c_ulong,
    pub QRAE1: ::std::os::raw::c_ulong,
    pub QRAE2: ::std::os::raw::c_ulong,
    pub QRAE3: ::std::os::raw::c_ulong,
    pub Reserved13: [::std::os::raw::c_ulong; 28usize],
    pub Q0E: [::std::os::raw::c_ulong; 16usize],
    pub Q1E: [::std::os::raw::c_ulong; 16usize],
    pub Reserved14: [::std::os::raw::c_ulong; 96usize],
    pub QSTAT0: ::std::os::raw::c_ulong,
    pub QSTAT1: ::std::os::raw::c_ulong,
    pub Reserved15: [::std::os::raw::c_ulong; 6usize],
    pub QWMTHRA: ::std::os::raw::c_ulong,
    pub Reserved16: [::std::os::raw::c_ulong; 7usize],
    pub CCSTAT: ::std::os::raw::c_ulong,
    pub Reserved17: [::std::os::raw::c_ulong; 623usize],
    pub ER: ::std::os::raw::c_ulong,
    pub Reserved18: ::std::os::raw::c_ulong,
    pub ECR: ::std::os::raw::c_ulong,
    pub Reserved19: ::std::os::raw::c_ulong,
    pub ESR: ::std::os::raw::c_ulong,
    pub Reserved20: ::std::os::raw::c_ulong,
    pub CER: ::std::os::raw::c_ulong,
    pub Reserved21: ::std::os::raw::c_ulong,
    pub EER: ::std::os::raw::c_ulong,
    pub Reserved22: ::std::os::raw::c_ulong,
    pub EECR: ::std::os::raw::c_ulong,
    pub Reserved23: ::std::os::raw::c_ulong,
    pub EESR: ::std::os::raw::c_ulong,
    pub Reserved24: ::std::os::raw::c_ulong,
    pub SER: ::std::os::raw::c_ulong,
    pub Reserved25: ::std::os::raw::c_ulong,
    pub SECR: ::std::os::raw::c_ulong,
    pub Reserved26: [::std::os::raw::c_ulong; 3usize],
    pub IER: ::std::os::raw::c_ulong,
    pub Reserved27: ::std::os::raw::c_ulong,
    pub IECR: ::std::os::raw::c_ulong,
    pub Reserved28: ::std::os::raw::c_ulong,
    pub IESR: ::std::os::raw::c_ulong,
    pub Reserved29: ::std::os::raw::c_ulong,
    pub IPR: ::std::os::raw::c_ulong,
    pub Reserved30: ::std::os::raw::c_ulong,
    pub ICR: ::std::os::raw::c_ulong,
    pub Reserved31: ::std::os::raw::c_ulong,
    pub IEVAL: ::std::os::raw::c_ulong,
    pub Reserved32: ::std::os::raw::c_ulong,
    pub QER: ::std::os::raw::c_ulong,
    pub QEER: ::std::os::raw::c_ulong,
    pub QEECR: ::std::os::raw::c_ulong,
    pub QEESR: ::std::os::raw::c_ulong,
    pub QSER: ::std::os::raw::c_ulong,
    pub QSECR: ::std::os::raw::c_ulong,
    pub Reserved33: [::std::os::raw::c_ulong; 986usize],
    pub ER_S0: ::std::os::raw::c_ulong,
    pub Reserved34: ::std::os::raw::c_ulong,
    pub ECR_S0: ::std::os::raw::c_ulong,
    pub Reserved35: ::std::os::raw::c_ulong,
    pub ESR_S0: ::std::os::raw::c_ulong,
    pub Reserved36: ::std::os::raw::c_ulong,
    pub CER_S0: ::std::os::raw::c_ulong,
    pub Reserved37: ::std::os::raw::c_ulong,
    pub EER_S0: ::std::os::raw::c_ulong,
    pub Reserved38: ::std::os::raw::c_ulong,
    pub EECR_S0: ::std::os::raw::c_ulong,
    pub Reserved39: ::std::os::raw::c_ulong,
    pub EESR_S0: ::std::os::raw::c_ulong,
    pub Reserved40: ::std::os::raw::c_ulong,
    pub SER_S0: ::std::os::raw::c_ulong,
    pub Reserved41: ::std::os::raw::c_ulong,
    pub SECR_S0: ::std::os::raw::c_ulong,
    pub Reserved42: [::std::os::raw::c_ulong; 3usize],
    pub IER_S0: ::std::os::raw::c_ulong,
    pub Reserved43: ::std::os::raw::c_ulong,
    pub IECR_S0: ::std::os::raw::c_ulong,
    pub Reserved44: ::std::os::raw::c_ulong,
    pub IESR_S0: ::std::os::raw::c_ulong,
    pub Reserved45: ::std::os::raw::c_ulong,
    pub IPR_S0: ::std::os::raw::c_ulong,
    pub Reserved46: ::std::os::raw::c_ulong,
    pub ICR_S0: ::std::os::raw::c_ulong,
    pub Reserved47: ::std::os::raw::c_ulong,
    pub IEVAL_S0: ::std::os::raw::c_ulong,
    pub Reserved48: ::std::os::raw::c_ulong,
    pub QER_S0: ::std::os::raw::c_ulong,
    pub QEER_S0: ::std::os::raw::c_ulong,
    pub QEECR_S0: ::std::os::raw::c_ulong,
    pub QEESR_S0: ::std::os::raw::c_ulong,
    pub QSER_S0: ::std::os::raw::c_ulong,
    pub QSECR_S0: ::std::os::raw::c_ulong,
    pub Reserved49: [::std::os::raw::c_ulong; 90usize],
    pub ER_S1: ::std::os::raw::c_ulong,
    pub Reserved50: ::std::os::raw::c_ulong,
    pub ECR_S1: ::std::os::raw::c_ulong,
    pub Reserved51: ::std::os::raw::c_ulong,
    pub ESR_S1: ::std::os::raw::c_ulong,
    pub Reserved52: ::std::os::raw::c_ulong,
    pub CER_S1: ::std::os::raw::c_ulong,
    pub Reserved53: ::std::os::raw::c_ulong,
    pub EER_S1: ::std::os::raw::c_ulong,
    pub Reserved54: ::std::os::raw::c_ulong,
    pub EECR_S1: ::std::os::raw::c_ulong,
    pub Reserved55: ::std::os::raw::c_ulong,
    pub EESR_S1: ::std::os::raw::c_ulong,
    pub Reserved56: ::std::os::raw::c_ulong,
    pub SER_S1: ::std::os::raw::c_ulong,
    pub Reserved57: ::std::os::raw::c_ulong,
    pub SECR_S1: ::std::os::raw::c_ulong,
    pub Reserved58: [::std::os::raw::c_ulong; 3usize],
    pub IER_S1: ::std::os::raw::c_ulong,
    pub Reserved59: ::std::os::raw::c_ulong,
    pub IECR_S1: ::std::os::raw::c_ulong,
    pub Reserved60: ::std::os::raw::c_ulong,
    pub IESR_S1: ::std::os::raw::c_ulong,
    pub Reserved61: ::std::os::raw::c_ulong,
    pub IPR_S1: ::std::os::raw::c_ulong,
    pub Reserved62: ::std::os::raw::c_ulong,
    pub ICR_S1: ::std::os::raw::c_ulong,
    pub Reserved63: ::std::os::raw::c_ulong,
    pub IEVAL_S1: ::std::os::raw::c_ulong,
    pub Reserved64: ::std::os::raw::c_ulong,
    pub QER_S1: ::std::os::raw::c_ulong,
    pub QEER_S1: ::std::os::raw::c_ulong,
    pub QEECR_S1: ::std::os::raw::c_ulong,
    pub QEESR_S1: ::std::os::raw::c_ulong,
    pub QSER_S1: ::std::os::raw::c_ulong,
    pub QSECR_S1: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_edma_cc() {
    assert_eq!(::std::mem::size_of::<st_edma_cc>() , 17712usize , concat ! (
               "Size of: " , stringify ! ( st_edma_cc ) ));
    assert_eq! (::std::mem::align_of::<st_edma_cc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_edma_cc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . REVID as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . CCCFG as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( CCCFG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved1 as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QCHMAP0 as * const _ as
                usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QCHMAP0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QCHMAP1 as * const _ as
                usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QCHMAP1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QCHMAP2 as * const _ as
                usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QCHMAP2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QCHMAP3 as * const _ as
                usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QCHMAP3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QCHMAP4 as * const _ as
                usize } , 1056usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QCHMAP4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QCHMAP5 as * const _ as
                usize } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QCHMAP5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QCHMAP6 as * const _ as
                usize } , 1072usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QCHMAP6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QCHMAP7 as * const _ as
                usize } , 1080usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QCHMAP7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved2 as * const _
                as usize } , 1088usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . DMAQNUM0 as * const _ as
                usize } , 1152usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( DMAQNUM0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . DMAQNUM1 as * const _ as
                usize } , 1160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( DMAQNUM1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . DMAQNUM2 as * const _ as
                usize } , 1168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( DMAQNUM2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . DMAQNUM3 as * const _ as
                usize } , 1176usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( DMAQNUM3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved3 as * const _
                as usize } , 1184usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QDMAQNUM as * const _ as
                usize } , 1216usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QDMAQNUM ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved4 as * const _
                as usize } , 1224usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QUEPRI as * const _ as
                usize } , 1288usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QUEPRI ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved5 as * const _
                as usize } , 1296usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EMR as * const _ as
                usize } , 1536usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EMR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved6 as * const _
                as usize } , 1544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EMCR as * const _ as
                usize } , 1552usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EMCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved7 as * const _
                as usize } , 1560usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEMR as * const _ as
                usize } , 1568usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEMR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEMCR as * const _ as
                usize } , 1576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEMCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . CCERR as * const _ as
                usize } , 1584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( CCERR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . CCERRCLR as * const _ as
                usize } , 1592usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( CCERRCLR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EEVAL as * const _ as
                usize } , 1600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EEVAL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved8 as * const _
                as usize } , 1608usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . DRAE0 as * const _ as
                usize } , 1664usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( DRAE0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved9 as * const _
                as usize } , 1672usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . DRAE1 as * const _ as
                usize } , 1680usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( DRAE1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved10 as * const _
                as usize } , 1688usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . DRAE2 as * const _ as
                usize } , 1696usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( DRAE2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved11 as * const _
                as usize } , 1704usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . DRAE3 as * const _ as
                usize } , 1712usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( DRAE3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved12 as * const _
                as usize } , 1720usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QRAE0 as * const _ as
                usize } , 1792usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QRAE0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QRAE1 as * const _ as
                usize } , 1800usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QRAE1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QRAE2 as * const _ as
                usize } , 1808usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QRAE2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QRAE3 as * const _ as
                usize } , 1816usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QRAE3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved13 as * const _
                as usize } , 1824usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Q0E as * const _ as
                usize } , 2048usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Q0E ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Q1E as * const _ as
                usize } , 2176usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Q1E ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved14 as * const _
                as usize } , 2304usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QSTAT0 as * const _ as
                usize } , 3072usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QSTAT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QSTAT1 as * const _ as
                usize } , 3080usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QSTAT1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved15 as * const _
                as usize } , 3088usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QWMTHRA as * const _ as
                usize } , 3136usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QWMTHRA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved16 as * const _
                as usize } , 3144usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . CCSTAT as * const _ as
                usize } , 3200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( CCSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved17 as * const _
                as usize } , 3208usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved17 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ER as * const _ as usize
                } , 8192usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved18 as * const _
                as usize } , 8200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved18 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ECR as * const _ as
                usize } , 8208usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ECR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved19 as * const _
                as usize } , 8216usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved19 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ESR as * const _ as
                usize } , 8224usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ESR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved20 as * const _
                as usize } , 8232usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved20 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . CER as * const _ as
                usize } , 8240usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( CER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved21 as * const _
                as usize } , 8248usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved21 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EER as * const _ as
                usize } , 8256usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved22 as * const _
                as usize } , 8264usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved22 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EECR as * const _ as
                usize } , 8272usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EECR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved23 as * const _
                as usize } , 8280usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved23 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EESR as * const _ as
                usize } , 8288usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EESR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved24 as * const _
                as usize } , 8296usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved24 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . SER as * const _ as
                usize } , 8304usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( SER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved25 as * const _
                as usize } , 8312usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved25 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . SECR as * const _ as
                usize } , 8320usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( SECR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved26 as * const _
                as usize } , 8328usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved26 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IER as * const _ as
                usize } , 8352usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved27 as * const _
                as usize } , 8360usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved27 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IECR as * const _ as
                usize } , 8368usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IECR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved28 as * const _
                as usize } , 8376usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved28 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IESR as * const _ as
                usize } , 8384usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IESR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved29 as * const _
                as usize } , 8392usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved29 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IPR as * const _ as
                usize } , 8400usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IPR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved30 as * const _
                as usize } , 8408usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved30 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ICR as * const _ as
                usize } , 8416usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ICR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved31 as * const _
                as usize } , 8424usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved31 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IEVAL as * const _ as
                usize } , 8432usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IEVAL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved32 as * const _
                as usize } , 8440usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QER as * const _ as
                usize } , 8448usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEER as * const _ as
                usize } , 8456usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEECR as * const _ as
                usize } , 8464usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEECR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEESR as * const _ as
                usize } , 8472usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEESR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QSER as * const _ as
                usize } , 8480usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QSER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QSECR as * const _ as
                usize } , 8488usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QSECR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved33 as * const _
                as usize } , 8496usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved33 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ER_S0 as * const _ as
                usize } , 16384usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ER_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved34 as * const _
                as usize } , 16392usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved34 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ECR_S0 as * const _ as
                usize } , 16400usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ECR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved35 as * const _
                as usize } , 16408usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved35 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ESR_S0 as * const _ as
                usize } , 16416usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ESR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved36 as * const _
                as usize } , 16424usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved36 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . CER_S0 as * const _ as
                usize } , 16432usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( CER_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved37 as * const _
                as usize } , 16440usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved37 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EER_S0 as * const _ as
                usize } , 16448usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EER_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved38 as * const _
                as usize } , 16456usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved38 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EECR_S0 as * const _ as
                usize } , 16464usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EECR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved39 as * const _
                as usize } , 16472usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved39 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EESR_S0 as * const _ as
                usize } , 16480usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EESR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved40 as * const _
                as usize } , 16488usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved40 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . SER_S0 as * const _ as
                usize } , 16496usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( SER_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved41 as * const _
                as usize } , 16504usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved41 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . SECR_S0 as * const _ as
                usize } , 16512usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( SECR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved42 as * const _
                as usize } , 16520usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved42 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IER_S0 as * const _ as
                usize } , 16544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IER_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved43 as * const _
                as usize } , 16552usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved43 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IECR_S0 as * const _ as
                usize } , 16560usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IECR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved44 as * const _
                as usize } , 16568usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved44 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IESR_S0 as * const _ as
                usize } , 16576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IESR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved45 as * const _
                as usize } , 16584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved45 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IPR_S0 as * const _ as
                usize } , 16592usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IPR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved46 as * const _
                as usize } , 16600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved46 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ICR_S0 as * const _ as
                usize } , 16608usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ICR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved47 as * const _
                as usize } , 16616usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved47 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IEVAL_S0 as * const _ as
                usize } , 16624usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IEVAL_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved48 as * const _
                as usize } , 16632usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved48 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QER_S0 as * const _ as
                usize } , 16640usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QER_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEER_S0 as * const _ as
                usize } , 16648usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEER_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEECR_S0 as * const _ as
                usize } , 16656usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEECR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEESR_S0 as * const _ as
                usize } , 16664usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEESR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QSER_S0 as * const _ as
                usize } , 16672usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QSER_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QSECR_S0 as * const _ as
                usize } , 16680usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QSECR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved49 as * const _
                as usize } , 16688usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved49 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ER_S1 as * const _ as
                usize } , 17408usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ER_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved50 as * const _
                as usize } , 17416usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved50 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ECR_S1 as * const _ as
                usize } , 17424usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ECR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved51 as * const _
                as usize } , 17432usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved51 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ESR_S1 as * const _ as
                usize } , 17440usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ESR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved52 as * const _
                as usize } , 17448usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved52 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . CER_S1 as * const _ as
                usize } , 17456usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( CER_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved53 as * const _
                as usize } , 17464usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved53 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EER_S1 as * const _ as
                usize } , 17472usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EER_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved54 as * const _
                as usize } , 17480usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved54 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EECR_S1 as * const _ as
                usize } , 17488usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EECR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved55 as * const _
                as usize } , 17496usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved55 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EESR_S1 as * const _ as
                usize } , 17504usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EESR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved56 as * const _
                as usize } , 17512usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved56 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . SER_S1 as * const _ as
                usize } , 17520usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( SER_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved57 as * const _
                as usize } , 17528usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved57 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . SECR_S1 as * const _ as
                usize } , 17536usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( SECR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved58 as * const _
                as usize } , 17544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved58 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IER_S1 as * const _ as
                usize } , 17568usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IER_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved59 as * const _
                as usize } , 17576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved59 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IECR_S1 as * const _ as
                usize } , 17584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IECR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved60 as * const _
                as usize } , 17592usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved60 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IESR_S1 as * const _ as
                usize } , 17600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IESR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved61 as * const _
                as usize } , 17608usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved61 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IPR_S1 as * const _ as
                usize } , 17616usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IPR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved62 as * const _
                as usize } , 17624usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved62 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ICR_S1 as * const _ as
                usize } , 17632usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ICR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved63 as * const _
                as usize } , 17640usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved63 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IEVAL_S1 as * const _ as
                usize } , 17648usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IEVAL_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved64 as * const _
                as usize } , 17656usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QER_S1 as * const _ as
                usize } , 17664usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QER_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEER_S1 as * const _ as
                usize } , 17672usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEER_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEECR_S1 as * const _ as
                usize } , 17680usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEECR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEESR_S1 as * const _ as
                usize } , 17688usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEESR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QSER_S1 as * const _ as
                usize } , 17696usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QSER_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QSECR_S1 as * const _ as
                usize } , 17704usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QSECR_S1 ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_edma_cc_param {
    pub OPT: ::std::os::raw::c_ulong,
    pub SRC: ::std::os::raw::c_ulong,
    pub A_B_CNT: ::std::os::raw::c_ulong,
    pub DST: ::std::os::raw::c_ulong,
    pub SRC_DST_BIDX: ::std::os::raw::c_ulong,
    pub LINK_BCNTRLD: ::std::os::raw::c_ulong,
    pub SRC_DST_CIDX: ::std::os::raw::c_ulong,
    pub CCNT: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_edma_cc_param() {
    assert_eq!(::std::mem::size_of::<st_edma_cc_param>() , 64usize , concat !
               ( "Size of: " , stringify ! ( st_edma_cc_param ) ));
    assert_eq! (::std::mem::align_of::<st_edma_cc_param>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( st_edma_cc_param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc_param ) ) . OPT as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc_param ) ,
                "::" , stringify ! ( OPT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc_param ) ) . SRC as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc_param ) ,
                "::" , stringify ! ( SRC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc_param ) ) . A_B_CNT as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc_param ) ,
                "::" , stringify ! ( A_B_CNT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc_param ) ) . DST as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc_param ) ,
                "::" , stringify ! ( DST ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc_param ) ) . SRC_DST_BIDX as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc_param ) ,
                "::" , stringify ! ( SRC_DST_BIDX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc_param ) ) . LINK_BCNTRLD as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc_param ) ,
                "::" , stringify ! ( LINK_BCNTRLD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc_param ) ) . SRC_DST_CIDX as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc_param ) ,
                "::" , stringify ! ( SRC_DST_CIDX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc_param ) ) . CCNT as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc_param ) ,
                "::" , stringify ! ( CCNT ) ));
}
impl Clone for st_edma_cc_param {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct st_edma_tc {
    pub REVID: ::std::os::raw::c_ulong,
    pub TCCFG: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 62usize],
    pub TCSTAT: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 7usize],
    pub ERRSTAT: ::std::os::raw::c_ulong,
    pub ERREN: ::std::os::raw::c_ulong,
    pub ERRCLR: ::std::os::raw::c_ulong,
    pub ERRDET: ::std::os::raw::c_ulong,
    pub ERRCMD: ::std::os::raw::c_ulong,
    pub Reserved3: [::std::os::raw::c_ulong; 3usize],
    pub RDRATE: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 63usize],
    pub SAOPT: ::std::os::raw::c_ulong,
    pub SASRC: ::std::os::raw::c_ulong,
    pub SACNT: ::std::os::raw::c_ulong,
    pub SADST: ::std::os::raw::c_ulong,
    pub SABIDX: ::std::os::raw::c_ulong,
    pub SAMPPRXY: ::std::os::raw::c_ulong,
    pub SACNTRLD: ::std::os::raw::c_ulong,
    pub SASRCBREF: ::std::os::raw::c_ulong,
    pub SADSTBREF: ::std::os::raw::c_ulong,
    pub Reserved5: [::std::os::raw::c_ulong; 7usize],
    pub DFCNTRLD: ::std::os::raw::c_ulong,
    pub DFSRCBREF: ::std::os::raw::c_ulong,
    pub DFDSTBREF: ::std::os::raw::c_ulong,
    pub Reserved6: [::std::os::raw::c_ulong; 29usize],
    pub DFOPT0: ::std::os::raw::c_ulong,
    pub DFSRC0: ::std::os::raw::c_ulong,
    pub DFCNT0: ::std::os::raw::c_ulong,
    pub DFDST0: ::std::os::raw::c_ulong,
    pub DFBIDX0: ::std::os::raw::c_ulong,
    pub DFMPPRXY0: ::std::os::raw::c_ulong,
    pub Reserved7: [::std::os::raw::c_ulong; 10usize],
    pub DFOPT1: ::std::os::raw::c_ulong,
    pub DFSRC1: ::std::os::raw::c_ulong,
    pub DFCNT1: ::std::os::raw::c_ulong,
    pub DFDST1: ::std::os::raw::c_ulong,
    pub DFBIDX1: ::std::os::raw::c_ulong,
    pub DFMPPRXY1: ::std::os::raw::c_ulong,
    pub Reserved8: [::std::os::raw::c_ulong; 10usize],
    pub DFOPT2: ::std::os::raw::c_ulong,
    pub DFSRC2: ::std::os::raw::c_ulong,
    pub DFCNT2: ::std::os::raw::c_ulong,
    pub DFDST2: ::std::os::raw::c_ulong,
    pub DFBIDX2: ::std::os::raw::c_ulong,
    pub DFMPPRXY2: ::std::os::raw::c_ulong,
    pub Reserved9: [::std::os::raw::c_ulong; 10usize],
    pub DFOPT3: ::std::os::raw::c_ulong,
    pub DFSRC3: ::std::os::raw::c_ulong,
    pub DFCNT3: ::std::os::raw::c_ulong,
    pub DFDST3: ::std::os::raw::c_ulong,
    pub DFBIDX3: ::std::os::raw::c_ulong,
    pub DFMPPRXY3: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_edma_tc() {
    assert_eq!(::std::mem::size_of::<st_edma_tc>() , 1968usize , concat ! (
               "Size of: " , stringify ! ( st_edma_tc ) ));
    assert_eq! (::std::mem::align_of::<st_edma_tc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_edma_tc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . REVID as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . TCCFG as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( TCCFG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved1 as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . TCSTAT as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( TCSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved2 as * const _
                as usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . ERRSTAT as * const _ as
                usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( ERRSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . ERREN as * const _ as
                usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( ERREN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . ERRCLR as * const _ as
                usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( ERRCLR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . ERRDET as * const _ as
                usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( ERRDET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . ERRCMD as * const _ as
                usize } , 608usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( ERRCMD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved3 as * const _
                as usize } , 616usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . RDRATE as * const _ as
                usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( RDRATE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved4 as * const _
                as usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SAOPT as * const _ as
                usize } , 1152usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SAOPT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SASRC as * const _ as
                usize } , 1160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SASRC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SACNT as * const _ as
                usize } , 1168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SACNT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SADST as * const _ as
                usize } , 1176usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SADST ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SABIDX as * const _ as
                usize } , 1184usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SABIDX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SAMPPRXY as * const _ as
                usize } , 1192usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SAMPPRXY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SACNTRLD as * const _ as
                usize } , 1200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SACNTRLD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SASRCBREF as * const _
                as usize } , 1208usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SASRCBREF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SADSTBREF as * const _
                as usize } , 1216usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SADSTBREF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved5 as * const _
                as usize } , 1224usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFCNTRLD as * const _ as
                usize } , 1280usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFCNTRLD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFSRCBREF as * const _
                as usize } , 1288usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFSRCBREF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFDSTBREF as * const _
                as usize } , 1296usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFDSTBREF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved6 as * const _
                as usize } , 1304usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFOPT0 as * const _ as
                usize } , 1536usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFOPT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFSRC0 as * const _ as
                usize } , 1544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFSRC0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFCNT0 as * const _ as
                usize } , 1552usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFCNT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFDST0 as * const _ as
                usize } , 1560usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFDST0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFBIDX0 as * const _ as
                usize } , 1568usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFBIDX0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFMPPRXY0 as * const _
                as usize } , 1576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFMPPRXY0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved7 as * const _
                as usize } , 1584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFOPT1 as * const _ as
                usize } , 1664usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFOPT1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFSRC1 as * const _ as
                usize } , 1672usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFSRC1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFCNT1 as * const _ as
                usize } , 1680usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFCNT1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFDST1 as * const _ as
                usize } , 1688usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFDST1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFBIDX1 as * const _ as
                usize } , 1696usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFBIDX1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFMPPRXY1 as * const _
                as usize } , 1704usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFMPPRXY1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved8 as * const _
                as usize } , 1712usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFOPT2 as * const _ as
                usize } , 1792usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFOPT2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFSRC2 as * const _ as
                usize } , 1800usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFSRC2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFCNT2 as * const _ as
                usize } , 1808usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFCNT2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFDST2 as * const _ as
                usize } , 1816usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFDST2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFBIDX2 as * const _ as
                usize } , 1824usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFBIDX2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFMPPRXY2 as * const _
                as usize } , 1832usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFMPPRXY2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved9 as * const _
                as usize } , 1840usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFOPT3 as * const _ as
                usize } , 1920usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFOPT3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFSRC3 as * const _ as
                usize } , 1928usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFSRC3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFCNT3 as * const _ as
                usize } , 1936usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFCNT3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFDST3 as * const _ as
                usize } , 1944usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFDST3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFBIDX3 as * const _ as
                usize } , 1952usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFBIDX3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFMPPRXY3 as * const _
                as usize } , 1960usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFMPPRXY3 ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_timer {
    pub REVID: ::std::os::raw::c_ulong,
    pub EMUMGT: ::std::os::raw::c_ulong,
    pub GPINTGPEN: ::std::os::raw::c_ulong,
    pub GPDATGPDIR: ::std::os::raw::c_ulong,
    pub TIM12: ::std::os::raw::c_ulong,
    pub TIM34: ::std::os::raw::c_ulong,
    pub PRD12: ::std::os::raw::c_ulong,
    pub PRD34: ::std::os::raw::c_ulong,
    pub TCR: ::std::os::raw::c_ulong,
    pub TGCR: ::std::os::raw::c_ulong,
    pub WDTCR: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 2usize],
    pub REL12: ::std::os::raw::c_ulong,
    pub REL34: ::std::os::raw::c_ulong,
    pub CAP12: ::std::os::raw::c_ulong,
    pub CAP34: ::std::os::raw::c_ulong,
    pub INTCTLSTAT: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 6usize],
    pub CMP0: ::std::os::raw::c_ulong,
    pub CMP1: ::std::os::raw::c_ulong,
    pub CMP2: ::std::os::raw::c_ulong,
    pub CMP3: ::std::os::raw::c_ulong,
    pub CMP4: ::std::os::raw::c_ulong,
    pub CMP5: ::std::os::raw::c_ulong,
    pub CMP6: ::std::os::raw::c_ulong,
    pub CMP7: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_timer() {
    assert_eq!(::std::mem::size_of::<st_timer>() , 256usize , concat ! (
               "Size of: " , stringify ! ( st_timer ) ));
    assert_eq! (::std::mem::align_of::<st_timer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . REVID as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . EMUMGT as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( EMUMGT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . GPINTGPEN as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( GPINTGPEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . GPDATGPDIR as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( GPDATGPDIR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . TIM12 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( TIM12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . TIM34 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( TIM34 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . PRD12 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( PRD12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . PRD34 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( PRD34 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . TCR as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( TCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . TGCR as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( TGCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . WDTCR as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( WDTCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . Reserved1 as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . REL12 as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( REL12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . REL34 as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( REL34 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CAP12 as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CAP12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CAP34 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CAP34 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . INTCTLSTAT as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( INTCTLSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . Reserved2 as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CMP0 as * const _ as usize
                } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CMP0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CMP1 as * const _ as usize
                } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CMP1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CMP2 as * const _ as usize
                } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CMP2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CMP3 as * const _ as usize
                } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CMP3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CMP4 as * const _ as usize
                } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CMP4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CMP5 as * const _ as usize
                } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CMP5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CMP6 as * const _ as usize
                } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CMP6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CMP7 as * const _ as usize
                } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CMP7 ) ));
}
impl Clone for st_timer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mmcsd {
    pub MMCCTL: ::std::os::raw::c_ulong,
    pub MMCCLK: ::std::os::raw::c_ulong,
    pub MMCST0: ::std::os::raw::c_ulong,
    pub MMCST1: ::std::os::raw::c_ulong,
    pub MMCIM: ::std::os::raw::c_ulong,
    pub MMCTOR: ::std::os::raw::c_ulong,
    pub MMCTOD: ::std::os::raw::c_ulong,
    pub MMCBLEN: ::std::os::raw::c_ulong,
    pub MMCNBLK: ::std::os::raw::c_ulong,
    pub MMCNBLC: ::std::os::raw::c_ulong,
    pub MMCDRR: ::std::os::raw::c_ulong,
    pub MMCDXR: ::std::os::raw::c_ulong,
    pub MMCCMD: ::std::os::raw::c_ulong,
    pub MMCARGHL: ::std::os::raw::c_ulong,
    pub MMCRSP01: ::std::os::raw::c_ulong,
    pub MMCRSP23: ::std::os::raw::c_ulong,
    pub MMCRSP45: ::std::os::raw::c_ulong,
    pub MMCRSP67: ::std::os::raw::c_ulong,
    pub MMCDRSP: ::std::os::raw::c_ulong,
    pub Reserved1: ::std::os::raw::c_ulong,
    pub MMCCIDX: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 4usize],
    pub SDIOCTL: ::std::os::raw::c_ulong,
    pub SDIOST0: ::std::os::raw::c_ulong,
    pub SDIOIEN: ::std::os::raw::c_ulong,
    pub SDIOIST: ::std::os::raw::c_ulong,
    pub MMCFIFOCTL: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_mmcsd() {
    assert_eq!(::std::mem::size_of::<st_mmcsd>() , 240usize , concat ! (
               "Size of: " , stringify ! ( st_mmcsd ) ));
    assert_eq! (::std::mem::align_of::<st_mmcsd>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_mmcsd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCCTL as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCCTL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCCLK as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCCLK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCST0 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCST0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCST1 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCST1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCIM as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCIM ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCTOR as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCTOR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCTOD as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCTOD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCBLEN as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCBLEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCNBLK as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCNBLK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCNBLC as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCNBLC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCDRR as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCDRR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCDXR as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCDXR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCCMD as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCCMD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCARGHL as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCARGHL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCRSP01 as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCRSP01 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCRSP23 as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCRSP23 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCRSP45 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCRSP45 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCRSP67 as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCRSP67 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCDRSP as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCDRSP ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . Reserved1 as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCCIDX as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCCIDX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . Reserved2 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . SDIOCTL as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( SDIOCTL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . SDIOST0 as * const _ as
                usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( SDIOST0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . SDIOIEN as * const _ as
                usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( SDIOIEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . SDIOIST as * const _ as
                usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( SDIOIST ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCFIFOCTL as * const _ as
                usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCFIFOCTL ) ));
}
impl Clone for st_mmcsd {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_ecap {
    pub TSCTR: u32,
    pub CTRPHS: u32,
    pub CAP1: u32,
    pub CAP2: u32,
    pub CAP3: u32,
    pub CAP4: u32,
    pub Rev0: [u8; 16usize],
    pub ECCTL1: u16,
    pub ECCTL2: u16,
    pub ECEINT: u16,
    pub ECFLG: u16,
    pub ECCLR: u16,
    pub ECFRC: u16,
}
#[test]
fn bindgen_test_layout_st_ecap() {
    assert_eq!(::std::mem::size_of::<st_ecap>() , 52usize , concat ! (
               "Size of: " , stringify ! ( st_ecap ) ));
    assert_eq! (::std::mem::align_of::<st_ecap>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( st_ecap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . TSCTR as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( TSCTR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . CTRPHS as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( CTRPHS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . CAP1 as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( CAP1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . CAP2 as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( CAP2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . CAP3 as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( CAP3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . CAP4 as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( CAP4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . Rev0 as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( Rev0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . ECCTL1 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( ECCTL1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . ECCTL2 as * const _ as
                usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( ECCTL2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . ECEINT as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( ECEINT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . ECFLG as * const _ as usize
                } , 46usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( ECFLG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . ECCLR as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( ECCLR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . ECFRC as * const _ as usize
                } , 50usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( ECFRC ) ));
}
impl Clone for st_ecap {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn mmu_init();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct exc_frame_t {
    pub excno: u32,
    pub nest_count: u32,
    pub ipm: u32,
    pub r0: u32,
    pub r1: u32,
    pub r2: u32,
    pub r3: u32,
    pub r12: u32,
    pub lr: u32,
    pub pc: u32,
    pub cpsr: u32,
}
#[test]
fn bindgen_test_layout_exc_frame_t() {
    assert_eq!(::std::mem::size_of::<exc_frame_t>() , 44usize , concat ! (
               "Size of: " , stringify ! ( exc_frame_t ) ));
    assert_eq! (::std::mem::align_of::<exc_frame_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( exc_frame_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . excno as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( excno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . nest_count as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( nest_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . ipm as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( ipm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . r0 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( r0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . r1 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( r1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . r2 as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( r2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . r3 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( r3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . r12 as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . lr as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( lr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . pc as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( pc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . cpsr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( cpsr ) ));
}
impl Clone for exc_frame_t {
    fn clone(&self) -> Self { *self }
}
pub type TEXPTN = uint_t;
pub type FLGPTN = uint_t;
pub type OVRTIM = ulong_t;
pub type INTNO = uint_t;
pub type INHNO = uint_t;
pub type EXCNO = uint_t;
pub type TASK = ::std::option::Option<unsafe extern "C" fn(exinf: isize)>;
pub type TEXRTN =
    ::std::option::Option<unsafe extern "C" fn(texptn: TEXPTN, exinf: isize)>;
pub type CYCHDR = ::std::option::Option<unsafe extern "C" fn(exinf: isize)>;
pub type ALMHDR = ::std::option::Option<unsafe extern "C" fn(exinf: isize)>;
pub type OVRHDR =
    ::std::option::Option<unsafe extern "C" fn(tskid: ID, exinf: isize)>;
pub type ISR = ::std::option::Option<unsafe extern "C" fn(exinf: isize)>;
pub type INTHDR = ::std::option::Option<unsafe extern "C" fn()>;
pub type EXCHDR =
    ::std::option::Option<unsafe extern "C" fn(p_excinf:
                                                   *mut ::std::os::raw::c_void)>;
pub type EXTSVC =
    ::std::option::Option<unsafe extern "C" fn(par1: isize, par2: isize,
                                               par3: isize, par4: isize,
                                               par5: isize, cdmid: ID)
                              -> ER_UINT>;
pub type INIRTN = ::std::option::Option<unsafe extern "C" fn(exinf: isize)>;
pub type TERRTN = ::std::option::Option<unsafe extern "C" fn(exinf: isize)>;
pub type STK_T = ::std::os::raw::c_longlong;
pub type MPF_T = isize;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_ctsk {
    pub tskatr: ATR,
    pub exinf: isize,
    pub task: TASK,
    pub itskpri: PRI,
    pub stksz: SIZE,
    pub stk: *mut STK_T,
    pub sstksz: SIZE,
    pub sstk: *mut STK_T,
}
#[test]
fn bindgen_test_layout_t_ctsk() {
    assert_eq!(::std::mem::size_of::<t_ctsk>() , 64usize , concat ! (
               "Size of: " , stringify ! ( t_ctsk ) ));
    assert_eq! (::std::mem::align_of::<t_ctsk>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_ctsk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ctsk ) ) . tskatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ctsk ) , "::" ,
                stringify ! ( tskatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ctsk ) ) . exinf as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ctsk ) , "::" ,
                stringify ! ( exinf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ctsk ) ) . task as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ctsk ) , "::" ,
                stringify ! ( task ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ctsk ) ) . itskpri as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ctsk ) , "::" ,
                stringify ! ( itskpri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ctsk ) ) . stksz as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ctsk ) , "::" ,
                stringify ! ( stksz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ctsk ) ) . stk as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ctsk ) , "::" ,
                stringify ! ( stk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ctsk ) ) . sstksz as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ctsk ) , "::" ,
                stringify ! ( sstksz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ctsk ) ) . sstk as * const _ as usize }
                , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ctsk ) , "::" ,
                stringify ! ( sstk ) ));
}
impl Clone for t_ctsk {
    fn clone(&self) -> Self { *self }
}
pub type T_CTSK = t_ctsk;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rtsk {
    pub tskstat: STAT,
    pub tskpri: PRI,
    pub tskbpri: PRI,
    pub tskwait: STAT,
    pub wobjid: ID,
    pub lefttmo: TMO,
    pub actcnt: uint_t,
    pub wupcnt: uint_t,
    pub texmsk: bool_t,
    pub waifbd: bool_t,
    pub svclevel: uint_t,
}
#[test]
fn bindgen_test_layout_t_rtsk() {
    assert_eq!(::std::mem::size_of::<t_rtsk>() , 44usize , concat ! (
               "Size of: " , stringify ! ( t_rtsk ) ));
    assert_eq! (::std::mem::align_of::<t_rtsk>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rtsk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . tskstat as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( tskstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . tskpri as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( tskpri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . tskbpri as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( tskbpri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . tskwait as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( tskwait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . wobjid as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( wobjid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . lefttmo as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( lefttmo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . actcnt as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( actcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . wupcnt as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( wupcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . texmsk as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( texmsk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . waifbd as * const _ as usize
                } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( waifbd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . svclevel as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( svclevel ) ));
}
impl Clone for t_rtsk {
    fn clone(&self) -> Self { *self }
}
pub type T_RTSK = t_rtsk;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_dtex {
    pub texatr: ATR,
    pub texrtn: TEXRTN,
}
#[test]
fn bindgen_test_layout_t_dtex() {
    assert_eq!(::std::mem::size_of::<t_dtex>() , 16usize , concat ! (
               "Size of: " , stringify ! ( t_dtex ) ));
    assert_eq! (::std::mem::align_of::<t_dtex>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_dtex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_dtex ) ) . texatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_dtex ) , "::" ,
                stringify ! ( texatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_dtex ) ) . texrtn as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_dtex ) , "::" ,
                stringify ! ( texrtn ) ));
}
impl Clone for t_dtex {
    fn clone(&self) -> Self { *self }
}
pub type T_DTEX = t_dtex;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rtex {
    pub texstat: STAT,
    pub pndptn: TEXPTN,
}
#[test]
fn bindgen_test_layout_t_rtex() {
    assert_eq!(::std::mem::size_of::<t_rtex>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_rtex ) ));
    assert_eq! (::std::mem::align_of::<t_rtex>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rtex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtex ) ) . texstat as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtex ) , "::" ,
                stringify ! ( texstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtex ) ) . pndptn as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtex ) , "::" ,
                stringify ! ( pndptn ) ));
}
impl Clone for t_rtex {
    fn clone(&self) -> Self { *self }
}
pub type T_RTEX = t_rtex;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_csem {
    pub sematr: ATR,
    pub isemcnt: uint_t,
    pub maxsem: uint_t,
}
#[test]
fn bindgen_test_layout_t_csem() {
    assert_eq!(::std::mem::size_of::<t_csem>() , 12usize , concat ! (
               "Size of: " , stringify ! ( t_csem ) ));
    assert_eq! (::std::mem::align_of::<t_csem>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_csem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_csem ) ) . sematr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_csem ) , "::" ,
                stringify ! ( sematr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_csem ) ) . isemcnt as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_csem ) , "::" ,
                stringify ! ( isemcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_csem ) ) . maxsem as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_csem ) , "::" ,
                stringify ! ( maxsem ) ));
}
impl Clone for t_csem {
    fn clone(&self) -> Self { *self }
}
pub type T_CSEM = t_csem;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rsem {
    pub wtskid: ID,
    pub semcnt: uint_t,
}
#[test]
fn bindgen_test_layout_t_rsem() {
    assert_eq!(::std::mem::size_of::<t_rsem>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_rsem ) ));
    assert_eq! (::std::mem::align_of::<t_rsem>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rsem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rsem ) ) . wtskid as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rsem ) , "::" ,
                stringify ! ( wtskid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rsem ) ) . semcnt as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rsem ) , "::" ,
                stringify ! ( semcnt ) ));
}
impl Clone for t_rsem {
    fn clone(&self) -> Self { *self }
}
pub type T_RSEM = t_rsem;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_cflg {
    pub flgatr: ATR,
    pub iflgptn: FLGPTN,
}
#[test]
fn bindgen_test_layout_t_cflg() {
    assert_eq!(::std::mem::size_of::<t_cflg>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_cflg ) ));
    assert_eq! (::std::mem::align_of::<t_cflg>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_cflg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cflg ) ) . flgatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cflg ) , "::" ,
                stringify ! ( flgatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cflg ) ) . iflgptn as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cflg ) , "::" ,
                stringify ! ( iflgptn ) ));
}
impl Clone for t_cflg {
    fn clone(&self) -> Self { *self }
}
pub type T_CFLG = t_cflg;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rflg {
    pub wtskid: ID,
    pub flgptn: FLGPTN,
}
#[test]
fn bindgen_test_layout_t_rflg() {
    assert_eq!(::std::mem::size_of::<t_rflg>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_rflg ) ));
    assert_eq! (::std::mem::align_of::<t_rflg>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rflg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rflg ) ) . wtskid as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rflg ) , "::" ,
                stringify ! ( wtskid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rflg ) ) . flgptn as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rflg ) , "::" ,
                stringify ! ( flgptn ) ));
}
impl Clone for t_rflg {
    fn clone(&self) -> Self { *self }
}
pub type T_RFLG = t_rflg;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_cdtq {
    pub dtqatr: ATR,
    pub dtqcnt: uint_t,
    pub dtqmb: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_t_cdtq() {
    assert_eq!(::std::mem::size_of::<t_cdtq>() , 16usize , concat ! (
               "Size of: " , stringify ! ( t_cdtq ) ));
    assert_eq! (::std::mem::align_of::<t_cdtq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_cdtq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cdtq ) ) . dtqatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cdtq ) , "::" ,
                stringify ! ( dtqatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cdtq ) ) . dtqcnt as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cdtq ) , "::" ,
                stringify ! ( dtqcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cdtq ) ) . dtqmb as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cdtq ) , "::" ,
                stringify ! ( dtqmb ) ));
}
impl Clone for t_cdtq {
    fn clone(&self) -> Self { *self }
}
pub type T_CDTQ = t_cdtq;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rdtq {
    pub stskid: ID,
    pub rtskid: ID,
    pub sdtqcnt: uint_t,
}
#[test]
fn bindgen_test_layout_t_rdtq() {
    assert_eq!(::std::mem::size_of::<t_rdtq>() , 12usize , concat ! (
               "Size of: " , stringify ! ( t_rdtq ) ));
    assert_eq! (::std::mem::align_of::<t_rdtq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rdtq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rdtq ) ) . stskid as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rdtq ) , "::" ,
                stringify ! ( stskid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rdtq ) ) . rtskid as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rdtq ) , "::" ,
                stringify ! ( rtskid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rdtq ) ) . sdtqcnt as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rdtq ) , "::" ,
                stringify ! ( sdtqcnt ) ));
}
impl Clone for t_rdtq {
    fn clone(&self) -> Self { *self }
}
pub type T_RDTQ = t_rdtq;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_cpdq {
    pub pdqatr: ATR,
    pub pdqcnt: uint_t,
    pub maxdpri: PRI,
    pub pdqmb: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_t_cpdq() {
    assert_eq!(::std::mem::size_of::<t_cpdq>() , 24usize , concat ! (
               "Size of: " , stringify ! ( t_cpdq ) ));
    assert_eq! (::std::mem::align_of::<t_cpdq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_cpdq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cpdq ) ) . pdqatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cpdq ) , "::" ,
                stringify ! ( pdqatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cpdq ) ) . pdqcnt as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cpdq ) , "::" ,
                stringify ! ( pdqcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cpdq ) ) . maxdpri as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cpdq ) , "::" ,
                stringify ! ( maxdpri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cpdq ) ) . pdqmb as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cpdq ) , "::" ,
                stringify ! ( pdqmb ) ));
}
impl Clone for t_cpdq {
    fn clone(&self) -> Self { *self }
}
pub type T_CPDQ = t_cpdq;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rpdq {
    pub stskid: ID,
    pub rtskid: ID,
    pub spdqcnt: uint_t,
}
#[test]
fn bindgen_test_layout_t_rpdq() {
    assert_eq!(::std::mem::size_of::<t_rpdq>() , 12usize , concat ! (
               "Size of: " , stringify ! ( t_rpdq ) ));
    assert_eq! (::std::mem::align_of::<t_rpdq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rpdq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rpdq ) ) . stskid as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rpdq ) , "::" ,
                stringify ! ( stskid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rpdq ) ) . rtskid as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rpdq ) , "::" ,
                stringify ! ( rtskid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rpdq ) ) . spdqcnt as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rpdq ) , "::" ,
                stringify ! ( spdqcnt ) ));
}
impl Clone for t_rpdq {
    fn clone(&self) -> Self { *self }
}
pub type T_RPDQ = t_rpdq;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_cmtx {
    pub mtxatr: ATR,
    pub ceilpri: PRI,
}
#[test]
fn bindgen_test_layout_t_cmtx() {
    assert_eq!(::std::mem::size_of::<t_cmtx>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_cmtx ) ));
    assert_eq! (::std::mem::align_of::<t_cmtx>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_cmtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cmtx ) ) . mtxatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cmtx ) , "::" ,
                stringify ! ( mtxatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cmtx ) ) . ceilpri as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cmtx ) , "::" ,
                stringify ! ( ceilpri ) ));
}
impl Clone for t_cmtx {
    fn clone(&self) -> Self { *self }
}
pub type T_CMTX = t_cmtx;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rmtx {
    pub htskid: ID,
    pub wtskid: ID,
}
#[test]
fn bindgen_test_layout_t_rmtx() {
    assert_eq!(::std::mem::size_of::<t_rmtx>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_rmtx ) ));
    assert_eq! (::std::mem::align_of::<t_rmtx>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rmtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rmtx ) ) . htskid as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rmtx ) , "::" ,
                stringify ! ( htskid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rmtx ) ) . wtskid as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rmtx ) , "::" ,
                stringify ! ( wtskid ) ));
}
impl Clone for t_rmtx {
    fn clone(&self) -> Self { *self }
}
pub type T_RMTX = t_rmtx;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_cmpf {
    pub mpfatr: ATR,
    pub blkcnt: uint_t,
    pub blksz: uint_t,
    pub mpf: *mut MPF_T,
    pub mpfmb: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_t_cmpf() {
    assert_eq!(::std::mem::size_of::<t_cmpf>() , 32usize , concat ! (
               "Size of: " , stringify ! ( t_cmpf ) ));
    assert_eq! (::std::mem::align_of::<t_cmpf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_cmpf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cmpf ) ) . mpfatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cmpf ) , "::" ,
                stringify ! ( mpfatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cmpf ) ) . blkcnt as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cmpf ) , "::" ,
                stringify ! ( blkcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cmpf ) ) . blksz as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cmpf ) , "::" ,
                stringify ! ( blksz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cmpf ) ) . mpf as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cmpf ) , "::" ,
                stringify ! ( mpf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cmpf ) ) . mpfmb as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cmpf ) , "::" ,
                stringify ! ( mpfmb ) ));
}
impl Clone for t_cmpf {
    fn clone(&self) -> Self { *self }
}
pub type T_CMPF = t_cmpf;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rmpf {
    pub wtskid: ID,
    pub fblkcnt: uint_t,
}
#[test]
fn bindgen_test_layout_t_rmpf() {
    assert_eq!(::std::mem::size_of::<t_rmpf>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_rmpf ) ));
    assert_eq! (::std::mem::align_of::<t_rmpf>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rmpf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rmpf ) ) . wtskid as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rmpf ) , "::" ,
                stringify ! ( wtskid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rmpf ) ) . fblkcnt as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rmpf ) , "::" ,
                stringify ! ( fblkcnt ) ));
}
impl Clone for t_rmpf {
    fn clone(&self) -> Self { *self }
}
pub type T_RMPF = t_rmpf;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_ccyc {
    pub cycatr: ATR,
    pub exinf: isize,
    pub cychdr: CYCHDR,
    pub cyctim: RELTIM,
    pub cycphs: RELTIM,
}
#[test]
fn bindgen_test_layout_t_ccyc() {
    assert_eq!(::std::mem::size_of::<t_ccyc>() , 32usize , concat ! (
               "Size of: " , stringify ! ( t_ccyc ) ));
    assert_eq! (::std::mem::align_of::<t_ccyc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_ccyc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ccyc ) ) . cycatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ccyc ) , "::" ,
                stringify ! ( cycatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ccyc ) ) . exinf as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ccyc ) , "::" ,
                stringify ! ( exinf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ccyc ) ) . cychdr as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ccyc ) , "::" ,
                stringify ! ( cychdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ccyc ) ) . cyctim as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ccyc ) , "::" ,
                stringify ! ( cyctim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ccyc ) ) . cycphs as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ccyc ) , "::" ,
                stringify ! ( cycphs ) ));
}
impl Clone for t_ccyc {
    fn clone(&self) -> Self { *self }
}
pub type T_CCYC = t_ccyc;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rcyc {
    pub cycstat: STAT,
    pub lefttim: RELTIM,
}
#[test]
fn bindgen_test_layout_t_rcyc() {
    assert_eq!(::std::mem::size_of::<t_rcyc>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_rcyc ) ));
    assert_eq! (::std::mem::align_of::<t_rcyc>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rcyc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rcyc ) ) . cycstat as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rcyc ) , "::" ,
                stringify ! ( cycstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rcyc ) ) . lefttim as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rcyc ) , "::" ,
                stringify ! ( lefttim ) ));
}
impl Clone for t_rcyc {
    fn clone(&self) -> Self { *self }
}
pub type T_RCYC = t_rcyc;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_calm {
    pub almatr: ATR,
    pub exinf: isize,
    pub almhdr: ALMHDR,
}
#[test]
fn bindgen_test_layout_t_calm() {
    assert_eq!(::std::mem::size_of::<t_calm>() , 24usize , concat ! (
               "Size of: " , stringify ! ( t_calm ) ));
    assert_eq! (::std::mem::align_of::<t_calm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_calm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_calm ) ) . almatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_calm ) , "::" ,
                stringify ! ( almatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_calm ) ) . exinf as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_calm ) , "::" ,
                stringify ! ( exinf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_calm ) ) . almhdr as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( t_calm ) , "::" ,
                stringify ! ( almhdr ) ));
}
impl Clone for t_calm {
    fn clone(&self) -> Self { *self }
}
pub type T_CALM = t_calm;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_ralm {
    pub almstat: STAT,
    pub lefttim: RELTIM,
}
#[test]
fn bindgen_test_layout_t_ralm() {
    assert_eq!(::std::mem::size_of::<t_ralm>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_ralm ) ));
    assert_eq! (::std::mem::align_of::<t_ralm>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_ralm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ralm ) ) . almstat as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ralm ) , "::" ,
                stringify ! ( almstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ralm ) ) . lefttim as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ralm ) , "::" ,
                stringify ! ( lefttim ) ));
}
impl Clone for t_ralm {
    fn clone(&self) -> Self { *self }
}
pub type T_RALM = t_ralm;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rovr {
    pub ovrstat: STAT,
    pub leftotm: OVRTIM,
}
#[test]
fn bindgen_test_layout_t_rovr() {
    assert_eq!(::std::mem::size_of::<t_rovr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( t_rovr ) ));
    assert_eq! (::std::mem::align_of::<t_rovr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_rovr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rovr ) ) . ovrstat as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rovr ) , "::" ,
                stringify ! ( ovrstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rovr ) ) . leftotm as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rovr ) , "::" ,
                stringify ! ( leftotm ) ));
}
impl Clone for t_rovr {
    fn clone(&self) -> Self { *self }
}
pub type T_ROVR = t_rovr;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_cisr {
    pub isratr: ATR,
    pub exinf: isize,
    pub intno: INTNO,
    pub isr: ISR,
    pub isrpri: PRI,
}
#[test]
fn bindgen_test_layout_t_cisr() {
    assert_eq!(::std::mem::size_of::<t_cisr>() , 40usize , concat ! (
               "Size of: " , stringify ! ( t_cisr ) ));
    assert_eq! (::std::mem::align_of::<t_cisr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_cisr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cisr ) ) . isratr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cisr ) , "::" ,
                stringify ! ( isratr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cisr ) ) . exinf as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cisr ) , "::" ,
                stringify ! ( exinf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cisr ) ) . intno as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cisr ) , "::" ,
                stringify ! ( intno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cisr ) ) . isr as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cisr ) , "::" ,
                stringify ! ( isr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cisr ) ) . isrpri as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cisr ) , "::" ,
                stringify ! ( isrpri ) ));
}
impl Clone for t_cisr {
    fn clone(&self) -> Self { *self }
}
pub type T_CISR = t_cisr;
extern "C" {
    pub fn _kernel_act_tsk(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_iact_tsk(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_can_act(tskid: ID) -> ER_UINT;
}
extern "C" {
    pub fn _kernel_ext_tsk() -> ER;
}
extern "C" {
    pub fn _kernel_ter_tsk(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_chg_pri(tskid: ID, tskpri: PRI) -> ER;
}
extern "C" {
    pub fn _kernel_get_pri(tskid: ID, p_tskpri: *mut PRI) -> ER;
}
extern "C" {
    pub fn _kernel_get_inf(p_exinf: *mut isize) -> ER;
}
extern "C" {
    pub fn _kernel_slp_tsk() -> ER;
}
extern "C" {
    pub fn _kernel_tslp_tsk(tmout: TMO) -> ER;
}
extern "C" {
    pub fn _kernel_wup_tsk(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_iwup_tsk(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_can_wup(tskid: ID) -> ER_UINT;
}
extern "C" {
    pub fn _kernel_rel_wai(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_irel_wai(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_dis_wai(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_idis_wai(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_ena_wai(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_iena_wai(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_sus_tsk(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_rsm_tsk(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_dly_tsk(dlytim: RELTIM) -> ER;
}
extern "C" {
    pub fn _kernel_ras_tex(tskid: ID, rasptn: TEXPTN) -> ER;
}
extern "C" {
    pub fn _kernel_iras_tex(tskid: ID, rasptn: TEXPTN) -> ER;
}
extern "C" {
    pub fn _kernel_dis_tex() -> ER;
}
extern "C" {
    pub fn _kernel_ena_tex() -> ER;
}
extern "C" {
    pub fn _kernel_sns_tex() -> bool_t;
}
extern "C" {
    pub fn _kernel_ref_tex(tskid: ID, pk_rtex: *mut T_RTEX) -> ER;
}
extern "C" {
    pub fn _kernel_sig_sem(semid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_isig_sem(semid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_wai_sem(semid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_pol_sem(semid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_twai_sem(semid: ID, tmout: TMO) -> ER;
}
extern "C" {
    pub fn _kernel_set_flg(flgid: ID, setptn: FLGPTN) -> ER;
}
extern "C" {
    pub fn _kernel_iset_flg(flgid: ID, setptn: FLGPTN) -> ER;
}
extern "C" {
    pub fn _kernel_clr_flg(flgid: ID, clrptn: FLGPTN) -> ER;
}
extern "C" {
    pub fn _kernel_wai_flg(flgid: ID, waiptn: FLGPTN, wfmode: MODE,
                           p_flgptn: *mut FLGPTN) -> ER;
}
extern "C" {
    pub fn _kernel_pol_flg(flgid: ID, waiptn: FLGPTN, wfmode: MODE,
                           p_flgptn: *mut FLGPTN) -> ER;
}
extern "C" {
    pub fn _kernel_twai_flg(flgid: ID, waiptn: FLGPTN, wfmode: MODE,
                            p_flgptn: *mut FLGPTN, tmout: TMO) -> ER;
}
extern "C" {
    pub fn _kernel_snd_dtq(dtqid: ID, data: isize) -> ER;
}
extern "C" {
    pub fn _kernel_psnd_dtq(dtqid: ID, data: isize) -> ER;
}
extern "C" {
    pub fn _kernel_ipsnd_dtq(dtqid: ID, data: isize) -> ER;
}
extern "C" {
    pub fn _kernel_tsnd_dtq(dtqid: ID, data: isize, tmout: TMO) -> ER;
}
extern "C" {
    pub fn _kernel_fsnd_dtq(dtqid: ID, data: isize) -> ER;
}
extern "C" {
    pub fn _kernel_ifsnd_dtq(dtqid: ID, data: isize) -> ER;
}
extern "C" {
    pub fn _kernel_rcv_dtq(dtqid: ID, p_data: *mut isize) -> ER;
}
extern "C" {
    pub fn _kernel_prcv_dtq(dtqid: ID, p_data: *mut isize) -> ER;
}
extern "C" {
    pub fn _kernel_trcv_dtq(dtqid: ID, p_data: *mut isize, tmout: TMO) -> ER;
}
extern "C" {
    pub fn _kernel_snd_pdq(pdqid: ID, data: isize, datapri: PRI) -> ER;
}
extern "C" {
    pub fn _kernel_psnd_pdq(pdqid: ID, data: isize, datapri: PRI) -> ER;
}
extern "C" {
    pub fn _kernel_ipsnd_pdq(pdqid: ID, data: isize, datapri: PRI) -> ER;
}
extern "C" {
    pub fn _kernel_tsnd_pdq(pdqid: ID, data: isize, datapri: PRI, tmout: TMO)
     -> ER;
}
extern "C" {
    pub fn _kernel_rcv_pdq(pdqid: ID, p_data: *mut isize, p_datapri: *mut PRI)
     -> ER;
}
extern "C" {
    pub fn _kernel_prcv_pdq(pdqid: ID, p_data: *mut isize,
                            p_datapri: *mut PRI) -> ER;
}
extern "C" {
    pub fn _kernel_trcv_pdq(pdqid: ID, p_data: *mut isize,
                            p_datapri: *mut PRI, tmout: TMO) -> ER;
}
extern "C" {
    pub fn _kernel_loc_mtx(mtxid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_ploc_mtx(mtxid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_tloc_mtx(mtxid: ID, tmout: TMO) -> ER;
}
extern "C" {
    pub fn _kernel_unl_mtx(mtxid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_get_mpf(mpfid: ID, p_blk: *mut *mut ::std::os::raw::c_void)
     -> ER;
}
extern "C" {
    pub fn _kernel_pget_mpf(mpfid: ID,
                            p_blk: *mut *mut ::std::os::raw::c_void) -> ER;
}
extern "C" {
    pub fn _kernel_tget_mpf(mpfid: ID,
                            p_blk: *mut *mut ::std::os::raw::c_void,
                            tmout: TMO) -> ER;
}
extern "C" {
    pub fn _kernel_rel_mpf(mpfid: ID, blk: *mut ::std::os::raw::c_void) -> ER;
}
extern "C" {
    pub fn _kernel_get_tim(p_systim: *mut SYSTIM) -> ER;
}
extern "C" {
    pub fn _kernel_get_utm(p_sysutm: *mut SYSUTM) -> ER;
}
extern "C" {
    pub fn _kernel_ref_ovr(tskid: ID, pk_rovr: *mut T_ROVR) -> ER;
}
extern "C" {
    pub fn _kernel_sta_cyc(cycid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_stp_cyc(cycid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_sta_alm(almid: ID, almtim: RELTIM) -> ER;
}
extern "C" {
    pub fn _kernel_ista_alm(almid: ID, almtim: RELTIM) -> ER;
}
extern "C" {
    pub fn _kernel_stp_alm(almid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_istp_alm(almid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_sta_ovr(tskid: ID, ovrtim: OVRTIM) -> ER;
}
extern "C" {
    pub fn _kernel_ista_ovr(tskid: ID, ovrtim: OVRTIM) -> ER;
}
extern "C" {
    pub fn _kernel_stp_ovr(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_istp_ovr(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_rot_rdq(tskpri: PRI) -> ER;
}
extern "C" {
    pub fn _kernel_irot_rdq(tskpri: PRI) -> ER;
}
extern "C" {
    pub fn _kernel_get_did(p_domid: *mut ID) -> ER;
}
extern "C" {
    pub fn _kernel_get_tid(p_tskid: *mut ID) -> ER;
}
extern "C" {
    pub fn _kernel_iget_tid(p_tskid: *mut ID) -> ER;
}
extern "C" {
    pub fn _kernel_loc_cpu() -> ER;
}
extern "C" {
    pub fn _kernel_iloc_cpu() -> ER;
}
extern "C" {
    pub fn _kernel_unl_cpu() -> ER;
}
extern "C" {
    pub fn _kernel_iunl_cpu() -> ER;
}
extern "C" {
    pub fn _kernel_dis_dsp() -> ER;
}
extern "C" {
    pub fn _kernel_ena_dsp() -> ER;
}
extern "C" {
    pub fn _kernel_sns_ctx() -> bool_t;
}
extern "C" {
    pub fn _kernel_sns_loc() -> bool_t;
}
extern "C" {
    pub fn _kernel_sns_dsp() -> bool_t;
}
extern "C" {
    pub fn _kernel_sns_dpn() -> bool_t;
}
extern "C" {
    pub fn _kernel_sns_ker() -> bool_t;
}
extern "C" {
    pub fn _kernel_ext_ker() -> ER;
}
extern "C" {
    pub fn _kernel_prb_mem(base: *const ::std::os::raw::c_void, size: SIZE,
                           tskid: ID, pmmode: MODE) -> ER;
}
extern "C" {
    pub fn _kernel_dis_int(intno: INTNO) -> ER;
}
extern "C" {
    pub fn _kernel_ena_int(intno: INTNO) -> ER;
}
extern "C" {
    pub fn _kernel_chg_ipm(intpri: PRI) -> ER;
}
extern "C" {
    pub fn _kernel_get_ipm(p_intpri: *mut PRI) -> ER;
}
extern "C" {
    pub fn _kernel_xsns_dpn(p_excinf: *mut ::std::os::raw::c_void) -> bool_t;
}
extern "C" {
    pub fn _kernel_xsns_xpn(p_excinf: *mut ::std::os::raw::c_void) -> bool_t;
}
extern "C" {
    pub fn _kernel_ini_sem(semid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_ini_flg(flgid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_ini_dtq(dtqid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_ini_pdq(pdqid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_ini_mtx(mtxid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_ini_mpf(mpfid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_ref_tsk(tskid: ID, pk_rtsk: *mut T_RTSK) -> ER;
}
extern "C" {
    pub fn _kernel_ref_sem(semid: ID, pk_rsem: *mut T_RSEM) -> ER;
}
extern "C" {
    pub fn _kernel_ref_flg(flgid: ID, pk_rflg: *mut T_RFLG) -> ER;
}
extern "C" {
    pub fn _kernel_ref_dtq(dtqid: ID, pk_rdtq: *mut T_RDTQ) -> ER;
}
extern "C" {
    pub fn _kernel_ref_pdq(pdqid: ID, pk_rpdq: *mut T_RPDQ) -> ER;
}
extern "C" {
    pub fn _kernel_ref_mtx(mtxid: ID, pk_rmtx: *mut T_RMTX) -> ER;
}
extern "C" {
    pub fn _kernel_ref_mpf(mpfid: ID, pk_rmpf: *mut T_RMPF) -> ER;
}
extern "C" {
    pub fn _kernel_ref_cyc(cycid: ID, pk_rcyc: *mut T_RCYC) -> ER;
}
extern "C" {
    pub fn _kernel_ref_alm(almid: ID, pk_ralm: *mut T_RALM) -> ER;
}
extern "C" {
    pub fn _kernel_acre_tsk(pk_ctsk: *const T_CTSK) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_sem(pk_csem: *const T_CSEM) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_flg(pk_cflg: *const T_CFLG) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_dtq(pk_cdtq: *const T_CDTQ) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_pdq(pk_cpdq: *const T_CPDQ) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_mtx(pk_cmtx: *const T_CMTX) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_mpf(pk_cmpf: *const T_CMPF) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_cyc(pk_ccyc: *const T_CCYC) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_alm(pk_calm: *const T_CALM) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_isr(pk_cisr: *const T_CISR) -> ER_ID;
}
extern "C" {
    pub fn _kernel_del_tsk(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_sem(semid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_flg(flgid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_dtq(dtqid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_pdq(pdqid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_mtx(mtxid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_mpf(mpfid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_cyc(cycid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_alm(almid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_isr(isrid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_sac_tsk(tskid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_sem(semid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_flg(flgid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_dtq(dtqid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_pdq(pdqid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_mtx(mtxid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_mpf(mpfid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_cyc(cycid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_alm(almid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_isr(isrid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_def_tex(tskid: ID, pk_dtex: *const T_DTEX) -> ER;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SYSLOG {
    pub logtype: uint_t,
    pub logtim: SYSTIM,
    pub loginfo: [isize; 6usize],
}
#[test]
fn bindgen_test_layout_SYSLOG() {
    assert_eq!(::std::mem::size_of::<SYSLOG>() , 64usize , concat ! (
               "Size of: " , stringify ! ( SYSLOG ) ));
    assert_eq! (::std::mem::align_of::<SYSLOG>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SYSLOG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SYSLOG ) ) . logtype as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SYSLOG ) , "::" ,
                stringify ! ( logtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SYSLOG ) ) . logtim as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SYSLOG ) , "::" ,
                stringify ! ( logtim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SYSLOG ) ) . loginfo as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SYSLOG ) , "::" ,
                stringify ! ( loginfo ) ));
}
impl Clone for SYSLOG {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_syslog_rlog {
    pub count: uint_t,
    pub lost: uint_t,
    pub logmask: uint_t,
    pub lowmask: uint_t,
}
#[test]
fn bindgen_test_layout_t_syslog_rlog() {
    assert_eq!(::std::mem::size_of::<t_syslog_rlog>() , 16usize , concat ! (
               "Size of: " , stringify ! ( t_syslog_rlog ) ));
    assert_eq! (::std::mem::align_of::<t_syslog_rlog>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_syslog_rlog ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_syslog_rlog ) ) . count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_syslog_rlog ) , "::"
                , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_syslog_rlog ) ) . lost as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_syslog_rlog ) , "::"
                , stringify ! ( lost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_syslog_rlog ) ) . logmask as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_syslog_rlog ) , "::"
                , stringify ! ( logmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_syslog_rlog ) ) . lowmask as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( t_syslog_rlog ) , "::"
                , stringify ! ( lowmask ) ));
}
impl Clone for t_syslog_rlog {
    fn clone(&self) -> Self { *self }
}
pub type T_SYSLOG_RLOG = t_syslog_rlog;
extern "C" {
    pub fn _syslog_wri_log(prio: uint_t, p_syslog: *const SYSLOG, cdmid: ID)
     -> ER;
}
extern "C" {
    pub fn _syslog_fwri_log(ercd: ER, p_syslog: *const SYSLOG, cdmid: ID)
     -> ER;
}
extern "C" {
    pub fn syslog(prio: uint_t, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn itron_strerror(ercd: ER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn t_perror(prio: uint_t, file: *const ::std::os::raw::c_char,
                    line: int_t, expr: *const ::std::os::raw::c_char,
                    ercd: ER);
}
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int,
                    arg4: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(arg1: *const ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char,
                      arg3: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(arg1: ::std::os::raw::c_int,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_int,
                        arg4: *const ::std::os::raw::c_char,
                        arg5: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(::std::mem::size_of::<__sbuf>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sbuf ) ));
    assert_eq! (::std::mem::align_of::<__sbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _base as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _size as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _size ) ));
}
impl Clone for __sbuf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    pub _read: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2:
                                                              *mut ::std::os::raw::c_char,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int>,
    pub _seek: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2: fpos_t,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> fpos_t>,
    pub _write: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void,
                                                           arg2:
                                                               *const ::std::os::raw::c_char,
                                                           arg3:
                                                               ::std::os::raw::c_int)
                                          -> ::std::os::raw::c_int>,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(::std::mem::size_of::<__sFILE>() , 152usize , concat ! (
               "Size of: " , stringify ! ( __sFILE ) ));
    assert_eq! (::std::mem::align_of::<__sFILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sFILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _p as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _r as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _w as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _file as * const _ as usize
                } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _bf as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _bf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lbfsize as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lbfsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _cookie as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _close as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _read as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _seek as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _write as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ub as * const _ as usize }
                , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ub ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _extra as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _extra ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ur as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ubuf as * const _ as usize
                } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ubuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _nbuf as * const _ as usize
                } , 119usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _nbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lb as * const _ as usize }
                , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _blksize as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _blksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _offset ) ));
}
impl Clone for __sFILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = __sFILE;
extern "C" {
    #[link_name = "__stdinp"]
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    #[link_name = "__stdoutp"]
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    #[link_name = "__stderrp"]
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(arg1: *mut ::std::os::raw::c_char,
                 arg2: ::std::os::raw::c_int, arg3: *mut FILE)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __nitems: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn freopen(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: *mut FILE)
     -> *mut FILE;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: ::std::os::raw::c_long,
                 arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __nitems: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int, arg4: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int,
                  arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                      arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __prefix: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __offset: off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(__str: *mut ::std::os::raw::c_char, __size: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char,
                   arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__str: *mut ::std::os::raw::c_char, __size: usize,
                     __format: *const ::std::os::raw::c_char,
                     arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__str: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(arg1: ::std::os::raw::c_int,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(__linep: *mut *mut ::std::os::raw::c_char,
                    __linecapp: *mut usize,
                    __delimiter: ::std::os::raw::c_int, __stream: *mut FILE)
     -> isize;
}
extern "C" {
    pub fn getline(__linep: *mut *mut ::std::os::raw::c_char,
                   __linecapp: *mut usize, __stream: *mut FILE) -> isize;
}
extern "C" {
    pub fn fmemopen(__buf: *mut ::std::os::raw::c_void, __size: usize,
                    __mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufp: *mut *mut ::std::os::raw::c_char,
                          __sizep: *mut usize) -> *mut FILE;
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(arg1: *mut *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(arg1: *const ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                     arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zopen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char,
                 arg3: ::std::os::raw::c_int) -> *mut FILE;
}
extern "C" {
    pub fn funopen(arg1: *const ::std::os::raw::c_void,
                   arg2:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *mut ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg3:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg4:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      fpos_t,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> fpos_t>,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(arg1: *mut ::std::os::raw::c_char,
                         arg2: ::std::os::raw::c_int, arg3: usize,
                         arg4: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                          arg3: ::std::os::raw::c_int, arg4: usize,
                          arg5: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(arg1: *mut ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int, arg3: usize,
                          arg4: *const ::std::os::raw::c_char,
                          arg5: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                           arg3: ::std::os::raw::c_int, arg4: usize,
                           arg5: *const ::std::os::raw::c_char,
                           arg6: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
#[repr(u32)]
/**
 * \~English
 * \brief Enumeration type for buttons
 *
 * \~Japanese
 * \brief ボタンを表す番号
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum button_t {
    LEFT_BUTTON = 0,
    RIGHT_BUTTON = 1,
    UP_BUTTON = 2,
    DOWN_BUTTON = 3,
    ENTER_BUTTON = 4,
    BACK_BUTTON = 5,
    TNUM_BUTTON = 6,
}
extern "C" {
    /**
 * \~English
 * \brief         Get the pressed state of the button.
 * \details       When an invalid button number is specified , always returns \a false  [TODO: check - error log is output]．
 * \param  button Button number
 * \retval true   Pressed state
 * \retval false  Unpressed state
 *
 * \~Japanese
 * \brief         ボタンの押下状態を取得する．
 * \details       不正のボタン番号を指定した場合，常に \a false を返す（エラーログが出力される）．
 * \param  button ボタン番号
 * \retval true   押されている状態
 * \retval false  押されていない状態
 */
    pub fn ev3_button_is_pressed(button: button_t) -> bool_t;
}
extern "C" {
    /**
 * \~English
 * [TODO: sync with jp version]
 * \brief 		  Attach a click event handler for a button.
 * \details		  The button handler executes in the task contest. The default is called from the wait disabled state.
 * \param button  the button to be set
 * \param handler the handler to be attached, NULL for clearing the current handler
 * \param exinf   extra information passed to the \a handler when it is called
 * \retval E_OK   Successful completion
 * \retval E_ID   Invalid button number
 *
 * \~Japanese
 * \brief          指定したボタンのクリックイベントハンドラを設定する．
 * \details        ボタンハンドラはタスクコンテストで実行する．デフォルトは，待ち禁止状態から呼び出される．
 * \param  button  ボタン番号
 * \param  handler イベントハンドラ．NULLを指定した場合，元のハンドラがクリアされる
 * \param  exinf   イベントハンドラの拡張情報
 * \retval E_OK    正常終了
 * \retval E_ID    不正のボタン番号
 */
    pub fn ev3_button_set_on_clicked(button: button_t, handler: ISR,
                                     exinf: isize) -> ER;
}
/**
 * \~English
 * \brief A memory file is a file stored in RAM rather than on the SD card.
 *
 * \~Japanese
 * \brief メモリファイルの構造体．メモリファイルのデータは，SDカードではなく，メモリに格納される．
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct memfile_t {
    //< \~English Pointer of the buffer where this file is stored. NULL means a invalid memory file. \~Japanese このファイルが格納されているバッファへのポインタ．NULLは無効なメモリファイル．
    pub buffer: *mut ::std::os::raw::c_void,
    //< \~English Actual size of this file	 					                                     \~Japanese ファイルの実際のサイズ
    pub filesz: u32,
    //< \~English Maximum size of the buffer to store this file   									 \~Japanese バッファの最大サイズ
    pub buffersz: u32,
}
#[test]
fn bindgen_test_layout_memfile_t() {
    assert_eq!(::std::mem::size_of::<memfile_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( memfile_t ) ));
    assert_eq! (::std::mem::align_of::<memfile_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( memfile_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memfile_t ) ) . buffer as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( memfile_t ) , "::" ,
                stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memfile_t ) ) . filesz as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( memfile_t ) , "::" ,
                stringify ! ( filesz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memfile_t ) ) . buffersz as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( memfile_t ) , "::" ,
                stringify ! ( buffersz ) ));
}
impl Clone for memfile_t {
    fn clone(&self) -> Self { *self }
}
/**
 * \~English
 * \brief Structure of file information.
 *
 * \~Japanese
 * \brief ファイル情報の構造体．
 */
#[repr(C)]
pub struct fileinfo_t {
    //< \~English File size          \~Japanese ファイルのサイズ
    pub size: u32,
    //< \~English Last modified date \~Japanese ファイルのLast modified date
    pub date: u16,
    //< \~English Last modified time \~Japanese ファイルのLast modified time
    pub time: u16,
    //< \~English Flag of a folder   \~Japanese フォルダであることを表すフラグ
    pub is_dir: bool_t,
    //< \~English Flag of read-only  \~Japanese 読み出し専用であることを表すフラグ
    pub is_readonly: bool_t,
    //< \~English Flag of hidden     \~Japanese 隠しファイルであることを表すフラグ
    pub is_hidden: bool_t,
    //< \~English File name          \~Japanese ファイル名
    pub name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_fileinfo_t() {
    assert_eq!(::std::mem::size_of::<fileinfo_t>() , 276usize , concat ! (
               "Size of: " , stringify ! ( fileinfo_t ) ));
    assert_eq! (::std::mem::align_of::<fileinfo_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( fileinfo_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileinfo_t ) ) . size as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fileinfo_t ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileinfo_t ) ) . date as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( fileinfo_t ) , "::" ,
                stringify ! ( date ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileinfo_t ) ) . time as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( fileinfo_t ) , "::" ,
                stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileinfo_t ) ) . is_dir as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( fileinfo_t ) , "::" ,
                stringify ! ( is_dir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileinfo_t ) ) . is_readonly as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( fileinfo_t ) , "::" ,
                stringify ! ( is_readonly ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileinfo_t ) ) . is_hidden as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( fileinfo_t ) , "::" ,
                stringify ! ( is_hidden ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileinfo_t ) ) . name as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( fileinfo_t ) , "::" ,
                stringify ! ( name ) ));
}
extern "C" {
    /**
 * \~English
 * \brief      Open a directory for reading.
 * \details    If it succeeds, it returns the ID of the opened directory as a return value. This ID can be used to obtain file information in the directory.
 * \param path Path of the directory to be opened
 * \retval >0     ID of the opened directory
 * \retval E_CTX  Call from non-task contest
 * \retval E_MACV Memory access violation (path)
 * \retval E_NOID Insufficient ID number
 * \retval E_PAR  Invalid path name
 * \retval E_SYS  I/O error occurred (High possibility of SD card failure)
 *
 * \~Japanese
 * \brief         ディレクトリをオープンする．
 * \details       成功した場合，オープンされたディレクトリのIDを戻り値として返す．このIDはディレクトリ内のファイル情報を取得するために使える．
 * \param  path   ディレクトリのパス
 * \retval >0     オープンされたディレクトリのID
 * \retval E_CTX  非タスクコンテストから呼び出す
 * \retval E_MACV メモリアクセス違反（path）
 * \retval E_NOID ID番号不足
 * \retval E_PAR  パス名は無効
 * \retval E_SYS  I/Oエラーが発生した（SDカード不良の可能性が高い）
 */
    pub fn ev3_sdcard_opendir(path: *const ::std::os::raw::c_char) -> ER_ID;
}
extern "C" {
    /**
 * \~English
 * \brief             Read file information in the directory.
 * \details   	      Return information on the next file from the opened directory. [TODO: check]
 * \param  dirid      ID of an opened directory
 * \param  p_fileinfo Pointer to structure with information of storing file [TODO: check].
 * \retval E_OK       Success
 * \retval E_CTX      Call from non-task contest
 * \retval E_ID       Invalid ID number
 * \retval E_MACV     Memory access violation (p_fileinfo)
 * \retval E_OBJ      There is no information on files that can be read any more
 * \retval E_SYS      I/O error occurred (High possibility of SD card failure)
 *
 * \~Japanese
 * \brief             ディレクトリ内のファイル情報を読み込む．
 * \details           オープンされたディレクトリから次のファイルの情報を返す．
 * \param  dirid      ディレクトリのID
 * \param  p_fileinfo ファイル情報を格納する場所へのポインタ
 * \retval E_OK       正常終了
 * \retval E_CTX      非タスクコンテストから呼び出す
 * \retval E_ID       不正ID番号
 * \retval E_MACV     メモリアクセス違反（p_fileinfo）
 * \retval E_OBJ      これ以上読み込めるファイルの情報がない
 * \retval E_SYS  I/Oエラーが発生した（SDカード不良の可能性が高い）
 */
    pub fn ev3_sdcard_readdir(dirid: ID, p_fileinfo: *mut fileinfo_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief             Close a directory.
 * \details           If it succeeds, it releases the resource of the opened directory, and its ID can not be used.
 * \param  dirid      ID of an opened directory
 * \retval E_OK       Success
 * \retval E_CTX      Call from non-task contest
 * \retval E_ID       Invalid ID number
 * \retval E_SYS      I/O error occurred (High possibility of SD card failure)
 *
 * \~Japanese
 * \brief          ディレクトリをクローズする．
 * \details        成功した場合，オープンされたディレクトリのリソースを解放して，そのIDは使えなくなる．
 * \param  dirid   ディレクトリのID
 * \retval E_OK    正常終了
 * \retval E_CTX   非タスクコンテストから呼び出す
 * \retval E_ID    不正ID番号
 * \retval E_SYS   I/Oエラーが発生した（SDカード不良の可能性が高い）
 */
    pub fn ev3_sdcard_closedir(dirid: ID) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief            Create a memory file and load a specific file into it from the SD card.
 * \details          Generates an object of the memory file and reads the specified file from the SD card into this memory file. If an error occurs , clear buffer in \a p_memfile to \a NULL.
 * \param  path      Path of the file to be loaded
 * \param  p_memfile Pointer of save the created memory file
 * \retval E_OK      Success
 * \retval E_MACV    Memory access violation (path or p_memfile)
 * \retval E_NOMEM   No enough free memory to create the memory file, or \a p_memfile is NULL. The \a buffer of \a p_memfile will be set to NULL if this happens.
 * \retval E_PAR     The \a path does not point to a valid file. The \a buffer of \a p_memfile will be set to NULL if this happens.
 * \retval E_SYS     I/O failure, which might be caused by a corrupted SD card. The \a buffer of \a p_memfile will be set to NULL if this happens.
 *
 * \~Japanese
 * \brief            SDカードのファイルをメモリファイルとしてロードする．
 * \details          メモリファイルのオブジェクトを生成して，指定したファイルをSDカードからこのメモリファイルに読み込む．エラーが発生する場合，\a p_memfile の \a buffer はNULLにクリアする.
 * \param  path      ファイルのパス
 * \param  p_memfile 生成したメモリファイルのオブジェクトを格納する場所へのポインタ
 * \retval E_OK      正常終了
 * \retval E_MACV    メモリアクセス違反（pathかp_memfile）
 * \retval E_NOMEM   メモリ不足
 * \retval E_PAR     パス名は無効
 * \retval E_SYS     I/Oエラーが発生した（SDカード不良の可能性が高い）
 */
    pub fn ev3_memfile_load(path: *const ::std::os::raw::c_char,
                            p_memfile: *mut memfile_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief            Free the resource (memory) allocated to a memory file.
  * \details         The \a buffer of \a p_memfile will be set to NULL on success.
 * \param  p_memfile Pointer of a memory file to release
 * \retval E_OK      Success
 * \retval E_PAR     The \a p_memfile is NULL. [TODO: check - inconsistent with Jp version -> E_MACV]
 * \retval E_OBJ     The \a p_memfile does not point to a valid memory file.
 *
 * \~Japanese
 * \brief            メモリファイルを解放する．
 * \details          メモリファイルにより確保されたリソース（メモリ領域）を解放する．正常終了の場合，\a p_memfile の \a buffer はNULLにクリアする．
 * \param  p_memfile 解放するメモリファイルのポインタ
 * \retval E_OK      正常終了
 * \retval E_MACV    メモリアクセス違反（p_memfile）
 * \retval E_OBJ     \a p_memfile で指定したメモリファイルは無効
 */
    pub fn ev3_memfile_free(p_memfile: *mut memfile_t) -> ER;
}
#[repr(u32)]
/**
 * \~English
 * \brief Numbers representing serial ports
 *
 * \~Japanese
 * \brief シリアルポートを表す番号
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum serial_port_t {
    EV3_SERIAL_DEFAULT = 0,
    EV3_SERIAL_UART = 1,
    EV3_SERIAL_BT = 2,
}
extern "C" {
    /**
 * \~English
 * \brief 	     Open the serial port as a file.
 * \details      In case of failure, NULL is returned (error log is output).
 * \param port   Serial port number
 * \returns      Serial port file
 *
 * \~Japanese
 * \brief 	     シリアルポートをファイルとしてオープンする．
 * \details      失敗の場合，NULLを返す（エラーログが出力される）．
 * \param port   シリアルポート番号
 * \returns      シリアルポートのファイル
 */
    pub fn ev3_serial_open_file(port: serial_port_t) -> *mut FILE;
}
extern "C" {
    /**
 * \~English
 * \brief            It is checked whether Bluetooth (Serial Port Profile) is connected.
 * \retval true      Connected. It can communicate with the Bluetooth virtual serial port.
 * \retval false     Unconnected.
 *
 * \~Japanese
 * \brief            Bluetooth (Serial Port Profile)が接続されているかどうかをチェックする．
 * \retval true      接続済み．Bluetooth仮想シリアルポートで通信できる．
 * \retval false     接続切れ．
 */
    pub fn ev3_bluetooth_is_connected() -> bool_t;
}
#[repr(u32)]
/**
 * \~English
 * \brief Enumeration type for font size
 *
 * \~Japanese
 * \brief フォントを表す番号
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcdfont_t { EV3_FONT_SMALL = 0, EV3_FONT_MEDIUM = 1, }
#[repr(u32)]
/**
 * \~English
 * \brief Enumeration type for LCD color
 *
 * \~Japanese
 * \brief LCDカラーを表す番号
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcdcolor_t { EV3_LCD_WHITE = 0, EV3_LCD_BLACK = 1, }
extern "C" {
    /**
 * \~English
 * \brief        Set the default font.
 * \param font   Font number
 * \retval E_OK  Successful completion
 * \retval E_ID  Invalid font number
 *
 * \~Japanese
 * \brief        デフォルトのフォントを設定する．
 * \param  font  フォントの番号
 * \retval E_OK  正常終了
 * \retval E_ID  不正ID番号
 */
    pub fn ev3_lcd_set_font(font: lcdfont_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief           Get font size.
 * \param  font     Font number
 * \param  p_width  Pointer to a place to store the acquired font width. If it is NULL, it is not stored.
 * \param  p_height Pointer to the place to store the height of the acquired font. If it is NULL, it is not stored.
 * \retval E_OK     Successful completion
 * \retval E_ID     Invalid fomt number
 *
 * \~Japanese
 * \brief           フォントのサイズを取得する．
 * \param  font     フォントの番号
 * \param  p_width  取得したフォントの幅を格納する場所へのポインタ．NULLの場合は格納しない．
 * \param  p_height 取得したフォントの高さを格納する場所へのポインタ．NULLの場合は格納しない．
 * \retval E_OK     正常終了
 * \retval E_ID     不正ID番号
 */
    pub fn ev3_font_get_size(font: lcdfont_t, p_width: *mut i32,
                             p_height: *mut i32) -> ER;
}
/**
 * \~English
 * \brief Structure of the image object.
 *
 * \~Japanese
 * \brief 画像のオブジェクトの構造体．
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct image_t {
    pub width: i32,
    pub height: i32,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_image_t() {
    assert_eq!(::std::mem::size_of::<image_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( image_t ) ));
    assert_eq! (::std::mem::align_of::<image_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( image_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const image_t ) ) . width as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( image_t ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const image_t ) ) . height as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( image_t ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const image_t ) ) . data as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( image_t ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for image_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * \~English
 * \brief            Load images from memory file.
 * \details          Create an image object from the specified memory file. Currently, it only supports monochrome image files in BMP format. If an error occurs , clear the data of \a p_image to NULL.
 * \param  p_memfile Object of memory file where image file is stored
 * \param  p_image   Pointer to the place to store the object of the generated image
 * \retval E_OK      Successful completion
 * \retval E_NOMEM   Insufficient memory
 * \retval E_NOSPT   Image file format is not supported
 * \retval E_OBJ     Image file is damaged
 * \retval E_PAR     Invalid memory file
 *
 * \~Japanese
 * \brief            メモリファイルから画像をロードする．
 * \details          指定したメモリファイルから画像のオブジェクトを生成する．現時点では，BMP形式のモノクロ画像ファイルしかサポートしない．
 *                   エラーが発生する場合，\a p_image の \a data はNULLにクリアする.
 * \param  p_memfile 画像ファイルが格納されるメモリファイルのオブジェクト
 * \param  p_image   生成した画像のオブジェクトを格納する場所へのポインタ
 * \retval E_OK      正常終了
 * \retval E_NOMEM   メモリ不足
 * \retval E_NOSPT   画像ファイルの形式は未対応
 * \retval E_OBJ     画像ファイルは破損
 * \retval E_PAR     メモリファイルは無効
 */
    pub fn ev3_image_load(p_memfile: *const memfile_t, p_image: *mut image_t)
     -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief            Release the image object.
 * \details          Free resources (memory area) secured by the object of the image. In case of normal \a termination , data of \a p_image is cleared to NULL.
 * \param  p_image   Pointer to released object
 * \retval E_OK      Successful completion
 * \retval E_PAR     \a p_image is NULL
 *
 * \~Japanese
 * \brief            画像のオブジェクトを解放する．
 * \details          画像のオブジェクトにより確保されたリソース（メモリ領域）を解放する．正常終了の場合，\a p_image の \a data はNULLにクリアする．
 * \param  p_image   解放する画像のオブジェクトのポインタ
 * \retval E_OK      正常終了
 * \retval E_PAR     \a p_image はNULL
 */
    pub fn ev3_image_free(p_image: *mut image_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief             Draws a character string at the specified position.
 * \param  x          Horizontal position of upper left corner
 * \param  y          Vertical position of upper left corner
 * \param  str        String (pointer to array of characters)
 * \retval E_OK       Successful completion
 *
 * \~Japanese
 * \brief             指定位置で文字列を描く．
 * \param  x          左上隅の水平方向の位置
 * \param  y          左上隅の垂直方向の位置
 * \param  str        文字列
 * \retval E_OK       正常終了
 */
    pub fn ev3_lcd_draw_string(str: *const ::std::os::raw::c_char, x: i32,
                               y: i32) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief             Draw a line at specified coordinates.
 * \param  x0         Horizontal position of start point
 * \param  y0         Vertical position of start point
 * \param  x1         Horizontal position of the end point
 * \param  y1         Vertical position of the end point
 * \retval E_OK       Successful completion
 *
 * \~Japanese
 * \brief             指定座標で線を引く．
 * \param  x0         始点の水平方向の位置
 * \param  y0         始点の垂直方向の位置
 * \param  x1         終点の水平方向の位置
 * \param  y1         終点の垂直方向の位置
 * \retval E_OK       正常終了
 */
    pub fn ev3_lcd_draw_line(x0: i32, y0: i32, x1: i32, y1: i32) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief            Draw a rectangle
 * \param  x         Horizontal position of upper left corner
 * \param  y         Vertical position of upper left corner
 * \param  w         Width of the rectangle
 * \param  h         Height of the rectangle
 * \param  color     Color [TODO: color of filling?]
 * \retval E_OK      Successful completion
 *
 * \~Japanese
 * \brief            矩形を描いて色を塗る．
 * \param  x         左上隅の水平方向の位置
 * \param  y         左上隅の垂直方向の位置
 * \param  w         矩形の幅
 * \param  h         矩形の高さ
 * \param  color     カラー
 * \retval E_OK      正常終了
 */
    pub fn ev3_lcd_fill_rect(x: i32, y: i32, w: i32, h: i32,
                             color: lcdcolor_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief            Display the image at specified coordinates.
 * \param  p_image   Image object
 * \param  x         Horizontal position of upper left corner
 * \param  y         Vertical position of upper left corner
 * \retval E_OK      Successful completion
 * \retval E_PAR     Image object invalid
 *
 * \~Japanese
 * \brief            指定座標で画像を表示する．
 * \param  p_image   画像のオブジェクト
 * \param  x         左上隅の水平方向の位置
 * \param  y         左上隅の垂直方向の位置
 * \retval E_OK      正常終了
 * \retval E_PAR     画像のオブジェクトは無効
 */
    pub fn ev3_lcd_draw_image(p_image: *const image_t, x: i32, y: i32) -> ER;
}
#[repr(u32)]
/**
 * \~English
 * \brief Enumeration type for supported LED colors
 *
 * \~Japanese
 * \brief 設定できるLEDカラーの列挙型
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ledcolor_t {
    LED_OFF = 0,
    LED_RED = 1,
    LED_GREEN = 2,
    LED_ORANGE = 3,
}
extern "C" {
    /**
 * \~English
 * \brief 		 Control the color of LED lights.
 * \details      When specifying an incorrect setting value, do not change the color of the LED light.
 * \param color  The color to set
 * \retval E_OK  Successful completion
 * \retval E_PAR Incorrect setting value
 *
 * \~Japanese
 * \brief 		 LEDライトのカラーを設定する
 * \details      不正の設定値を指定した場合，LEDライトのカラーを変えない．
 * \param  color LEDカラーの設定値
 * \retval E_OK  正常終了
 * \retval E_PAR 不正の設定値
 */
    pub fn ev3_led_set_color(color: ledcolor_t) -> ER;
}
#[repr(u32)]
/**
 * \~English
 * \brief ID for supported motor ports
 *
 * \~Japanese
 * \brief モータポートを表す番号
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum motor_port_t {
    EV3_PORT_A = 0,
    EV3_PORT_B = 1,
    EV3_PORT_C = 2,
    EV3_PORT_D = 3,
    TNUM_MOTOR_PORT = 4,
}
#[repr(u32)]
/**
 * \~English
 * \brief Enumeration type for supported motor types
 *
 * \~Japanese
 * \brief サポートするモータタイプ
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum motor_type_t {
    NONE_MOTOR = 0,
    MEDIUM_MOTOR = 1,
    LARGE_MOTOR = 2,
    UNREGULATED_MOTOR = 3,
    TNUM_MOTOR_TYPE = 4,
}
extern "C" {
    /**
 * \~English
 * \brief 	   Configure a motor port.
 * \details	   Set the type of motor connected to the motor port. You can also specify a new motor type even if you have already set it.
 * \param port Motor port to be configured
 * \param type Motor type for the specified motor port
 * \retval E_OK  Successful completion
 * \retval E_ID  Illegal motor port number
 * \retval E_PAR Illegal motor type
 *
 * \~Japanese
 * \brief 	     モータポートを設定する．
 * \details      モータポートに接続しているモータのタイプを設定する．既に設定した場合も新しいモータタイプを指定できる．
 * \param  port  モータポート番号
 * \param  type  モータタイプ
 * \retval E_OK  正常終了
 * \retval E_ID  不正のモータポート番号
 * \retval E_PAR 不正のモータタイプ
 */
    pub fn ev3_motor_config(port: motor_port_t, type_: motor_type_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief 	    Get the type of a motor port.
 * \param port  Motor port to be inquired
 * \retval >=0  Motor type of specified motor port
 * \retval E_ID Illegal motor port number
 *
 * \~Japanese
 * \brief 	    モータポートのモータタイプを取得する．
 * \param  port モータポート番号
 * \retval >=0  指定したモータポートのモータタイプ
 * \retval E_ID 不正のモータポート番号
 */
    pub fn ev3_motor_get_type(port: motor_port_t) -> ER_UINT;
}
extern "C" {
    /**
 * \~English
 * \brief 	   Get the angular position of a motor port.
 * \details    When an incorrect motor port number is specified, it always returns 0.
 * \param port Motor port to be inquired
 * \return     Angular position in degrees. A negative value means the motor rotate has rotated backwards. [TODO: number of degrees per one revolution of motor]

 *
 * \~Japanese
 * \brief 	   モータの角位置を取得する．
 * \details    不正のモータポート番号を指定した場合，常に0を返す（エラーログが出力される）．
 * \param port モータポート番号
 * \return     モータの角位置（単位は度），マイナスの値は逆方向に回転されたことを指す
 */
    pub fn ev3_motor_get_counts(port: motor_port_t) -> i32;
}
extern "C" {
    /**
 * \~English
 * \brief 	   Reset the angular position of the motor to zero
 * \details    Setting the value of the angular position sensor of the motor does not affect the actual power and position of the motor.
 * \param port Motor port to be inquired
 * \retval E_OK   Successful completion
 * \retval E_ID   Illegal motor port number
 * \retval E_OBJ  Motor port has not been initialized.
 *
 * \~Japanese
 * \brief 	      モータの角位置をゼロにリセットする．
 * \details       モータの角位置センサの値を設定するだけ，モータの実際のパワーと位置に影響を与えない．
 * \param  port   モータポート番号
 * \retval E_OK   正常終了
 * \retval E_ID   不正のモータポート番号
 * \retval E_OBJ  モータ未接続
 */
    pub fn ev3_motor_reset_counts(port: motor_port_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief 	    Set the unregulated power for a motor port.
 * \param port  Motor port to be set
 * \param power The percentage of full power, ranging from -100 to +100. A negative value makes the motor rotate backwards.
 * \retval E_OK     Successful completion
 * \retval E_ID     Illegal motor port number
 * \retval E_OBJ    Motor port has not been initialized.
 *
 * \~Japanese
 * \brief 	     モータのパワーを設定する
 * \param  port  モータポート番号
 * \param  power モータのフルパワーのパーセント値．範囲：-100から+100．マイナスの値でモータを逆方向に回転させることができる．
 * \retval E_OK  正常終了
 * \retval E_ID  不正のモータポート番号
 * \retval E_OBJ モータ未接続
 */
    pub fn ev3_motor_set_power(port: motor_port_t,
                               power: ::std::os::raw::c_int) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief 	    Get the actual power of a motor port.
 * \details     When an incorrect motor port number is specified, it always returns 0.
 * \param port  Motor port to be set
 * \return      Motor power [TODO: range?]
 *
 * \~Japanese
 * \brief 	   モータのパワーを取得する
 * \details    不正のモータポート番号を指定した場合，常に0を返す（エラーログが出力される）．
 * \param port モータポート番号
 * \return     モータのパワー
 */
    pub fn ev3_motor_get_power(port: motor_port_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \~English
 * \brief 	    Stop a motor port.
 * \param port  Motor port to be stopped
 * \param brake Brake mode, \a true for braking, \a false for coasting.
 * \retval E_OK     Successful completion
 * \retval E_ID     Illegal motor port number
 * \retval E_OBJ    Motor port has not been initialized.
 *
 * \~Japanese
 * \brief 	     モータを停止する
 * \param  port  モータポート番号
 * \param  brake ブレーキモードの指定，\a true （ブレーキモード）, \a false （フロートモード）
 * \retval E_OK  正常終了
 * \retval E_ID  不正のモータポート番号
 * \retval E_OBJ モータ未接続
 */
    pub fn ev3_motor_stop(port: motor_port_t, brake: bool_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief 	        Rotate a motor port for specified degrees.
 * \param port      Motor port to be rotated
 * \param degrees   Degrees to be rotated. A negative value makes the motor rotate backwards.
 * \param speed_abs Speed for rotating. The value is a percentage of full speed, ranging from 0 to +100.
 * \param blocking  \a true (The function will be blocked until the rotation is finished), or \a false (The function will not be blocked).
 * \retval E_OK     Successful completion
 * \retval E_ID     Illegal motor port number
 * \retval E_OBJ    Motor port has not been initialized.
 *
 * \~Japanese
 * \brief 	         モータを指定した角度だけ回転させる
 * \param  port      モータポート番号
 * \param  degrees   回転角度，マイナスの値でモータを逆方向に回転させることができる
 * \param  speed_abs 回転速度，モータポートのフルスピードのパーセント値．範囲：0から+100．
 * \param  blocking  \a true (関数は回転が完了してからリターン)，\a false (関数は回転操作を待たずにリターン)
 * \retval E_OK      正常終了
 * \retval E_ID      不正のモータポート番号
 * \retval E_OBJ     モータ未接続
 */
    pub fn ev3_motor_rotate(port: motor_port_t,
                            degrees: ::std::os::raw::c_int, speed_abs: u32,
                            blocking: bool_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief              Move the robot along a curved path using two motors.
 * \param  left_motor  ID of the left motor port
 * \param  right_motor ID of the right motor port
 * \param  power       Power of motors. Range: -100 to +100. A negative value moves the robot backwards.
 * \param  turn_ratio  The sharpness of the turn. Range: -100 to +100. If \a turn_ratio is negative, the robot will turn left.
 *                     If \a turn_ratio is positive, the robot will turn right. More specifically, \a turn_ratio determines the ratio of
 *                     inner wheel speed as a percent. For example, if \a turn_ratio is +25, the right motor will move at 75% of the \a power,
 *                     which makes the robot turn right.
 * \retval E_OK        Success
 * \retval E_ID        Invalid ID of motor port
 * \retval E_OBJ       Motor port has not been initialized.
 *
 * \~Japanese
 * \brief              ２つのモータでロボットのステアリング操作を行う．
 * \param  left_motor  左モータのモータポート番号
 * \param  right_motor 右モータのモータポート番号
 * \param  power       モータのパワー．範囲：-100から+100．マイナスの値は後退．
 * \param  turn_ratio  ステアリングの度合い．範囲：-100から+100．マイナスの値は左への転回，プラスの値は右への転回になる．
 *                     具体的に言えば，このパラメータはこの左右モータのパワーの差の度合いである．例えば，\a turn_ratio は+25である場合，
 *                     左モータのパワーは\a power で，右モータのパワーは\a power の75\%になり，ロボットは右へ転回する．
 * \retval E_OK        正常終了
 * \retval E_ID        不正のモータID
 * \retval E_OBJ       モータ未接続
 */
    pub fn ev3_motor_steer(left_motor: motor_port_t,
                           right_motor: motor_port_t,
                           power: ::std::os::raw::c_int,
                           turn_ratio: ::std::os::raw::c_int) -> ER;
}
#[repr(u32)]
/**
 * \~English
 * \brief Enumeration type for supported sensor ports
 *
 * \~Japanese
 * \brief センサポートを表す番号
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sensor_port_t {
    EV3_PORT_1 = 0,
    EV3_PORT_2 = 1,
    EV3_PORT_3 = 2,
    EV3_PORT_4 = 3,
    TNUM_SENSOR_PORT = 4,
}
#[repr(u32)]
/**
 * \~English
 * \brief Enumeration type for supported sensor types
 *
 * \~Japanese
 * \brief サポートするセンサタイプ
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sensor_type_t {
    NONE_SENSOR = 0,
    ULTRASONIC_SENSOR = 1,
    GYRO_SENSOR = 2,
    TOUCH_SENSOR = 3,
    COLOR_SENSOR = 4,
    INFRARED_SENSOR = 5,
    HT_NXT_ACCEL_SENSOR = 6,
    HT_NXT_COLOR_SENSOR = 7,
    NXT_TEMP_SENSOR = 8,
    TNUM_SENSOR_TYPE = 9,
}
#[repr(u32)]
/**
 * \~English
 * \brief Enumeration type for colors that can be detected by color sensor
 *
 * \~Japanese
 * \brief カラーセンサで識別できるカラーの番号
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum colorid_t {
    COLOR_NONE = 0,
    COLOR_BLACK = 1,
    COLOR_BLUE = 2,
    COLOR_GREEN = 3,
    COLOR_YELLOW = 4,
    COLOR_RED = 5,
    COLOR_WHITE = 6,
    COLOR_BROWN = 7,
    TNUM_COLOR = 8,
}
/**
 * \~English
 * \brief Structure for an RGB raw value
 *
 * \~Japanese
 * \brief RGB Raw値を格納する構造体
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rgb_raw_t {
    //< \~English Red value   \~Japanese 赤
    pub r: u16,
    //< \~English Green value \~Japanese 緑
    pub g: u16,
    //< \~English Blue value  \~Japanese 青
    pub b: u16,
}
#[test]
fn bindgen_test_layout_rgb_raw_t() {
    assert_eq!(::std::mem::size_of::<rgb_raw_t>() , 6usize , concat ! (
               "Size of: " , stringify ! ( rgb_raw_t ) ));
    assert_eq! (::std::mem::align_of::<rgb_raw_t>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( rgb_raw_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rgb_raw_t ) ) . r as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rgb_raw_t ) , "::" ,
                stringify ! ( r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rgb_raw_t ) ) . g as * const _ as usize }
                , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rgb_raw_t ) , "::" ,
                stringify ! ( g ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rgb_raw_t ) ) . b as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rgb_raw_t ) , "::" ,
                stringify ! ( b ) ));
}
impl Clone for rgb_raw_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * \~English
 * \brief 	     Configure a sensor port.
 * \details      Always returns 0  when an invalid sensor number is specified.
 * \param port   Sensor port to be configured
 * \param type   Sensor type for the specified sensor port
 * \retval E_OK  Successful completion
 * \retval E_ID  Illegal sensor port number
 * \retval E_PAR Illegal sensor type
 *
 * \~Japanese
 * \brief 	     センサポートを設定する．
 * \details      センサポートに接続しているセンサのタイプを設定する．既に設定した場合も新しいセンサタイプを指定できる．
 * \param  port  センサポート番号
 * \param  type  センサタイプ
 * \retval E_OK  正常終了
 * \retval E_ID  不正のセンサポート番号
 * \retval E_PAR 不正のセンサタイプ
 */
    pub fn ev3_sensor_config(port: sensor_port_t, type_: sensor_type_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief 	    Get the type of a sensor port.
 * \param port  Sensor port to be inquired
 * \retval >=0  Specified sensor type of supported sensor
 * \retval E_ID Incorrect sensor port number
 *
 * \~Japanese
 * \brief 	    センサポートのセンサタイプを取得する．
 * \param  port センサポート番号
 * \retval >=0  指定したセンサポートのセンサタイプ
 * \retval E_ID 不正のセンサポート番号
 */
    pub fn ev3_sensor_get_type(port: sensor_port_t) -> ER_UINT;
}
extern "C" {
    /**
 * \~English
 * \brief 	   Get the color by a color sensor.
 * \details    Always return COLOR_NONE (error  is outputted) when an incorrect sensor number is specified.
 * \param port Sensor port to be inquired
 * \return     Color detected
 *
 * \~Japanese
 * \brief 	    カラーセンサでカラーを識別する．
 * \details     不正のセンサポート番号を指定した場合，常にCOLOR_NONEを返す（エラーログが出力される）．
 * \param  port センサポート番号
 * \return      識別したカラー
 */
    pub fn ev3_color_sensor_get_color(port: sensor_port_t) -> colorid_t;
}
extern "C" {
    /**
 * \~English
 * \brief 	   Get the reflect light intensity by a color sensor.
 * \details    Always returns 0 (error log is outputted) when an invalid sensor number is specified.
 * \param port Sensor port to be inquired
 * \return     Reflect light intensity, ranging from 0 to 100
 *
 * \~Japanese
 * \brief 	    カラーセンサで反射光の強さを測定する．
 * \details     不正のセンサポート番号を指定した場合，常に0を返す（エラーログが出力される）．
 * \param port  センサポート番号
 * \return      反射光の強さ（0〜100）
 */
    pub fn ev3_color_sensor_get_reflect(port: sensor_port_t) -> u8;
}
extern "C" {
    /**
 * \~English
 * \brief 	   Get the ambient light intensity by a color sensor.
 * \details    Always returns 0 (error log is outputted) when an invalid sensor number is specified.
 * \param port Sensor port to be inquired
 * \return     Ambient light intensity, ranging from 0 to 100
 *
 * \~Japanese
 * \brief 	    カラーセンサで環境光の強さを測定する．
 * \details     不正のセンサポート番号を指定した場合，常に0を返す（エラーログが出力される）．
 * \param port  センサポート番号
 * \return      環境光の強さ（0〜100）
 */
    pub fn ev3_color_sensor_get_ambient(port: sensor_port_t) -> u8;
}
extern "C" {
    /**
 * \~English
 * \brief 	   Get the RGB raw value by a color sensor.
 * \details    If an invalid sensor number is specified, val is not updated (error log is output).
 * \param port Sensor port to be inquired
 * \param val  Pointer for storing sensor value
 *
 * \~Japanese
 * \brief 	    カラーセンサでRGB Raw値を測定する．
 * \details     不正のセンサポート番号を指定した場合，valは更新しない（エラーログが出力される）．
 * \param port  センサポート番号
 * \param val   取得した値を格納する変数のポインタ
 */
    pub fn ev3_color_sensor_get_rgb_raw(port: sensor_port_t,
                                        val: *mut rgb_raw_t);
}
extern "C" {
    /**
 * \~English
 * \brief 	   Get the angular position by a gyroscope sensor.
 * \details    Always returns 0 (error log is outputted) when an invalid sensor number is specified.
 * \param port Sensor port to be inquired
 * \return     Angular position in degrees
 *
 * \~Japanese
 * \brief 	    ジャイロセンサで角位置を測定する．
 * \details     不正のセンサポート番号を指定した場合，常に0を返す（エラーログが出力される）．
 * \param port  センサポート番号
 * \return      角位置（単位は度）
 */
    pub fn ev3_gyro_sensor_get_angle(port: sensor_port_t) -> i16;
}
extern "C" {
    /**
 * \~English
 * \brief 	   Get the angular speed by a gyroscope sensor.
 * \details    Always returns 0 (error log is outputted) when an invalid sensor number is specified.
 * \param port Sensor port to be inquired
 * \return     Angular speed in degrees/second.
 *
 * \~Japanese
 * \brief 	    ジャイロセンサで角速度を測定する
 * \details     不正のセンサポート番号を指定した場合，常に0を返す（エラーログが出力される）．
 * \param  port センサポート番号
 * \return      角位置（単位は度/秒）
 */
    pub fn ev3_gyro_sensor_get_rate(port: sensor_port_t) -> i16;
}
extern "C" {
    /**
 * \~English
 * \brief 	    Reset the angular position of a gyroscope sensor to zero.
 * \param port  Sensor port to be reset
 * \retval E_OK Successful completion
 * \retval E_ID Illegal sensor port number
 *
 * \~Japanese
 * \brief 	   ジャイロセンサの角位置をゼロにリセットする．
 * \param port センサポート番号
 * \retval E_OK 正常終了
 * \retval E_ID 不正のセンサポート番号
 */
    pub fn ev3_gyro_sensor_reset(port: sensor_port_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief 	   Get the distance by a ultrasonic sensor.
 * \details    Always returns 0 (error log is outputted) when an invalid sensor number is specified.
 * \param port Sensor port to be inquired
 * \return     Distance in centimeters.
 *
 * \~Japanese
 * \brief 	    超音波センサで距離を測定する．
 * \details     不正のセンサポート番号を指定した場合，常に0を返す（エラーログが出力される）．
 * \param  port センサポート番号
 * \return      距離（単位はセンチ）
 */
    pub fn ev3_ultrasonic_sensor_get_distance(port: sensor_port_t) -> i16;
}
extern "C" {
    /**
 * \~English
 * \brief 	     Get a ultrasonic signal by a ultrasonic sensor.
 * \details      When an invalid sensor support number is specified, always returns false (error log is output).
 * \param port   Sensor port to be inquired
 * \retval true  A signal has been received
 * \retval false No signal has been received
 *
 * \~Japanese
 * \brief 	     超音波センサで超音波信号を検出する．
 * \details      不正のセンサポート番号を指定した場合，常に \a false を返す（エラーログが出力される）．
 * \param  port  センサポート番号
 * \retval true  超音波信号を検出した
 * \retval false 超音波信号を検出しなかった
 */
    pub fn ev3_ultrasonic_sensor_listen(port: sensor_port_t) -> bool_t;
}
/**
 * \~English
 * \brief Structure for IR Seek values for all 4 channels
 *
 * \~Japanese
 * \brief IRビーコンの方位と距離を格納する構造体
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ir_seek_t {
    //< \~English Heading  for channels 1-4 (-25 to 25)           \~Japanese 全て（４つ）のチャンネルの方位（-25～25）
    pub heading: [i8; 4usize],
    //< \~English Distance for channels 1-4 (-128 and 0 to 100)   \~Japanese 全て（４つ）のチャンネルの距離（0〜100または-128）
    pub distance: [i8; 4usize],
}
#[test]
fn bindgen_test_layout_ir_seek_t() {
    assert_eq!(::std::mem::size_of::<ir_seek_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( ir_seek_t ) ));
    assert_eq! (::std::mem::align_of::<ir_seek_t>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ir_seek_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ir_seek_t ) ) . heading as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ir_seek_t ) , "::" ,
                stringify ! ( heading ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ir_seek_t ) ) . distance as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ir_seek_t ) , "::" ,
                stringify ! ( distance ) ));
}
impl Clone for ir_seek_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ir_remote_t {
    //< \~English IR Remote controller data for channels 1-4   \~Japanese 全て（４つ）のチャンネルのボタン入力のパタン
    pub channel: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_ir_remote_t() {
    assert_eq!(::std::mem::size_of::<ir_remote_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( ir_remote_t ) ));
    assert_eq! (::std::mem::align_of::<ir_remote_t>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ir_remote_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ir_remote_t ) ) . channel as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ir_remote_t ) , "::" ,
                stringify ! ( channel ) ));
}
impl Clone for ir_remote_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * \~English
 * \brief      Get the distance using the infrared sensor.
 * \details    Always returns 0 (error log is outputted) when an invalid sensor number is specified.
 * \param port Sensor port to be inquired.
 * \return     Distance in percentage (0-100).
 *
 * \~Japanese
 * \brief      IRセンサで距離を測定する．
 * \details    不正のセンサポート番号を指定した場合，常に0を返す（エラーログが出力される）．
 * \param port センサポート番号
 * \return     距離（単位はパーセント）
 */
    pub fn ev3_infrared_sensor_get_distance(port: sensor_port_t) -> i8;
}
extern "C" {
    /**
 * \~English
 * \brief      Gets values to seek a remote controller in beacon mode.
 * \details    When an invalid sensor support number is specified, always return 0 direction and distance of -128 (error log is output).
 * \param port Sensor port to be inquired.
 * \return     Struct with heading/distance for all (4) channels.
 *
 * \~Japanese
 * \brief      IRセンサでIRビーコンの方位と距離を測定する．
 * \details    不正のセンサポート番号を指定した場合，常に0の方位と-128の距離を返す（エラーログが出力される）．
 * \param port センサポート番号
 * \return     全て（４つ）のチャンネルの方位と距離
 */
    pub fn ev3_infrared_sensor_seek(port: sensor_port_t) -> ir_seek_t;
}
extern "C" {
    /**
 * \~English
 * \brief      Gets commands from IR remote controllers.
 * \details    When an invalid sensor support number is specified, always return 0 pattern (error log is output).
 * \param port Sensor port to be inquired.
 * \return     Struct with details of the IR remote buttons pressed.
 *
 * \~Japanese
 * \brief      IRセンサでIRビーコンのボタン入力を検出する．
 * \details    不正のセンサポート番号を指定した場合，常に0のパタンを返す（エラーログが出力される）．
 * \param port センサポート番号
 * \return     全て（４つ）のチャンネルのボタン入力のパタン
 */
    pub fn ev3_infrared_sensor_get_remote(port: sensor_port_t) -> ir_remote_t;
}
extern "C" {
    /**
 * \~English
 * \brief 	     Get the status of a touch sensor.
 * \details      When an invalid sensor support number is specified, always returns false (error log is output)
 * \param port   Sensor port to be inquired
 * \retval true  Pressed  pressed
 * \retval false Unpressed pressed
 *
 * \~Japanese
 * \brief 	     タッチセンサの状態を検出する．
 * \details      不正のセンサポート番号を指定した場合，常に \a false を返す（エラーログが出力される）．
 * \param port   センサポート番号
 * \retval true  押されている状態
 * \retval false 押されていない状態
 */
    pub fn ev3_touch_sensor_is_pressed(port: sensor_port_t) -> bool_t;
}
extern "C" {
    /**
 * \~English
 * \brief 	     Measure acceleration with a HiTechnic NXT acceleration sensor.
 * \details      When an invalid sensor support number is specified, always returns false (error log is output)
 * \param port   Sensor port to be inquired
 * \param axes   Array to store the x/y/z axes data
 * \retval true  Axes [] is  updated
 * \retval false Axes[] is unchanged due to I2C busy
 *
 * \~Japanese
 * \brief 	     加速度センサ（HiTechnic社製）で加速度を測定する．
 * \details      不正のセンサポート番号を指定した場合，常に \a false を返す（エラーログが出力される）．
 * \param  port  センサポート番号
 * \param  axes  x軸、y軸、z軸の3方向の加速度を格納するための配列
 * \retval true  axes[]は更新された
 * \retval false axes[]は変更されなかった（前回のI2C操作が完成していない）
 */
    pub fn ht_nxt_accel_sensor_measure(port: sensor_port_t, axes: *mut i16)
     -> bool_t;
}
extern "C" {
    /**
 * \~English
 * \brief        Measure color with a HiTechnic NXT color sensor (NCO1038).
 * \details      When an invalid sensor support number is specified, always returns false (error log is output)
 * \param port   Sensor port to be inquired
 * \param color  Pointer to store color number (0-17)
 * \retval true  color is updated
 * \retval false color is unchanged due to I2C busy
 *
 * \~Japanese
 * \brief        カラーセンサ（HiTechnic社製）でカラーを測定する．
 * \details      不正のセンサポート番号を指定した場合，常に \a false を返す（エラーログが出力される）．
 * \param  port  センサポート番号
 * \param  color カラーの番号（0-17）を格納するためのポインタ
 * \retval true  colorは更新された
 * \retval false colorは変更されなかった（前回のI2C操作が完成していない）
 */
    pub fn ht_nxt_color_sensor_measure_color(port: sensor_port_t,
                                             color: *mut u8) -> bool_t;
}
extern "C" {
    /**
 * \~English
 * \brief        Measure RGB raw value with a HiTechnic NXT color sensor (NCO1038).
 * \details      When an invalid sensor support number is specified, always returns false (error log is output)
 * \param port   Sensor port to be inquired
 * \param val    Pointer to store RGB raw value
 * \retval true  val is updated
 * \retval false val is unchanged due to I2C busy
 *
 * \~Japanese
 * \brief        カラーセンサ（HiTechnic社製）でRGB Raw値を測定する．
 * \details      不正のセンサポート番号を指定した場合，常に \a false を返す（エラーログが出力される）．
 * \param  port  センサポート番号
 * \param  val   RGB Raw値を格納するためのポインタ
 * \retval true  valは更新された
 * \retval false valは変更されなかった（前回のI2C操作が完成していない）
 */
    pub fn ht_nxt_color_sensor_measure_rgb(port: sensor_port_t,
                                           val: *mut rgb_raw_t) -> bool_t;
}
extern "C" {
    /**
 * \~English
 * \brief 	     Measure temperature with a NXT temperature sensor (9749).
 * \details      When an invalid sensor support number is specified, always returns false (error log is output)
 * \param port   Sensor port to be inquired
 * \param temp   Variable to store the temperature value
 * \retval true  Temp is updated)
 * \retval false Temp is unchanged due to I2C busy
 *
 * \~Japanese
 * \brief 	     NXT温度センサ（9749）で温度を測定する．
 * \details      不正のセンサポート番号を指定した場合，常に \a false を返す（エラーログが出力される）．
 * \param  port  センサポート番号
 * \param  temp  温度データ（°C）を格納するための変数へのポインタ
 * \retval true  tempは更新された
 * \retval false tempは変更されなかった（前回のI2C操作が完成していない）
 */
    pub fn nxt_temp_sensor_measure(port: sensor_port_t, temp: *mut f32)
     -> bool_t;
}
extern "C" {
    /**
 * \~English
 * \brief          Set the volume level of speaker.
 * \param  volume  The percentage of max volume level. Range: 0 to +100. 0 means mute. If an out-of-range value is given, i.e. larger than 100,
 * 	               it will be clipped to 100, the maximum value.
 * \retval E_OK    Success
 * \retval E_CTX   Not called from task context.
 * \retval E_NORES Failed to acquire the sound device.
 *
 * \~Japanese
 * \brief          音量を調整する．
 * \param  volume  ボリュームの値．範囲：0から+100．0はミュート．+100を超えた値を指定すると，実際の値は+100になる．
 * \retval E_OK    正常終了
 * \retval E_CTX   非タスクコンテストから呼び出す
 * \retval E_NORES サウンドデバイスが占有されている
 */
    pub fn ev3_speaker_set_volume(volume: u8) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief           Play a tone. Any sound being played will be stopped by calling this function.
 * \param frequency Frequency of the note, in Hertz (Hz). Range: 250 - 10000. If a out-of-range value is given, it will be clipped to the minimum or maximum value.
 * \param duration  Duration to play, in milliseconds (ms). If a negative value is given, it will keep playing until stopped manually.
 * 				    If 0 is given, it will just stop the sound being played.
 * \retval E_OK     Success. The note is now being played.
 * \retval E_CTX    Not called from task context.
 * \retval E_NORES  Failed to acquire the sound device.
 *
 * \~Japanese
 * \brief           指定した周波数でトーン出力する．今再生しているサウンドは停止される．
 * \param frequency トーンの周波数
 * \param duration  出力持続時間．単位：ミリ秒．SOUND_MANUAL_STOPを指定した場合は手動で停止する．
 * \retval E_OK     正常終了
 * \retval E_CTX    非タスクコンテストから呼び出す
 * \retval E_NORES  サウンドデバイスが占有されている
 */
    pub fn ev3_speaker_play_tone(frequency: u16, duration: i32) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief            Play a WAV file stored in memory. Only 8-bit 8kHz mono WAV file is supported by now. Any sound being played will be stopped by calling this function.
 * \param  p_memfile Pointer of a memory file which holds the content of the WAV file to be played.
 * \param  duration  Duration to play, in milliseconds (ms). If SOUND_MANUAL_STOP is specified,it will keep playing until stopped manually or finished.
 * 			         If 0 is given, it will just stop the sound being played.
 * \retval E_OK      Success. The WAV file is now being played.
 * \retval E_CTX     Not called from task context.
 * \retval E_PAR     Not a valid or supported WAV file.
 * \retval E_NORES   Failed to acquire the sound device.
 *
 * \~Japanese
 * \brief            指定したWAVファイル（8-bit 8kHz mono）を再生する．今再生しているサウンドは停止される．
 * \param  p_memfile WAVファイルのメモリファイルへのポインタ
 * \param  duration  出力持続時間．単位：ミリ秒．SOUND_MANUAL_STOPを指定した場合は手動で停止しないと最後まで再生する．
 * \retval E_OK      正常終了
 * \retval E_CTX     非タスクコンテストから呼び出す
 * \retval E_NORES   サウンドデバイスが占有されている
 */
    pub fn ev3_speaker_play_file(p_memfile: *const memfile_t, duration: i32)
     -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief           The sound being played will be stopped by calling this function.
 * \retval E_OK     Success
 * \retval E_CTX    Not called from task context.
 * \retval E_NORES  Failed to acquire the sound device.
 *
 * \~Japanese
 * \brief            今再生しているサウンドを停止する．
 * \retval E_OK      正常終了
 * \retval E_CTX     非タスクコンテストから呼び出す
 * \retval E_NORES   サウンドデバイスが占有されている
 */
    pub fn ev3_speaker_stop() -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief            Start an EV3 cyclic handler.
 * \param  ev3cycid  ID number of cyclic handler for EV 3 (specified by EV3_CRE_CYC）
 * \retval E_OK      Successful completion
 * \retval E_CTX     Call from non-task context
 * \retval E_ID      Invalid ID number
 *
 * \~Japanese
 * \brief            EV3用周期ハンドラの動作を開始する．
 * \param  ev3cycid  EV3用周期ハンドラのID番号（EV3_CRE_CYCで指定）
 * \retval E_OK      正常終了
 * \retval E_CTX     非タスクコンテキストからの呼出し
 * \retval E_ID      不正ID番号
 */
    pub fn ev3_sta_cyc(ev3cycid: ID) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief            Stop an EV3 cyclic handler.
 * \param  ev3cycid  ID number of cyclic handler for EV 3 (specified by EV3_CRE_CYC）
 * \retval E_OK      Successful completion
 * \retval E_CTX     Call from non-task context
 * \retval E_ID      Invalid ID number
 *
 * \~Japanese
 * \brief            EV3用周期ハンドラの動作を停止する．
 * \param  ev3cycid  EV3用周期ハンドラのID番号（EV3_CRE_CYCで指定）
 * \retval E_OK      正常終了
 * \retval E_CTX     非タスクコンテキストからの呼出し
 * \retval E_ID      不正ID番号
 */
    pub fn ev3_stp_cyc(ev3cycid: ID) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief         Get the current of battery.
 * \returns       Battery current in mA
 *
 * \~Japanese
 * \brief         バッテリの電流を取得する．
 * \returns       バッテリの電流（mA）
 */
    pub fn ev3_battery_current_mA() -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \~English
 * \brief         Get the voltage of battery.
 * \returns       Battery voltage in mV
 *
 * \~Japanese
 * \brief         バッテリの電圧を取得する．
 * \returns       バッテリの電圧（mV）
 */
    pub fn ev3_battery_voltage_mV() -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Application initialize task
 */
    pub fn _app_init_task(unused: isize);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
