/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NO_LONG_LONG: ::std::os::raw::c_uint = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const __DARWIN_CLK_TCK: ::std::os::raw::c_uint = 100;
pub const CHAR_BIT: ::std::os::raw::c_uint = 8;
pub const MB_LEN_MAX: ::std::os::raw::c_uint = 6;
pub const CLK_TCK: ::std::os::raw::c_uint = 100;
pub const SCHAR_MAX: ::std::os::raw::c_uint = 127;
pub const SCHAR_MIN: ::std::os::raw::c_int = -128;
pub const UCHAR_MAX: ::std::os::raw::c_uint = 255;
pub const CHAR_MAX: ::std::os::raw::c_uint = 127;
pub const CHAR_MIN: ::std::os::raw::c_int = -128;
pub const USHRT_MAX: ::std::os::raw::c_uint = 65535;
pub const SHRT_MAX: ::std::os::raw::c_uint = 32767;
pub const SHRT_MIN: ::std::os::raw::c_int = -32768;
pub const UINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_MIN: ::std::os::raw::c_int = -2147483648;
pub const ULONG_MAX: ::std::os::raw::c_int = -1;
pub const LONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const LONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const ULLONG_MAX: ::std::os::raw::c_int = -1;
pub const LLONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const LLONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const LONG_BIT: ::std::os::raw::c_uint = 64;
pub const SSIZE_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const WORD_BIT: ::std::os::raw::c_uint = 32;
pub const SIZE_T_MAX: ::std::os::raw::c_int = -1;
pub const UQUAD_MAX: ::std::os::raw::c_int = -1;
pub const QUAD_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const QUAD_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const ARG_MAX: ::std::os::raw::c_uint = 262144;
pub const CHILD_MAX: ::std::os::raw::c_uint = 266;
pub const GID_MAX: ::std::os::raw::c_uint = 2147483647;
pub const LINK_MAX: ::std::os::raw::c_uint = 32767;
pub const MAX_CANON: ::std::os::raw::c_uint = 1024;
pub const MAX_INPUT: ::std::os::raw::c_uint = 1024;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 16;
pub const UID_MAX: ::std::os::raw::c_uint = 2147483647;
pub const OPEN_MAX: ::std::os::raw::c_uint = 10240;
pub const PATH_MAX: ::std::os::raw::c_uint = 1024;
pub const PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const EQUIV_CLASS_MAX: ::std::os::raw::c_uint = 2;
pub const EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const NZERO: ::std::os::raw::c_uint = 20;
pub const _POSIX_ARG_MAX: ::std::os::raw::c_uint = 4096;
pub const _POSIX_CHILD_MAX: ::std::os::raw::c_uint = 25;
pub const _POSIX_LINK_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MAX_CANON: ::std::os::raw::c_uint = 255;
pub const _POSIX_MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const _POSIX_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX_NGROUPS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_OPEN_MAX: ::std::os::raw::c_uint = 20;
pub const _POSIX_PATH_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const _POSIX_SSIZE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_STREAM_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _POSIX2_BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX2_EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX2_LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_AIO_MAX: ::std::os::raw::c_uint = 1;
pub const _POSIX_DELAYTIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_MQ_OPEN_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MQ_PRIO_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_RTSIG_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_SEM_VALUE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_SIGQUEUE_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_CLOCKRES_MIN: ::std::os::raw::c_uint = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const _POSIX_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 128;
pub const _POSIX_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const PTHREAD_KEYS_MAX: ::std::os::raw::c_uint = 512;
pub const PTHREAD_STACK_MIN: ::std::os::raw::c_uint = 8192;
pub const _POSIX_HOST_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_SS_REPL_MAX: ::std::os::raw::c_uint = 4;
pub const _POSIX_SYMLINK_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_SYMLOOP_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: ::std::os::raw::c_uint = 30;
pub const _POSIX_TRACE_NAME_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TRACE_SYS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TTY_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const OFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const OFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const PASS_MAX: ::std::os::raw::c_uint = 128;
pub const NL_ARGMAX: ::std::os::raw::c_uint = 9;
pub const NL_LANGMAX: ::std::os::raw::c_uint = 14;
pub const NL_MSGMAX: ::std::os::raw::c_uint = 32767;
pub const NL_NMAX: ::std::os::raw::c_uint = 1;
pub const NL_SETMAX: ::std::os::raw::c_uint = 255;
pub const NL_TEXTMAX: ::std::os::raw::c_uint = 2048;
pub const _XOPEN_IOV_MAX: ::std::os::raw::c_uint = 16;
pub const IOV_MAX: ::std::os::raw::c_uint = 1024;
pub const _XOPEN_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _XOPEN_PATH_MAX: ::std::os::raw::c_uint = 1024;
pub const true_: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const E_OK: ::std::os::raw::c_uint = 0;
pub const E_SYS: ::std::os::raw::c_int = -5;
pub const E_NOSPT: ::std::os::raw::c_int = -9;
pub const E_RSFN: ::std::os::raw::c_int = -10;
pub const E_RSATR: ::std::os::raw::c_int = -11;
pub const E_PAR: ::std::os::raw::c_int = -17;
pub const E_ID: ::std::os::raw::c_int = -18;
pub const E_CTX: ::std::os::raw::c_int = -25;
pub const E_MACV: ::std::os::raw::c_int = -26;
pub const E_OACV: ::std::os::raw::c_int = -27;
pub const E_ILUSE: ::std::os::raw::c_int = -28;
pub const E_NOMEM: ::std::os::raw::c_int = -33;
pub const E_NOID: ::std::os::raw::c_int = -34;
pub const E_NORES: ::std::os::raw::c_int = -35;
pub const E_OBJ: ::std::os::raw::c_int = -41;
pub const E_NOEXS: ::std::os::raw::c_int = -42;
pub const E_QOVR: ::std::os::raw::c_int = -43;
pub const E_RLWAI: ::std::os::raw::c_int = -49;
pub const E_TMOUT: ::std::os::raw::c_int = -50;
pub const E_DLT: ::std::os::raw::c_int = -51;
pub const E_CLS: ::std::os::raw::c_int = -52;
pub const E_WBLK: ::std::os::raw::c_int = -57;
pub const E_BOVR: ::std::os::raw::c_int = -58;
pub const TMO_POL: ::std::os::raw::c_uint = 0;
pub const TMO_FEVR: ::std::os::raw::c_int = -1;
pub const TMO_NBLK: ::std::os::raw::c_int = -2;
pub const TACP_KERNEL: ::std::os::raw::c_uint = 0;
pub const TACP_SHARED: ::std::os::raw::c_int = -1;
pub const SIO_RDY_SND: ::std::os::raw::c_uint = 1;
pub const SIO_RDY_RCV: ::std::os::raw::c_uint = 2;
pub const TNUM_PORT: ::std::os::raw::c_uint = 4;
pub const SIO_PORT_UART: ::std::os::raw::c_uint = 1;
pub const SIO_PORT_BT: ::std::os::raw::c_uint = 2;
pub const SIO_PORT_LCD: ::std::os::raw::c_uint = 3;
pub const SIO_PORT_SPP_MASTER_TEST: ::std::os::raw::c_uint = 4;
pub const SERIAL_RCV_BUFSZ2: ::std::os::raw::c_uint = 8192;
pub const SERIAL_SND_BUFSZ2: ::std::os::raw::c_uint = 8192;
pub const CORE_CLK_MHZ: ::std::os::raw::c_uint = 300;
pub const OSCIN_MHZ: ::std::os::raw::c_uint = 24;
pub const ARM_PAGE_TABLE_RATIO: ::std::os::raw::c_uint = 20;
pub const PERIOD_UART_SENSOR_CYC: ::std::os::raw::c_uint = 10000;
pub const STACK_SIZE: ::std::os::raw::c_uint = 4096;
pub const KERNEL_HEAP_SIZE: ::std::os::raw::c_uint = 1048576;
pub const APP_HEAP_SIZE: ::std::os::raw::c_uint = 1048576;
pub const BT_SND_BUF_SIZE: ::std::os::raw::c_uint = 2048;
pub const BT_HIGH_PRI_TIME_SLICE: ::std::os::raw::c_uint = 1;
pub const BT_LOW_PRI_TIME_SLICE: ::std::os::raw::c_uint = 19;
pub const BT_USE_EDMA_MODE: ::std::os::raw::c_uint = 1;
pub const TMAX_APP_TSK_NUM: ::std::os::raw::c_uint = 32;
pub const TMAX_APP_SEM_NUM: ::std::os::raw::c_uint = 16;
pub const TMAX_APP_FLG_NUM: ::std::os::raw::c_uint = 16;
pub const TMAX_APP_DTQ_NUM: ::std::os::raw::c_uint = 16;
pub const TMAX_APP_PDQ_NUM: ::std::os::raw::c_uint = 16;
pub const TMAX_APP_MTX_NUM: ::std::os::raw::c_uint = 16;
pub const TMAX_APP_TEXT_SIZE: ::std::os::raw::c_uint = 1048576;
pub const TMAX_APP_DATA_SIZE: ::std::os::raw::c_uint = 1048576;
pub const TMAX_APP_BINARY_SIZE: ::std::os::raw::c_uint = 1048576;
pub const LCD_FRAME_RATE: ::std::os::raw::c_uint = 25;
pub const FORCE_SHUTDOWN_TIMEOUT: ::std::os::raw::c_uint = 500;
pub const TMAX_EV3_CYC_NUM: ::std::os::raw::c_uint = 16;
pub const SUART1_INT: ::std::os::raw::c_uint = 3;
pub const SUART2_INT: ::std::os::raw::c_uint = 4;
pub const TCNT_SYSLOG_BUFFER: ::std::os::raw::c_uint = 1024;
pub const T64P0_TINT12: ::std::os::raw::c_uint = 21;
pub const T64P1_TINT12: ::std::os::raw::c_uint = 23;
pub const UART0_INT: ::std::os::raw::c_uint = 25;
pub const UART1_INT: ::std::os::raw::c_uint = 53;
pub const UART2_INT: ::std::os::raw::c_uint = 61;
pub const GPIO_B0INT: ::std::os::raw::c_uint = 42;
pub const GPIO_B1INT: ::std::os::raw::c_uint = 43;
pub const GPIO_B2INT: ::std::os::raw::c_uint = 44;
pub const GPIO_B3INT: ::std::os::raw::c_uint = 45;
pub const GPIO_B4INT: ::std::os::raw::c_uint = 46;
pub const GPIO_B5INT: ::std::os::raw::c_uint = 47;
pub const GPIO_B6INT: ::std::os::raw::c_uint = 48;
pub const GPIO_B7INT: ::std::os::raw::c_uint = 49;
pub const GPIO_B8INT: ::std::os::raw::c_uint = 50;
pub const TMIN_INTNO: ::std::os::raw::c_uint = 0;
pub const TMAX_INTNO: ::std::os::raw::c_uint = 100;
pub const TMIN_INTPRI: ::std::os::raw::c_int = -31;
pub const TMAX_INTPRI: ::std::os::raw::c_int = -1;
pub const TIC_NUME: ::std::os::raw::c_uint = 1;
pub const TIC_DENO: ::std::os::raw::c_uint = 10;
pub const GPIO_ED_PIN0: ::std::os::raw::c_uint = 1;
pub const GPIO_ED_PIN1: ::std::os::raw::c_uint = 2;
pub const GPIO_ED_PIN2: ::std::os::raw::c_uint = 4;
pub const GPIO_ED_PIN3: ::std::os::raw::c_uint = 8;
pub const GPIO_ED_PIN4: ::std::os::raw::c_uint = 16;
pub const GPIO_ED_PIN5: ::std::os::raw::c_uint = 32;
pub const GPIO_ED_PIN6: ::std::os::raw::c_uint = 64;
pub const GPIO_ED_PIN7: ::std::os::raw::c_uint = 128;
pub const GPIO_ED_PIN8: ::std::os::raw::c_uint = 256;
pub const GPIO_ED_PIN9: ::std::os::raw::c_uint = 512;
pub const GPIO_ED_PIN10: ::std::os::raw::c_uint = 1024;
pub const GPIO_ED_PIN11: ::std::os::raw::c_uint = 2048;
pub const GPIO_ED_PIN12: ::std::os::raw::c_uint = 4096;
pub const GPIO_ED_PIN13: ::std::os::raw::c_uint = 8192;
pub const GPIO_ED_PIN14: ::std::os::raw::c_uint = 16384;
pub const GPIO_ED_PIN15: ::std::os::raw::c_uint = 32768;
pub const GPIO_DE_PIN0: ::std::os::raw::c_uint = 65536;
pub const GPIO_DE_PIN1: ::std::os::raw::c_uint = 131072;
pub const GPIO_DE_PIN2: ::std::os::raw::c_uint = 262144;
pub const GPIO_DE_PIN3: ::std::os::raw::c_uint = 524288;
pub const GPIO_DE_PIN4: ::std::os::raw::c_uint = 1048576;
pub const GPIO_DE_PIN5: ::std::os::raw::c_uint = 2097152;
pub const GPIO_DE_PIN6: ::std::os::raw::c_uint = 4194304;
pub const GPIO_DE_PIN7: ::std::os::raw::c_uint = 8388608;
pub const GPIO_DE_PIN8: ::std::os::raw::c_uint = 16777216;
pub const GPIO_DE_PIN9: ::std::os::raw::c_uint = 33554432;
pub const GPIO_DE_PIN10: ::std::os::raw::c_uint = 67108864;
pub const GPIO_DE_PIN11: ::std::os::raw::c_uint = 134217728;
pub const GPIO_DE_PIN12: ::std::os::raw::c_uint = 268435456;
pub const GPIO_DE_PIN13: ::std::os::raw::c_uint = 536870912;
pub const GPIO_DE_PIN14: ::std::os::raw::c_uint = 1073741824;
pub const GPIO_DE_PIN15: ::std::os::raw::c_uint = 2147483648;
pub const PLL_DIV_EN: ::std::os::raw::c_uint = 32768;
pub const PLL_DIV_RATIO: ::std::os::raw::c_uint = 31;
pub const UART_LSR_RXFIFOE: ::std::os::raw::c_uint = 128;
pub const UART_LSR_TEMT: ::std::os::raw::c_uint = 64;
pub const UART_LSR_THRE: ::std::os::raw::c_uint = 32;
pub const UART_LSR_BI: ::std::os::raw::c_uint = 16;
pub const UART_LSR_FE: ::std::os::raw::c_uint = 8;
pub const UART_LSR_PE: ::std::os::raw::c_uint = 4;
pub const UART_LSR_OE: ::std::os::raw::c_uint = 2;
pub const UART_LSR_DR: ::std::os::raw::c_uint = 1;
pub const SPIFLG_TX: ::std::os::raw::c_uint = 512;
pub const SPIFLG_RX: ::std::os::raw::c_uint = 256;
pub const SPIFLG_OE: ::std::os::raw::c_uint = 64;
pub const SPIFLG_BE: ::std::os::raw::c_uint = 16;
pub const SPIFLG_DESYNC: ::std::os::raw::c_uint = 8;
pub const SPIFLG_PE: ::std::os::raw::c_uint = 4;
pub const SPIFLG_TOUT: ::std::os::raw::c_uint = 2;
pub const SPIFLG_DE: ::std::os::raw::c_uint = 1;
pub const SPIBUF_RXEMPTY: ::std::os::raw::c_uint = 2147483648;
pub const SPIBUF_RXOVR: ::std::os::raw::c_uint = 1073741824;
pub const SPIBUF_TXFULL: ::std::os::raw::c_uint = 536870912;
pub const SPIBUF_BITERR: ::std::os::raw::c_uint = 268435456;
pub const SPIBUF_DESYNC: ::std::os::raw::c_uint = 134217728;
pub const SPIBUF_PARERR: ::std::os::raw::c_uint = 67108864;
pub const SPIBUF_TIMEOUT: ::std::os::raw::c_uint = 33554432;
pub const SPIBUF_DLENERR: ::std::os::raw::c_uint = 16777216;
pub const SPIINT0_DMAREQEN: ::std::os::raw::c_uint = 65536;
pub const SPIINT0_TXINTENA: ::std::os::raw::c_uint = 512;
pub const SPIINT0_RXINTENA: ::std::os::raw::c_uint = 256;
pub const SPILVL_TXINTLVL: ::std::os::raw::c_uint = 512;
pub const SPILVL_RXINTLVL: ::std::os::raw::c_uint = 256;
pub const PLL0_SYSCLK2_HZ: ::std::os::raw::c_uint = 150000000;
pub const CP15_CONTROL_XP_BIT: ::std::os::raw::c_uint = 8388608;
pub const CP15_CONTROL_V_BIT: ::std::os::raw::c_uint = 8192;
pub const CP15_CONTROL_I_BIT: ::std::os::raw::c_uint = 4096;
pub const CP15_CONTROL_C_BIT: ::std::os::raw::c_uint = 4;
pub const CP15_CONTROL_M_BIT: ::std::os::raw::c_uint = 1;
pub const CP15_AUXILIARY_SA_BIT: ::std::os::raw::c_uint = 64;
pub const CP15_AUXILIARY_EX_BIT: ::std::os::raw::c_uint = 128;
pub const CP15_CPUID_BIT: ::std::os::raw::c_uint = 3;
pub const CP15_TTB0_RGN_S: ::std::os::raw::c_uint = 2;
pub const CP15_TTB0_RGN_WBWA: ::std::os::raw::c_uint = 8;
pub const TMIN_FNCD: ::std::os::raw::c_int = -241;
pub const TFN_ACT_TSK: ::std::os::raw::c_int = -5;
pub const TFN_IACT_TSK: ::std::os::raw::c_int = -6;
pub const TFN_CAN_ACT: ::std::os::raw::c_int = -7;
pub const TFN_EXT_TSK: ::std::os::raw::c_int = -8;
pub const TFN_TER_TSK: ::std::os::raw::c_int = -9;
pub const TFN_CHG_PRI: ::std::os::raw::c_int = -10;
pub const TFN_GET_PRI: ::std::os::raw::c_int = -11;
pub const TFN_GET_INF: ::std::os::raw::c_int = -12;
pub const TFN_SLP_TSK: ::std::os::raw::c_int = -13;
pub const TFN_TSLP_TSK: ::std::os::raw::c_int = -14;
pub const TFN_WUP_TSK: ::std::os::raw::c_int = -15;
pub const TFN_IWUP_TSK: ::std::os::raw::c_int = -16;
pub const TFN_CAN_WUP: ::std::os::raw::c_int = -17;
pub const TFN_REL_WAI: ::std::os::raw::c_int = -18;
pub const TFN_IREL_WAI: ::std::os::raw::c_int = -19;
pub const TFN_DIS_WAI: ::std::os::raw::c_int = -21;
pub const TFN_IDIS_WAI: ::std::os::raw::c_int = -22;
pub const TFN_ENA_WAI: ::std::os::raw::c_int = -23;
pub const TFN_IENA_WAI: ::std::os::raw::c_int = -24;
pub const TFN_SUS_TSK: ::std::os::raw::c_int = -25;
pub const TFN_RSM_TSK: ::std::os::raw::c_int = -26;
pub const TFN_DLY_TSK: ::std::os::raw::c_int = -27;
pub const TFN_RAS_TEX: ::std::os::raw::c_int = -29;
pub const TFN_IRAS_TEX: ::std::os::raw::c_int = -30;
pub const TFN_DIS_TEX: ::std::os::raw::c_int = -31;
pub const TFN_ENA_TEX: ::std::os::raw::c_int = -32;
pub const TFN_SNS_TEX: ::std::os::raw::c_int = -33;
pub const TFN_REF_TEX: ::std::os::raw::c_int = -34;
pub const TFN_SIG_SEM: ::std::os::raw::c_int = -37;
pub const TFN_ISIG_SEM: ::std::os::raw::c_int = -38;
pub const TFN_WAI_SEM: ::std::os::raw::c_int = -39;
pub const TFN_POL_SEM: ::std::os::raw::c_int = -40;
pub const TFN_TWAI_SEM: ::std::os::raw::c_int = -41;
pub const TFN_SET_FLG: ::std::os::raw::c_int = -45;
pub const TFN_ISET_FLG: ::std::os::raw::c_int = -46;
pub const TFN_CLR_FLG: ::std::os::raw::c_int = -47;
pub const TFN_WAI_FLG: ::std::os::raw::c_int = -48;
pub const TFN_POL_FLG: ::std::os::raw::c_int = -49;
pub const TFN_TWAI_FLG: ::std::os::raw::c_int = -50;
pub const TFN_SND_DTQ: ::std::os::raw::c_int = -53;
pub const TFN_PSND_DTQ: ::std::os::raw::c_int = -54;
pub const TFN_IPSND_DTQ: ::std::os::raw::c_int = -55;
pub const TFN_TSND_DTQ: ::std::os::raw::c_int = -56;
pub const TFN_FSND_DTQ: ::std::os::raw::c_int = -57;
pub const TFN_IFSND_DTQ: ::std::os::raw::c_int = -58;
pub const TFN_RCV_DTQ: ::std::os::raw::c_int = -59;
pub const TFN_PRCV_DTQ: ::std::os::raw::c_int = -60;
pub const TFN_TRCV_DTQ: ::std::os::raw::c_int = -61;
pub const TFN_SND_PDQ: ::std::os::raw::c_int = -65;
pub const TFN_PSND_PDQ: ::std::os::raw::c_int = -66;
pub const TFN_IPSND_PDQ: ::std::os::raw::c_int = -67;
pub const TFN_TSND_PDQ: ::std::os::raw::c_int = -68;
pub const TFN_RCV_PDQ: ::std::os::raw::c_int = -69;
pub const TFN_PRCV_PDQ: ::std::os::raw::c_int = -70;
pub const TFN_TRCV_PDQ: ::std::os::raw::c_int = -71;
pub const TFN_SND_MBX: ::std::os::raw::c_int = -73;
pub const TFN_RCV_MBX: ::std::os::raw::c_int = -74;
pub const TFN_PRCV_MBX: ::std::os::raw::c_int = -75;
pub const TFN_TRCV_MBX: ::std::os::raw::c_int = -76;
pub const TFN_LOC_MTX: ::std::os::raw::c_int = -77;
pub const TFN_PLOC_MTX: ::std::os::raw::c_int = -78;
pub const TFN_TLOC_MTX: ::std::os::raw::c_int = -79;
pub const TFN_UNL_MTX: ::std::os::raw::c_int = -80;
pub const TFN_SND_MBF: ::std::os::raw::c_int = -81;
pub const TFN_PSND_MBF: ::std::os::raw::c_int = -82;
pub const TFN_TSND_MBF: ::std::os::raw::c_int = -83;
pub const TFN_RCV_MBF: ::std::os::raw::c_int = -84;
pub const TFN_PRCV_MBF: ::std::os::raw::c_int = -85;
pub const TFN_TRCV_MBF: ::std::os::raw::c_int = -86;
pub const TFN_GET_MPF: ::std::os::raw::c_int = -89;
pub const TFN_PGET_MPF: ::std::os::raw::c_int = -90;
pub const TFN_TGET_MPF: ::std::os::raw::c_int = -91;
pub const TFN_REL_MPF: ::std::os::raw::c_int = -92;
pub const TFN_GET_TIM: ::std::os::raw::c_int = -93;
pub const TFN_GET_UTM: ::std::os::raw::c_int = -94;
pub const TFN_REF_OVR: ::std::os::raw::c_int = -96;
pub const TFN_STA_CYC: ::std::os::raw::c_int = -97;
pub const TFN_STP_CYC: ::std::os::raw::c_int = -98;
pub const TFN_STA_ALM: ::std::os::raw::c_int = -101;
pub const TFN_ISTA_ALM: ::std::os::raw::c_int = -102;
pub const TFN_STP_ALM: ::std::os::raw::c_int = -103;
pub const TFN_ISTP_ALM: ::std::os::raw::c_int = -104;
pub const TFN_STA_OVR: ::std::os::raw::c_int = -105;
pub const TFN_ISTA_OVR: ::std::os::raw::c_int = -106;
pub const TFN_STP_OVR: ::std::os::raw::c_int = -107;
pub const TFN_ISTP_OVR: ::std::os::raw::c_int = -108;
pub const TFN_SAC_SYS: ::std::os::raw::c_int = -109;
pub const TFN_REF_SYS: ::std::os::raw::c_int = -110;
pub const TFN_ROT_RDQ: ::std::os::raw::c_int = -111;
pub const TFN_IROT_RDQ: ::std::os::raw::c_int = -112;
pub const TFN_GET_DID: ::std::os::raw::c_int = -113;
pub const TFN_GET_TID: ::std::os::raw::c_int = -115;
pub const TFN_IGET_TID: ::std::os::raw::c_int = -116;
pub const TFN_LOC_CPU: ::std::os::raw::c_int = -117;
pub const TFN_ILOC_CPU: ::std::os::raw::c_int = -118;
pub const TFN_UNL_CPU: ::std::os::raw::c_int = -119;
pub const TFN_IUNL_CPU: ::std::os::raw::c_int = -120;
pub const TFN_DIS_DSP: ::std::os::raw::c_int = -121;
pub const TFN_ENA_DSP: ::std::os::raw::c_int = -122;
pub const TFN_SNS_CTX: ::std::os::raw::c_int = -123;
pub const TFN_SNS_LOC: ::std::os::raw::c_int = -124;
pub const TFN_SNS_DSP: ::std::os::raw::c_int = -125;
pub const TFN_SNS_DPN: ::std::os::raw::c_int = -126;
pub const TFN_SNS_KER: ::std::os::raw::c_int = -127;
pub const TFN_EXT_KER: ::std::os::raw::c_int = -128;
pub const TFN_ATT_MEM: ::std::os::raw::c_int = -129;
pub const TFN_DET_MEM: ::std::os::raw::c_int = -130;
pub const TFN_SAC_MEM: ::std::os::raw::c_int = -131;
pub const TFN_PRB_MEM: ::std::os::raw::c_int = -132;
pub const TFN_REF_MEM: ::std::os::raw::c_int = -133;
pub const TFN_ATT_PMA: ::std::os::raw::c_int = -135;
pub const TFN_CFG_INT: ::std::os::raw::c_int = -137;
pub const TFN_DIS_INT: ::std::os::raw::c_int = -138;
pub const TFN_ENA_INT: ::std::os::raw::c_int = -139;
pub const TFN_REF_INT: ::std::os::raw::c_int = -140;
pub const TFN_CHG_IPM: ::std::os::raw::c_int = -141;
pub const TFN_GET_IPM: ::std::os::raw::c_int = -142;
pub const TFN_XSNS_DPN: ::std::os::raw::c_int = -145;
pub const TFN_XSNS_XPN: ::std::os::raw::c_int = -146;
pub const TFN_REF_CFG: ::std::os::raw::c_int = -149;
pub const TFN_REF_VER: ::std::os::raw::c_int = -150;
pub const TFN_INI_SEM: ::std::os::raw::c_int = -162;
pub const TFN_INI_FLG: ::std::os::raw::c_int = -163;
pub const TFN_INI_DTQ: ::std::os::raw::c_int = -164;
pub const TFN_INI_PDQ: ::std::os::raw::c_int = -165;
pub const TFN_INI_MBX: ::std::os::raw::c_int = -166;
pub const TFN_INI_MTX: ::std::os::raw::c_int = -167;
pub const TFN_INI_MBF: ::std::os::raw::c_int = -168;
pub const TFN_INI_MPF: ::std::os::raw::c_int = -169;
pub const TFN_REF_TSK: ::std::os::raw::c_int = -177;
pub const TFN_REF_SEM: ::std::os::raw::c_int = -178;
pub const TFN_REF_FLG: ::std::os::raw::c_int = -179;
pub const TFN_REF_DTQ: ::std::os::raw::c_int = -180;
pub const TFN_REF_PDQ: ::std::os::raw::c_int = -181;
pub const TFN_REF_MBX: ::std::os::raw::c_int = -182;
pub const TFN_REF_MTX: ::std::os::raw::c_int = -183;
pub const TFN_REF_MBF: ::std::os::raw::c_int = -184;
pub const TFN_REF_MPF: ::std::os::raw::c_int = -185;
pub const TFN_REF_CYC: ::std::os::raw::c_int = -186;
pub const TFN_REF_ALM: ::std::os::raw::c_int = -187;
pub const TFN_REF_ISR: ::std::os::raw::c_int = -188;
pub const TFN_REF_SPN: ::std::os::raw::c_int = -189;
pub const TFN_ACRE_TSK: ::std::os::raw::c_int = -193;
pub const TFN_ACRE_SEM: ::std::os::raw::c_int = -194;
pub const TFN_ACRE_FLG: ::std::os::raw::c_int = -195;
pub const TFN_ACRE_DTQ: ::std::os::raw::c_int = -196;
pub const TFN_ACRE_PDQ: ::std::os::raw::c_int = -197;
pub const TFN_ACRE_MBX: ::std::os::raw::c_int = -198;
pub const TFN_ACRE_MTX: ::std::os::raw::c_int = -199;
pub const TFN_ACRE_MBF: ::std::os::raw::c_int = -200;
pub const TFN_ACRE_MPF: ::std::os::raw::c_int = -201;
pub const TFN_ACRE_CYC: ::std::os::raw::c_int = -202;
pub const TFN_ACRE_ALM: ::std::os::raw::c_int = -203;
pub const TFN_ACRE_ISR: ::std::os::raw::c_int = -204;
pub const TFN_ACRE_SPN: ::std::os::raw::c_int = -205;
pub const TFN_DEL_TSK: ::std::os::raw::c_int = -209;
pub const TFN_DEL_SEM: ::std::os::raw::c_int = -210;
pub const TFN_DEL_FLG: ::std::os::raw::c_int = -211;
pub const TFN_DEL_DTQ: ::std::os::raw::c_int = -212;
pub const TFN_DEL_PDQ: ::std::os::raw::c_int = -213;
pub const TFN_DEL_MBX: ::std::os::raw::c_int = -214;
pub const TFN_DEL_MTX: ::std::os::raw::c_int = -215;
pub const TFN_DEL_MBF: ::std::os::raw::c_int = -216;
pub const TFN_DEL_MPF: ::std::os::raw::c_int = -217;
pub const TFN_DEL_CYC: ::std::os::raw::c_int = -218;
pub const TFN_DEL_ALM: ::std::os::raw::c_int = -219;
pub const TFN_DEL_ISR: ::std::os::raw::c_int = -220;
pub const TFN_DEL_SPN: ::std::os::raw::c_int = -221;
pub const TFN_SAC_TSK: ::std::os::raw::c_int = -225;
pub const TFN_SAC_SEM: ::std::os::raw::c_int = -226;
pub const TFN_SAC_FLG: ::std::os::raw::c_int = -227;
pub const TFN_SAC_DTQ: ::std::os::raw::c_int = -228;
pub const TFN_SAC_PDQ: ::std::os::raw::c_int = -229;
pub const TFN_SAC_MTX: ::std::os::raw::c_int = -231;
pub const TFN_SAC_MBF: ::std::os::raw::c_int = -232;
pub const TFN_SAC_MPF: ::std::os::raw::c_int = -233;
pub const TFN_SAC_CYC: ::std::os::raw::c_int = -234;
pub const TFN_SAC_ALM: ::std::os::raw::c_int = -235;
pub const TFN_SAC_ISR: ::std::os::raw::c_int = -236;
pub const TFN_SAC_SPN: ::std::os::raw::c_int = -237;
pub const TFN_DEF_TEX: ::std::os::raw::c_int = -241;
pub const TFN_DEF_OVR: ::std::os::raw::c_int = -242;
pub const TFN_DEF_INH: ::std::os::raw::c_int = -243;
pub const TFN_DEF_EXC: ::std::os::raw::c_int = -244;
pub const TFN_DEF_SVC: ::std::os::raw::c_int = -245;
pub const TFN_MACT_TSK: ::std::os::raw::c_int = -257;
pub const TFN_IMACT_TSK: ::std::os::raw::c_int = -258;
pub const TFN_MIG_TSK: ::std::os::raw::c_int = -259;
pub const TFN_MSTA_CYC: ::std::os::raw::c_int = -261;
pub const TFN_MSTA_ALM: ::std::os::raw::c_int = -263;
pub const TFN_IMSTA_ALM: ::std::os::raw::c_int = -264;
pub const TFN_MROT_RDQ: ::std::os::raw::c_int = -265;
pub const TFN_IMROT_RDQ: ::std::os::raw::c_int = -266;
pub const TFN_GET_PID: ::std::os::raw::c_int = -267;
pub const TFN_IGET_PID: ::std::os::raw::c_int = -268;
pub const TFN_LOC_SPN: ::std::os::raw::c_int = -273;
pub const TFN_ILOC_SPN: ::std::os::raw::c_int = -274;
pub const TFN_TRY_SPN: ::std::os::raw::c_int = -275;
pub const TFN_ITRY_SPN: ::std::os::raw::c_int = -276;
pub const TFN_UNL_SPN: ::std::os::raw::c_int = -277;
pub const TFN_IUNL_SPN: ::std::os::raw::c_int = -278;
pub const SERVICE_CALL_NUM: ::std::os::raw::c_uint = 1;
pub const TDOM_SELF: ::std::os::raw::c_uint = 0;
pub const TDOM_KERNEL: ::std::os::raw::c_int = -1;
pub const TDOM_NONE: ::std::os::raw::c_int = -2;
pub const TSK_SELF: ::std::os::raw::c_uint = 0;
pub const TSK_NONE: ::std::os::raw::c_uint = 0;
pub const TPRI_SELF: ::std::os::raw::c_uint = 0;
pub const TPRI_INI: ::std::os::raw::c_uint = 0;
pub const TIPM_ENAALL: ::std::os::raw::c_uint = 0;
pub const TMIN_TPRI: ::std::os::raw::c_uint = 1;
pub const TMAX_TPRI: ::std::os::raw::c_uint = 16;
pub const TMIN_DPRI: ::std::os::raw::c_uint = 1;
pub const TMAX_DPRI: ::std::os::raw::c_uint = 16;
pub const TMIN_ISRPRI: ::std::os::raw::c_uint = 1;
pub const TMAX_ISRPRI: ::std::os::raw::c_uint = 16;
pub const TMAX_OVRTIM: ::std::os::raw::c_int = -1;
pub const TMAX_MAXSEM: ::std::os::raw::c_uint = 4294967295;
pub const TFN_SYSLOG_WRI_LOG: ::std::os::raw::c_uint = 1;
pub const TFN_SYSLOG_FWRI_LOG: ::std::os::raw::c_uint = 2;
pub const TFN_SYSLOG_REA_LOG: ::std::os::raw::c_uint = 3;
pub const TFN_SYSLOG_MSK_LOG: ::std::os::raw::c_uint = 4;
pub const TFN_SYSLOG_REF_LOG: ::std::os::raw::c_uint = 5;
pub const TFN_SERIAL_OPN_POR: ::std::os::raw::c_uint = 7;
pub const TFN_SERIAL_CLS_POR: ::std::os::raw::c_uint = 8;
pub const TFN_SERIAL_REA_DAT: ::std::os::raw::c_uint = 9;
pub const TFN_SERIAL_WRI_DAT: ::std::os::raw::c_uint = 10;
pub const TFN_SERIAL_CTL_POR: ::std::os::raw::c_uint = 11;
pub const TFN_SERIAL_REF_POR: ::std::os::raw::c_uint = 12;
pub const TFN_LOGTASK_FLUSH: ::std::os::raw::c_uint = 14;
pub const TFN_TEST_CHECK_POINT: ::std::os::raw::c_uint = 16;
pub const TFN_TEST_CHECK_ASSERT_ERROR: ::std::os::raw::c_uint = 17;
pub const TFN_TEST_CHECK_ERCD_ERROR: ::std::os::raw::c_uint = 18;
pub const TFN_TEST_SET_BIT_FUNC: ::std::os::raw::c_uint = 19;
pub const TFN_TEST_SYSLOG_FLUSH: ::std::os::raw::c_uint = 20;
pub const TFN_TEST_TEST_FINISH: ::std::os::raw::c_uint = 21;
pub const TMAX_LOGINFO: ::std::os::raw::c_uint = 6;
pub const __MAC_10_0: ::std::os::raw::c_uint = 1000;
pub const __MAC_10_1: ::std::os::raw::c_uint = 1010;
pub const __MAC_10_2: ::std::os::raw::c_uint = 1020;
pub const __MAC_10_3: ::std::os::raw::c_uint = 1030;
pub const __MAC_10_4: ::std::os::raw::c_uint = 1040;
pub const __MAC_10_5: ::std::os::raw::c_uint = 1050;
pub const __MAC_10_6: ::std::os::raw::c_uint = 1060;
pub const __MAC_10_7: ::std::os::raw::c_uint = 1070;
pub const __MAC_10_8: ::std::os::raw::c_uint = 1080;
pub const __MAC_10_9: ::std::os::raw::c_uint = 1090;
pub const __MAC_10_10: ::std::os::raw::c_uint = 101000;
pub const __MAC_10_10_2: ::std::os::raw::c_uint = 101002;
pub const __MAC_10_10_3: ::std::os::raw::c_uint = 101003;
pub const __MAC_10_11: ::std::os::raw::c_uint = 101100;
pub const __MAC_10_11_2: ::std::os::raw::c_uint = 101102;
pub const __MAC_10_11_3: ::std::os::raw::c_uint = 101103;
pub const __MAC_10_11_4: ::std::os::raw::c_uint = 101104;
pub const __MAC_10_12: ::std::os::raw::c_uint = 101200;
pub const __MAC_10_12_1: ::std::os::raw::c_uint = 101201;
pub const __MAC_10_12_2: ::std::os::raw::c_uint = 101202;
pub const __MAC_10_12_4: ::std::os::raw::c_uint = 101204;
pub const __MAC_10_13: ::std::os::raw::c_uint = 101300;
pub const __MAC_10_13_1: ::std::os::raw::c_uint = 101301;
pub const __MAC_10_13_2: ::std::os::raw::c_uint = 101302;
pub const __MAC_10_13_4: ::std::os::raw::c_uint = 101304;
pub const __IPHONE_2_0: ::std::os::raw::c_uint = 20000;
pub const __IPHONE_2_1: ::std::os::raw::c_uint = 20100;
pub const __IPHONE_2_2: ::std::os::raw::c_uint = 20200;
pub const __IPHONE_3_0: ::std::os::raw::c_uint = 30000;
pub const __IPHONE_3_1: ::std::os::raw::c_uint = 30100;
pub const __IPHONE_3_2: ::std::os::raw::c_uint = 30200;
pub const __IPHONE_4_0: ::std::os::raw::c_uint = 40000;
pub const __IPHONE_4_1: ::std::os::raw::c_uint = 40100;
pub const __IPHONE_4_2: ::std::os::raw::c_uint = 40200;
pub const __IPHONE_4_3: ::std::os::raw::c_uint = 40300;
pub const __IPHONE_5_0: ::std::os::raw::c_uint = 50000;
pub const __IPHONE_5_1: ::std::os::raw::c_uint = 50100;
pub const __IPHONE_6_0: ::std::os::raw::c_uint = 60000;
pub const __IPHONE_6_1: ::std::os::raw::c_uint = 60100;
pub const __IPHONE_7_0: ::std::os::raw::c_uint = 70000;
pub const __IPHONE_7_1: ::std::os::raw::c_uint = 70100;
pub const __IPHONE_8_0: ::std::os::raw::c_uint = 80000;
pub const __IPHONE_8_1: ::std::os::raw::c_uint = 80100;
pub const __IPHONE_8_2: ::std::os::raw::c_uint = 80200;
pub const __IPHONE_8_3: ::std::os::raw::c_uint = 80300;
pub const __IPHONE_8_4: ::std::os::raw::c_uint = 80400;
pub const __IPHONE_9_0: ::std::os::raw::c_uint = 90000;
pub const __IPHONE_9_1: ::std::os::raw::c_uint = 90100;
pub const __IPHONE_9_2: ::std::os::raw::c_uint = 90200;
pub const __IPHONE_9_3: ::std::os::raw::c_uint = 90300;
pub const __IPHONE_10_0: ::std::os::raw::c_uint = 100000;
pub const __IPHONE_10_1: ::std::os::raw::c_uint = 100100;
pub const __IPHONE_10_2: ::std::os::raw::c_uint = 100200;
pub const __IPHONE_10_3: ::std::os::raw::c_uint = 100300;
pub const __IPHONE_11_0: ::std::os::raw::c_uint = 110000;
pub const __IPHONE_11_1: ::std::os::raw::c_uint = 110100;
pub const __IPHONE_11_2: ::std::os::raw::c_uint = 110200;
pub const __IPHONE_11_3: ::std::os::raw::c_uint = 110300;
pub const __TVOS_9_0: ::std::os::raw::c_uint = 90000;
pub const __TVOS_9_1: ::std::os::raw::c_uint = 90100;
pub const __TVOS_9_2: ::std::os::raw::c_uint = 90200;
pub const __TVOS_10_0: ::std::os::raw::c_uint = 100000;
pub const __TVOS_10_0_1: ::std::os::raw::c_uint = 100001;
pub const __TVOS_10_1: ::std::os::raw::c_uint = 100100;
pub const __TVOS_10_2: ::std::os::raw::c_uint = 100200;
pub const __TVOS_11_0: ::std::os::raw::c_uint = 110000;
pub const __TVOS_11_1: ::std::os::raw::c_uint = 110100;
pub const __TVOS_11_2: ::std::os::raw::c_uint = 110200;
pub const __TVOS_11_3: ::std::os::raw::c_uint = 110300;
pub const __WATCHOS_1_0: ::std::os::raw::c_uint = 10000;
pub const __WATCHOS_2_0: ::std::os::raw::c_uint = 20000;
pub const __WATCHOS_2_1: ::std::os::raw::c_uint = 20100;
pub const __WATCHOS_2_2: ::std::os::raw::c_uint = 20200;
pub const __WATCHOS_3_0: ::std::os::raw::c_uint = 30000;
pub const __WATCHOS_3_1: ::std::os::raw::c_uint = 30100;
pub const __WATCHOS_3_1_1: ::std::os::raw::c_uint = 30101;
pub const __WATCHOS_3_2: ::std::os::raw::c_uint = 30200;
pub const __WATCHOS_4_0: ::std::os::raw::c_uint = 40000;
pub const __WATCHOS_4_1: ::std::os::raw::c_uint = 40100;
pub const __WATCHOS_4_2: ::std::os::raw::c_uint = 40200;
pub const __WATCHOS_4_3: ::std::os::raw::c_uint = 40300;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: ::std::os::raw::c_uint = 101304;
pub const __DARWIN_WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const _FORTIFY_SOURCE: ::std::os::raw::c_uint = 2;
pub const RENAME_SECLUDE: ::std::os::raw::c_uint = 1;
pub const RENAME_SWAP: ::std::os::raw::c_uint = 2;
pub const RENAME_EXCL: ::std::os::raw::c_uint = 4;
pub const __SLBF: ::std::os::raw::c_uint = 1;
pub const __SNBF: ::std::os::raw::c_uint = 2;
pub const __SRD: ::std::os::raw::c_uint = 4;
pub const __SWR: ::std::os::raw::c_uint = 8;
pub const __SRW: ::std::os::raw::c_uint = 16;
pub const __SEOF: ::std::os::raw::c_uint = 32;
pub const __SERR: ::std::os::raw::c_uint = 64;
pub const __SMBF: ::std::os::raw::c_uint = 128;
pub const __SAPP: ::std::os::raw::c_uint = 256;
pub const __SSTR: ::std::os::raw::c_uint = 512;
pub const __SOPT: ::std::os::raw::c_uint = 1024;
pub const __SNPT: ::std::os::raw::c_uint = 2048;
pub const __SOFF: ::std::os::raw::c_uint = 4096;
pub const __SMOD: ::std::os::raw::c_uint = 8192;
pub const __SALC: ::std::os::raw::c_uint = 16384;
pub const __SIGN: ::std::os::raw::c_uint = 32768;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 1024;
pub const EOF: ::std::os::raw::c_int = -1;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 20;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 1024;
pub const TMP_MAX: ::std::os::raw::c_uint = 308915776;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const L_ctermid: ::std::os::raw::c_uint = 1024;
pub const __CTERMID_DEFINED: ::std::os::raw::c_uint = 1;
pub const _USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 2;
pub const TMAX_FILENAME_LEN: ::std::os::raw::c_uint = 255;
pub const EV3_LCD_WIDTH: ::std::os::raw::c_uint = 178;
pub const EV3_LCD_HEIGHT: ::std::os::raw::c_uint = 128;
pub const IR_RED_UP_BUTTON: ::std::os::raw::c_uint = 1;
pub const IR_RED_DOWN_BUTTON: ::std::os::raw::c_uint = 2;
pub const IR_BLUE_UP_BUTTON: ::std::os::raw::c_uint = 4;
pub const IR_BLUE_DOWN_BUTTON: ::std::os::raw::c_uint = 8;
pub const IR_BEACON_BUTTON: ::std::os::raw::c_uint = 16;
pub const SOUND_MANUAL_STOP: ::std::os::raw::c_int = -1;
pub const NOTE_C4: f64 = 261.63;
pub const NOTE_CS4: f64 = 277.18;
pub const NOTE_D4: f64 = 293.66;
pub const NOTE_DS4: f64 = 311.13;
pub const NOTE_E4: f64 = 329.63;
pub const NOTE_F4: f64 = 349.23;
pub const NOTE_FS4: f64 = 369.99;
pub const NOTE_G4: f64 = 392.;
pub const NOTE_GS4: f64 = 415.3;
pub const NOTE_A4: f64 = 440.;
pub const NOTE_AS4: f64 = 466.16;
pub const NOTE_B4: f64 = 493.88;
pub const NOTE_C5: f64 = 523.25;
pub const NOTE_CS5: f64 = 554.37;
pub const NOTE_D5: f64 = 587.33;
pub const NOTE_DS5: f64 = 622.25;
pub const NOTE_E5: f64 = 659.25;
pub const NOTE_F5: f64 = 698.46;
pub const NOTE_FS5: f64 = 739.99;
pub const NOTE_G5: f64 = 783.99;
pub const NOTE_GS5: f64 = 830.61;
pub const NOTE_A5: f64 = 880.;
pub const NOTE_AS5: f64 = 932.33;
pub const NOTE_B5: f64 = 987.77;
pub const NOTE_C6: f64 = 1046.5;
pub const NOTE_CS6: f64 = 1108.73;
pub const NOTE_D6: f64 = 1174.66;
pub const NOTE_DS6: f64 = 1244.51;
pub const NOTE_E6: f64 = 1318.51;
pub const NOTE_F6: f64 = 1396.91;
pub const NOTE_FS6: f64 = 1479.98;
pub const NOTE_G6: f64 = 1567.98;
pub const NOTE_GS6: f64 = 1661.22;
pub const NOTE_A6: f64 = 1760.;
pub const NOTE_AS6: f64 = 1864.66;
pub const NOTE_B6: f64 = 1975.53;
pub const TNUM_DOMID: ::std::os::raw::c_uint = 1;
pub const TNUM_TSKID: ::std::os::raw::c_uint = 60;
pub const TNUM_SEMID: ::std::os::raw::c_uint = 30;
pub const TNUM_FLGID: ::std::os::raw::c_uint = 20;
pub const TNUM_DTQID: ::std::os::raw::c_uint = 80;
pub const TNUM_PDQID: ::std::os::raw::c_uint = 16;
pub const TNUM_MTXID: ::std::os::raw::c_uint = 21;
pub const TNUM_MPFID: ::std::os::raw::c_uint = 4;
pub const TNUM_CYCID: ::std::os::raw::c_uint = 21;
pub const TNUM_ALMID: ::std::os::raw::c_uint = 1;
pub const TNUM_ISRID: ::std::os::raw::c_uint = 1;
pub const TDOM_APP: ::std::os::raw::c_uint = 1;
pub const LOGTASK: ::std::os::raw::c_uint = 1;
pub const BRICK_BTN_TSK: ::std::os::raw::c_uint = 2;
pub const LCD_REFRESH_TSK: ::std::os::raw::c_uint = 3;
pub const CONSOLE_BTN_TSK: ::std::os::raw::c_uint = 4;
pub const BT_TSK: ::std::os::raw::c_uint = 5;
pub const BT_QOS_TSK: ::std::os::raw::c_uint = 6;
pub const USBMSC_TSK: ::std::os::raw::c_uint = 7;
pub const EV3_INIT_TASK: ::std::os::raw::c_uint = 8;
pub const PLATFORM_BUSY_TASK: ::std::os::raw::c_uint = 9;
pub const EV3RT_LOGTASK: ::std::os::raw::c_uint = 10;
pub const APP_TERM_TASK: ::std::os::raw::c_uint = 11;
pub const ZMODEM_RECV_TASK: ::std::os::raw::c_uint = 12;
pub const SERIAL_RCV_SEM1: ::std::os::raw::c_uint = 1;
pub const SERIAL_SND_SEM1: ::std::os::raw::c_uint = 2;
pub const SERIAL_RCV_SEM2: ::std::os::raw::c_uint = 3;
pub const SERIAL_SND_SEM2: ::std::os::raw::c_uint = 4;
pub const SERIAL_RCV_SEM3: ::std::os::raw::c_uint = 5;
pub const SERIAL_SND_SEM3: ::std::os::raw::c_uint = 6;
pub const SERIAL_RCV_SEM4: ::std::os::raw::c_uint = 7;
pub const SERIAL_SND_SEM4: ::std::os::raw::c_uint = 8;
pub const MMCSD_MOD_SEM: ::std::os::raw::c_uint = 9;
pub const FATFS_SEM: ::std::os::raw::c_uint = 10;
pub const LCD_DMA_DONE_SEM: ::std::os::raw::c_uint = 11;
pub const SUART1_SEM: ::std::os::raw::c_uint = 12;
pub const SUART2_SEM: ::std::os::raw::c_uint = 13;
pub const SND_DEV_SEM: ::std::os::raw::c_uint = 14;
pub const BTN_CLICK_FLG: ::std::os::raw::c_uint = 1;
pub const CONSOLE_BTN_CLICK_FLG: ::std::os::raw::c_uint = 2;
pub const USBMSC_EVT_FLG: ::std::os::raw::c_uint = 3;
pub const APP_STATUS_FLAG: ::std::os::raw::c_uint = 4;
pub const DISKIO_MTX: ::std::os::raw::c_uint = 1;
pub const EV3RT_CONSOLE_MTX: ::std::os::raw::c_uint = 2;
pub const EV3RT_CONSOLE_LOG_MTX: ::std::os::raw::c_uint = 3;
pub const BT_DB_MTX: ::std::os::raw::c_uint = 4;
pub const DMLOADER_MTX: ::std::os::raw::c_uint = 5;
pub const BT_SIO_CYC: ::std::os::raw::c_uint = 1;
pub const DBSIO_TEST_SPP_MASTER_SIO_CYC: ::std::os::raw::c_uint = 2;
pub const BRICK_BTN_CYC: ::std::os::raw::c_uint = 3;
pub const BT_DMA_CYC: ::std::os::raw::c_uint = 4;
pub const EV3_BATTERY_MONITOR_CYC: ::std::os::raw::c_uint = 5;
pub const SND_STOP_ALM: ::std::os::raw::c_uint = 1;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __mbstate8: __BindgenUnionField<[::std::os::raw::c_char; 128usize]>,
    pub _mbstateL: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_pthread_handler_rec ) ));
    assert_eq! (::std::mem::align_of::<__darwin_pthread_handler_rec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_pthread_handler_rec )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) .
                __routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! (
                __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __arg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __arg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __next
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __next )
                ));
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_attr_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_attr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_cond_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_cond_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_condattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __sig as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutexattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutexattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_once_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_once_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_once_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __opaque )
                ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlockattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>() , 8192usize , concat
               ! ( "Size of: " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __sig as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __cleanup_stack
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __cleanup_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __opaque as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __opaque ) ));
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type rsize_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type ldsymbol_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TOPPERS_dummy_t {
    pub TOPPERS_dummy_field: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TOPPERS_dummy_t() {
    assert_eq!(::std::mem::size_of::<TOPPERS_dummy_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TOPPERS_dummy_t ) ));
    assert_eq! (::std::mem::align_of::<TOPPERS_dummy_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( TOPPERS_dummy_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TOPPERS_dummy_t ) ) . TOPPERS_dummy_field
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TOPPERS_dummy_t ) ,
                "::" , stringify ! ( TOPPERS_dummy_field ) ));
}
impl Clone for TOPPERS_dummy_t {
    fn clone(&self) -> Self { *self }
}
pub type TOPPERS_fp_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: TOPPERS_dummy_t)>;
pub type bool_t = ::std::os::raw::c_int;
pub type int_t = ::std::os::raw::c_int;
pub type uint_t = ::std::os::raw::c_uint;
pub type long_t = ::std::os::raw::c_long;
pub type ulong_t = ::std::os::raw::c_ulong;
pub type FN = int_t;
pub type ER = int_t;
pub type ID = int_t;
pub type ATR = uint_t;
pub type STAT = uint_t;
pub type MODE = uint_t;
pub type PRI = int_t;
pub type SIZE = usize;
pub type TMO = int_t;
pub type RELTIM = uint_t;
pub type SYSTIM = ulong_t;
pub type SYSUTM = ulong_t;
pub type FP = TOPPERS_fp_t;
pub type ER_BOOL = int_t;
pub type ER_ID = int_t;
pub type ER_UINT = int_t;
pub type MB_T = usize;
pub type ACPTN = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct acvct {
    pub acptn1: ACPTN,
    pub acptn2: ACPTN,
    pub acptn3: ACPTN,
    pub acptn4: ACPTN,
}
#[test]
fn bindgen_test_layout_acvct() {
    assert_eq!(::std::mem::size_of::<acvct>() , 16usize , concat ! (
               "Size of: " , stringify ! ( acvct ) ));
    assert_eq! (::std::mem::align_of::<acvct>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( acvct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const acvct ) ) . acptn1 as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( acvct ) , "::" ,
                stringify ! ( acptn1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const acvct ) ) . acptn2 as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( acvct ) , "::" ,
                stringify ! ( acptn2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const acvct ) ) . acptn3 as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( acvct ) , "::" ,
                stringify ! ( acptn3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const acvct ) ) . acptn4 as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( acvct ) , "::" ,
                stringify ! ( acptn4 ) ));
}
impl Clone for acvct {
    fn clone(&self) -> Self { *self }
}
pub type ACVCT = acvct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sio_port_control_block {
    _unused: [u8; 0],
}
pub type SIOPCB = sio_port_control_block;
extern "C" {
    pub fn sio_initialize_low();
}
extern "C" {
    pub fn sio_opn_por(siopid: ID, exinf: isize) -> *mut SIOPCB;
}
extern "C" {
    pub fn sio_cls_por(p_siopcb: *mut SIOPCB);
}
extern "C" {
    pub fn uart_sio_isr(exinf: isize);
}
extern "C" {
    pub fn uart_sio_cyc(exinf: isize);
}
extern "C" {
    pub fn sio_snd_chr(siopcb: *mut SIOPCB, c: ::std::os::raw::c_char)
     -> bool_t;
}
extern "C" {
    pub fn sio_rcv_chr(siopcb: *mut SIOPCB) -> int_t;
}
extern "C" {
    pub fn sio_ena_cbr(siopcb: *mut SIOPCB, cbrtn: uint_t);
}
extern "C" {
    pub fn sio_dis_cbr(siopcb: *mut SIOPCB, cbrtn: uint_t);
}
extern "C" {
    pub fn sio_irdy_snd(exinf: isize);
}
extern "C" {
    pub fn sio_irdy_rcv(exinf: isize);
}
extern "C" {
    pub fn bt_rcv_handler(data: *const u8, size: u16);
}
extern "C" {
    pub fn bt_sio_cyc(exinf: isize);
}
extern "C" {
    /**
 * Fetch the send buffer of Bluetooth into @buf.
 * The send buffer will be cleared (switched).
 * @param buf   a pointer to store base address of fetched send buffer.
 * @param bytes a pointer to store data size of fetched send buffer.
 */
    pub fn bt_fetch_snd_buf(buf: *mut *mut u8, bytes: *mut u32);
}
extern "C" {
    /**
 * Send a character to the LCD console
 */
    pub fn lcd_console_send_character(c: ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "SIO_PORT_DEFAULT"]
    pub static mut SIO_PORT_DEFAULT: ::std::os::raw::c_int;
}
extern "C" {
    pub fn svc_perror(file: *const ::std::os::raw::c_char, line: int_t,
                      expr: *const ::std::os::raw::c_char, ercd: ER);
}
extern "C" {
    pub fn pru_suart_isr(portline: isize);
}
#[repr(C)]
pub struct st_aintc {
    pub REVID: ::std::os::raw::c_ulong,
    pub CR: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 2usize],
    pub GER: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 2usize],
    pub GNLR: ::std::os::raw::c_ulong,
    pub SISR: ::std::os::raw::c_ulong,
    pub SICR: ::std::os::raw::c_ulong,
    pub EISR: ::std::os::raw::c_ulong,
    pub EICR: ::std::os::raw::c_ulong,
    pub Reserved3: ::std::os::raw::c_ulong,
    pub HIEISR: ::std::os::raw::c_ulong,
    pub HIEICR: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 5usize],
    pub VBR: ::std::os::raw::c_ulong,
    pub VSR: ::std::os::raw::c_ulong,
    pub VNR: ::std::os::raw::c_ulong,
    pub Reserved5: [::std::os::raw::c_ulong; 9usize],
    pub GPIR: ::std::os::raw::c_ulong,
    pub GPVR: ::std::os::raw::c_ulong,
    pub Reserved6: [::std::os::raw::c_ulong; 94usize],
    pub SRSR1: ::std::os::raw::c_ulong,
    pub SRSR2: ::std::os::raw::c_ulong,
    pub SRSR3: ::std::os::raw::c_ulong,
    pub SRSR4: ::std::os::raw::c_ulong,
    pub Reserved7: [::std::os::raw::c_ulong; 28usize],
    pub SECR1: ::std::os::raw::c_ulong,
    pub SECR2: ::std::os::raw::c_ulong,
    pub SECR3: ::std::os::raw::c_ulong,
    pub SECR4: ::std::os::raw::c_ulong,
    pub Reserved8: [::std::os::raw::c_ulong; 28usize],
    pub ESR1: ::std::os::raw::c_ulong,
    pub ESR2: ::std::os::raw::c_ulong,
    pub ESR3: ::std::os::raw::c_ulong,
    pub ESR4: ::std::os::raw::c_ulong,
    pub Reserved9: [::std::os::raw::c_ulong; 28usize],
    pub ECR1: ::std::os::raw::c_ulong,
    pub ECR2: ::std::os::raw::c_ulong,
    pub ECR3: ::std::os::raw::c_ulong,
    pub ECR4: ::std::os::raw::c_ulong,
    pub Reserved10: [::std::os::raw::c_ulong; 28usize],
    pub CMR: [::std::os::raw::c_uchar; 104usize],
    pub Reserved11: [::std::os::raw::c_ulong; 294usize],
    pub HIPIR1: ::std::os::raw::c_ulong,
    pub HIPIR2: ::std::os::raw::c_ulong,
    pub Reserved12: [::std::os::raw::c_ulong; 510usize],
    pub HINLR1: ::std::os::raw::c_ulong,
    pub HINLR2: ::std::os::raw::c_ulong,
    pub Reserved13: [::std::os::raw::c_ulong; 254usize],
    pub HIER: ::std::os::raw::c_ulong,
    pub Reserved14: [::std::os::raw::c_ulong; 63usize],
    pub HIPVR1: ::std::os::raw::c_ulong,
    pub HIPVR2: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_aintc() {
    assert_eq!(::std::mem::size_of::<st_aintc>() , 11176usize , concat ! (
               "Size of: " , stringify ! ( st_aintc ) ));
    assert_eq! (::std::mem::align_of::<st_aintc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_aintc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . REVID as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . CR as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( CR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved1 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . GER as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( GER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved2 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . GNLR as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( GNLR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SISR as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SISR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SICR as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SICR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . EISR as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( EISR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . EICR as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( EICR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved3 as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HIEISR as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HIEISR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HIEICR as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HIEICR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved4 as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . VBR as * const _ as usize
                } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( VBR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . VSR as * const _ as usize
                } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( VSR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . VNR as * const _ as usize
                } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( VNR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved5 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . GPIR as * const _ as usize
                } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( GPIR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . GPVR as * const _ as usize
                } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( GPVR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved6 as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SRSR1 as * const _ as
                usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SRSR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SRSR2 as * const _ as
                usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SRSR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SRSR3 as * const _ as
                usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SRSR3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SRSR4 as * const _ as
                usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SRSR4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved7 as * const _ as
                usize } , 1056usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SECR1 as * const _ as
                usize } , 1280usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SECR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SECR2 as * const _ as
                usize } , 1288usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SECR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SECR3 as * const _ as
                usize } , 1296usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SECR3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . SECR4 as * const _ as
                usize } , 1304usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( SECR4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved8 as * const _ as
                usize } , 1312usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . ESR1 as * const _ as usize
                } , 1536usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( ESR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . ESR2 as * const _ as usize
                } , 1544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( ESR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . ESR3 as * const _ as usize
                } , 1552usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( ESR3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . ESR4 as * const _ as usize
                } , 1560usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( ESR4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved9 as * const _ as
                usize } , 1568usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . ECR1 as * const _ as usize
                } , 1792usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( ECR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . ECR2 as * const _ as usize
                } , 1800usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( ECR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . ECR3 as * const _ as usize
                } , 1808usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( ECR3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . ECR4 as * const _ as usize
                } , 1816usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( ECR4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved10 as * const _ as
                usize } , 1824usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . CMR as * const _ as usize
                } , 2048usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( CMR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved11 as * const _ as
                usize } , 2152usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HIPIR1 as * const _ as
                usize } , 4504usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HIPIR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HIPIR2 as * const _ as
                usize } , 4512usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HIPIR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved12 as * const _ as
                usize } , 4520usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HINLR1 as * const _ as
                usize } , 8600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HINLR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HINLR2 as * const _ as
                usize } , 8608usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HINLR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved13 as * const _ as
                usize } , 8616usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HIER as * const _ as usize
                } , 10648usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HIER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . Reserved14 as * const _ as
                usize } , 10656usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( Reserved14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HIPVR1 as * const _ as
                usize } , 11160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HIPVR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_aintc ) ) . HIPVR2 as * const _ as
                usize } , 11168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_aintc ) , "::" ,
                stringify ! ( HIPVR2 ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_gpio {
    pub DIR: ::std::os::raw::c_ulong,
    pub OUT_DATA: ::std::os::raw::c_ulong,
    pub SET_DATA: ::std::os::raw::c_ulong,
    pub CLR_DATA: ::std::os::raw::c_ulong,
    pub IN_DATA: ::std::os::raw::c_ulong,
    pub SET_RIS_TRIG: ::std::os::raw::c_ulong,
    pub CLR_RIS_TRIG: ::std::os::raw::c_ulong,
    pub SET_FAL_TRIG: ::std::os::raw::c_ulong,
    pub CLR_FAL_TRIG: ::std::os::raw::c_ulong,
    pub INTSTAT: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_gpio() {
    assert_eq!(::std::mem::size_of::<st_gpio>() , 80usize , concat ! (
               "Size of: " , stringify ! ( st_gpio ) ));
    assert_eq! (::std::mem::align_of::<st_gpio>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_gpio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . DIR as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( DIR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . OUT_DATA as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( OUT_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . SET_DATA as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( SET_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . CLR_DATA as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( CLR_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . IN_DATA as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( IN_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . SET_RIS_TRIG as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( SET_RIS_TRIG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . CLR_RIS_TRIG as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( CLR_RIS_TRIG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . SET_FAL_TRIG as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( SET_FAL_TRIG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . CLR_FAL_TRIG as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( CLR_FAL_TRIG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_gpio ) ) . INTSTAT as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_gpio ) , "::" ,
                stringify ! ( INTSTAT ) ));
}
impl Clone for st_gpio {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_hpi {
    pub REVID: ::std::os::raw::c_ulong,
    pub PWREMU_MGMT: ::std::os::raw::c_ulong,
    pub Reserved1: ::std::os::raw::c_ulong,
    pub GPIO_EN: ::std::os::raw::c_ulong,
    pub GPIO_DIR1: ::std::os::raw::c_ulong,
    pub GPIO_DAT1: ::std::os::raw::c_ulong,
    pub GPIO_DIR2: ::std::os::raw::c_ulong,
    pub GPIO_DAT2: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 4usize],
    pub HPIC: ::std::os::raw::c_ulong,
    pub HPIAW: ::std::os::raw::c_ulong,
    pub HPIAR: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_hpi() {
    assert_eq!(::std::mem::size_of::<st_hpi>() , 120usize , concat ! (
               "Size of: " , stringify ! ( st_hpi ) ));
    assert_eq! (::std::mem::align_of::<st_hpi>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_hpi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . REVID as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . PWREMU_MGMT as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( PWREMU_MGMT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . Reserved1 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . GPIO_EN as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( GPIO_EN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . GPIO_DIR1 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( GPIO_DIR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . GPIO_DAT1 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( GPIO_DAT1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . GPIO_DIR2 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( GPIO_DIR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . GPIO_DAT2 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( GPIO_DAT2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . Reserved2 as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . HPIC as * const _ as usize }
                , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( HPIC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . HPIAW as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( HPIAW ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_hpi ) ) . HPIAR as * const _ as usize
                } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_hpi ) , "::" ,
                stringify ! ( HPIAR ) ));
}
impl Clone for st_hpi {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct st_pll0 {
    pub REVID: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 56usize],
    pub RSTYPE: ::std::os::raw::c_ulong,
    pub RSCTRL: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 5usize],
    pub PLLCTL: ::std::os::raw::c_ulong,
    pub OCSEL: ::std::os::raw::c_ulong,
    pub Reserved3: [::std::os::raw::c_ulong; 2usize],
    pub PLLM: ::std::os::raw::c_ulong,
    pub PREDIV: ::std::os::raw::c_ulong,
    pub PLLDIV1: ::std::os::raw::c_ulong,
    pub PLLDIV2: ::std::os::raw::c_ulong,
    pub PLLDIV3: ::std::os::raw::c_ulong,
    pub OSCDIV: ::std::os::raw::c_ulong,
    pub POSTDIV: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 3usize],
    pub PLLCMD: ::std::os::raw::c_ulong,
    pub PLLSTAT: ::std::os::raw::c_ulong,
    pub ALNCTL: ::std::os::raw::c_ulong,
    pub DCHANGE: ::std::os::raw::c_ulong,
    pub CKEN: ::std::os::raw::c_ulong,
    pub CKSTAT: ::std::os::raw::c_ulong,
    pub SYSTAT: ::std::os::raw::c_ulong,
    pub Reserved5: [::std::os::raw::c_ulong; 3usize],
    pub PLLDIV4: ::std::os::raw::c_ulong,
    pub PLLDIV5: ::std::os::raw::c_ulong,
    pub PLLDIV6: ::std::os::raw::c_ulong,
    pub PLLDIV7: ::std::os::raw::c_ulong,
    pub Reserved6: [::std::os::raw::c_ulong; 32usize],
    pub EMUCNT0: ::std::os::raw::c_ulong,
    pub EMUCNT1: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_pll0() {
    assert_eq!(::std::mem::size_of::<st_pll0>() , 1008usize , concat ! (
               "Size of: " , stringify ! ( st_pll0 ) ));
    assert_eq! (::std::mem::align_of::<st_pll0>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_pll0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . REVID as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . Reserved1 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . RSTYPE as * const _ as
                usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( RSTYPE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . RSCTRL as * const _ as
                usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( RSCTRL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . Reserved2 as * const _ as
                usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLCTL as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLCTL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . OCSEL as * const _ as usize
                } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( OCSEL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . Reserved3 as * const _ as
                usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLM as * const _ as usize
                } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLM ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PREDIV as * const _ as
                usize } , 552usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PREDIV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLDIV1 as * const _ as
                usize } , 560usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLDIV1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLDIV2 as * const _ as
                usize } , 568usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLDIV2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLDIV3 as * const _ as
                usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLDIV3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . OSCDIV as * const _ as
                usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( OSCDIV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . POSTDIV as * const _ as
                usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( POSTDIV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . Reserved4 as * const _ as
                usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLCMD as * const _ as
                usize } , 624usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLCMD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLSTAT as * const _ as
                usize } , 632usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . ALNCTL as * const _ as
                usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( ALNCTL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . DCHANGE as * const _ as
                usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( DCHANGE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . CKEN as * const _ as usize
                } , 656usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( CKEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . CKSTAT as * const _ as
                usize } , 664usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( CKSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . SYSTAT as * const _ as
                usize } , 672usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( SYSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . Reserved5 as * const _ as
                usize } , 680usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( Reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLDIV4 as * const _ as
                usize } , 704usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLDIV4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLDIV5 as * const _ as
                usize } , 712usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLDIV5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLDIV6 as * const _ as
                usize } , 720usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLDIV6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . PLLDIV7 as * const _ as
                usize } , 728usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( PLLDIV7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . Reserved6 as * const _ as
                usize } , 736usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( Reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . EMUCNT0 as * const _ as
                usize } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( EMUCNT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll0 ) ) . EMUCNT1 as * const _ as
                usize } , 1000usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll0 ) , "::" ,
                stringify ! ( EMUCNT1 ) ));
}
#[repr(C)]
pub struct st_pll1 {
    pub REVID: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 63usize],
    pub PLLCTL: ::std::os::raw::c_ulong,
    pub OCSEL: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 2usize],
    pub PLLM: ::std::os::raw::c_ulong,
    pub Reserved3: ::std::os::raw::c_ulong,
    pub PLLDIV1: ::std::os::raw::c_ulong,
    pub PLLDIV2: ::std::os::raw::c_ulong,
    pub PLLDIV3: ::std::os::raw::c_ulong,
    pub OSCDIV: ::std::os::raw::c_ulong,
    pub POSTDIV: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 3usize],
    pub PLLCMD: ::std::os::raw::c_ulong,
    pub PLLSTAT: ::std::os::raw::c_ulong,
    pub ALNCTL: ::std::os::raw::c_ulong,
    pub DCHANGE: ::std::os::raw::c_ulong,
    pub CKEN: ::std::os::raw::c_ulong,
    pub CKSTAT: ::std::os::raw::c_ulong,
    pub SYSTAT: ::std::os::raw::c_ulong,
    pub Reserved5: [::std::os::raw::c_ulong; 39usize],
    pub EMUCNT0: ::std::os::raw::c_ulong,
    pub EMUCNT1: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_pll1() {
    assert_eq!(::std::mem::size_of::<st_pll1>() , 1008usize , concat ! (
               "Size of: " , stringify ! ( st_pll1 ) ));
    assert_eq! (::std::mem::align_of::<st_pll1>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_pll1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . REVID as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . Reserved1 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . PLLCTL as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( PLLCTL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . OCSEL as * const _ as usize
                } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( OCSEL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . Reserved2 as * const _ as
                usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . PLLM as * const _ as usize
                } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( PLLM ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . Reserved3 as * const _ as
                usize } , 552usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . PLLDIV1 as * const _ as
                usize } , 560usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( PLLDIV1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . PLLDIV2 as * const _ as
                usize } , 568usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( PLLDIV2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . PLLDIV3 as * const _ as
                usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( PLLDIV3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . OSCDIV as * const _ as
                usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( OSCDIV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . POSTDIV as * const _ as
                usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( POSTDIV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . Reserved4 as * const _ as
                usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . PLLCMD as * const _ as
                usize } , 624usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( PLLCMD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . PLLSTAT as * const _ as
                usize } , 632usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( PLLSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . ALNCTL as * const _ as
                usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( ALNCTL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . DCHANGE as * const _ as
                usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( DCHANGE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . CKEN as * const _ as usize
                } , 656usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( CKEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . CKSTAT as * const _ as
                usize } , 664usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( CKSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . SYSTAT as * const _ as
                usize } , 672usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( SYSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . Reserved5 as * const _ as
                usize } , 680usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( Reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . EMUCNT0 as * const _ as
                usize } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( EMUCNT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_pll1 ) ) . EMUCNT1 as * const _ as
                usize } , 1000usize , concat ! (
                "Alignment of field: " , stringify ! ( st_pll1 ) , "::" ,
                stringify ! ( EMUCNT1 ) ));
}
#[repr(C)]
pub struct st_syscfg0 {
    pub REVID: ::std::os::raw::c_ulong,
    pub Reserved1: ::std::os::raw::c_ulong,
    pub DIEIDR0: ::std::os::raw::c_ulong,
    pub DIEIDR1: ::std::os::raw::c_ulong,
    pub DIEIDR2: ::std::os::raw::c_ulong,
    pub DIEIDR3: ::std::os::raw::c_ulong,
    pub DEVIDR0: ::std::os::raw::c_ulong,
    pub BOOTCFG: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 5usize],
    pub KICK0R: ::std::os::raw::c_ulong,
    pub KICK1R: ::std::os::raw::c_ulong,
    pub HOST0CFG: ::std::os::raw::c_ulong,
    pub Reserved3: [::std::os::raw::c_ulong; 40usize],
    pub IRAWSTAT: ::std::os::raw::c_ulong,
    pub IENSTAT: ::std::os::raw::c_ulong,
    pub IENSET: ::std::os::raw::c_ulong,
    pub IENCLR: ::std::os::raw::c_ulong,
    pub EOI: ::std::os::raw::c_ulong,
    pub FLTADDRR: ::std::os::raw::c_ulong,
    pub FLTSTAT: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 5usize],
    pub MSTPRI0: ::std::os::raw::c_ulong,
    pub MSTPRI1: ::std::os::raw::c_ulong,
    pub MSTPRI2: ::std::os::raw::c_ulong,
    pub Reserved5: ::std::os::raw::c_ulong,
    pub PINMUX0: ::std::os::raw::c_ulong,
    pub PINMUX1: ::std::os::raw::c_ulong,
    pub PINMUX2: ::std::os::raw::c_ulong,
    pub PINMUX3: ::std::os::raw::c_ulong,
    pub PINMUX4: ::std::os::raw::c_ulong,
    pub PINMUX5: ::std::os::raw::c_ulong,
    pub PINMUX6: ::std::os::raw::c_ulong,
    pub PINMUX7: ::std::os::raw::c_ulong,
    pub PINMUX8: ::std::os::raw::c_ulong,
    pub PINMUX9: ::std::os::raw::c_ulong,
    pub PINMUX10: ::std::os::raw::c_ulong,
    pub PINMUX11: ::std::os::raw::c_ulong,
    pub PINMUX12: ::std::os::raw::c_ulong,
    pub PINMUX13: ::std::os::raw::c_ulong,
    pub PINMUX14: ::std::os::raw::c_ulong,
    pub PINMUX15: ::std::os::raw::c_ulong,
    pub PINMUX16: ::std::os::raw::c_ulong,
    pub PINMUX17: ::std::os::raw::c_ulong,
    pub PINMUX18: ::std::os::raw::c_ulong,
    pub PINMUX19: ::std::os::raw::c_ulong,
    pub SUSPSRC: ::std::os::raw::c_ulong,
    pub CHIPSIG: ::std::os::raw::c_ulong,
    pub CHIPSIG_CLR: ::std::os::raw::c_ulong,
    pub CFGCHIP0: ::std::os::raw::c_ulong,
    pub CFGCHIP1: ::std::os::raw::c_ulong,
    pub CFGCHIP2: ::std::os::raw::c_ulong,
    pub CFGCHIP3: ::std::os::raw::c_ulong,
    pub CFGCHIP4: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_syscfg0() {
    assert_eq!(::std::mem::size_of::<st_syscfg0>() , 800usize , concat ! (
               "Size of: " , stringify ! ( st_syscfg0 ) ));
    assert_eq! (::std::mem::align_of::<st_syscfg0>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_syscfg0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . REVID as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . Reserved1 as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . DIEIDR0 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( DIEIDR0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . DIEIDR1 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( DIEIDR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . DIEIDR2 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( DIEIDR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . DIEIDR3 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( DIEIDR3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . DEVIDR0 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( DEVIDR0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . BOOTCFG as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( BOOTCFG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . Reserved2 as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . KICK0R as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( KICK0R ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . KICK1R as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( KICK1R ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . HOST0CFG as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( HOST0CFG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . Reserved3 as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . IRAWSTAT as * const _ as
                usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( IRAWSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . IENSTAT as * const _ as
                usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( IENSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . IENSET as * const _ as
                usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( IENSET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . IENCLR as * const _ as
                usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( IENCLR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . EOI as * const _ as
                usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( EOI ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . FLTADDRR as * const _ as
                usize } , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( FLTADDRR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . FLTSTAT as * const _ as
                usize } , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( FLTSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . Reserved4 as * const _
                as usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . MSTPRI0 as * const _ as
                usize } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( MSTPRI0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . MSTPRI1 as * const _ as
                usize } , 552usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( MSTPRI1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . MSTPRI2 as * const _ as
                usize } , 560usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( MSTPRI2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . Reserved5 as * const _
                as usize } , 568usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( Reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX0 as * const _ as
                usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX1 as * const _ as
                usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX2 as * const _ as
                usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX3 as * const _ as
                usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX4 as * const _ as
                usize } , 608usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX5 as * const _ as
                usize } , 616usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX6 as * const _ as
                usize } , 624usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX7 as * const _ as
                usize } , 632usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX8 as * const _ as
                usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX9 as * const _ as
                usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX10 as * const _ as
                usize } , 656usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX11 as * const _ as
                usize } , 664usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX12 as * const _ as
                usize } , 672usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX13 as * const _ as
                usize } , 680usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX14 as * const _ as
                usize } , 688usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX15 as * const _ as
                usize } , 696usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX16 as * const _ as
                usize } , 704usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX17 as * const _ as
                usize } , 712usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX17 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX18 as * const _ as
                usize } , 720usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX18 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . PINMUX19 as * const _ as
                usize } , 728usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( PINMUX19 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . SUSPSRC as * const _ as
                usize } , 736usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( SUSPSRC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . CHIPSIG as * const _ as
                usize } , 744usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( CHIPSIG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . CHIPSIG_CLR as * const _
                as usize } , 752usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( CHIPSIG_CLR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . CFGCHIP0 as * const _ as
                usize } , 760usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( CFGCHIP0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . CFGCHIP1 as * const _ as
                usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( CFGCHIP1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . CFGCHIP2 as * const _ as
                usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( CFGCHIP2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . CFGCHIP3 as * const _ as
                usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( CFGCHIP3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg0 ) ) . CFGCHIP4 as * const _ as
                usize } , 792usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg0 ) , "::" ,
                stringify ! ( CFGCHIP4 ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_syscfg1 {
    pub VTPIO_CTL: ::std::os::raw::c_ulong,
    pub DDR_SLEW: ::std::os::raw::c_ulong,
    pub DEEPSLEEP: ::std::os::raw::c_ulong,
    pub PUPD_ENA: ::std::os::raw::c_ulong,
    pub PUPD_SEL: ::std::os::raw::c_ulong,
    pub RXACTIVE: ::std::os::raw::c_ulong,
    pub PWRDN: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_syscfg1() {
    assert_eq!(::std::mem::size_of::<st_syscfg1>() , 56usize , concat ! (
               "Size of: " , stringify ! ( st_syscfg1 ) ));
    assert_eq! (::std::mem::align_of::<st_syscfg1>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_syscfg1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg1 ) ) . VTPIO_CTL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg1 ) , "::" ,
                stringify ! ( VTPIO_CTL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg1 ) ) . DDR_SLEW as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg1 ) , "::" ,
                stringify ! ( DDR_SLEW ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg1 ) ) . DEEPSLEEP as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg1 ) , "::" ,
                stringify ! ( DEEPSLEEP ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg1 ) ) . PUPD_ENA as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg1 ) , "::" ,
                stringify ! ( PUPD_ENA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg1 ) ) . PUPD_SEL as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg1 ) , "::" ,
                stringify ! ( PUPD_SEL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg1 ) ) . RXACTIVE as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg1 ) , "::" ,
                stringify ! ( RXACTIVE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_syscfg1 ) ) . PWRDN as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_syscfg1 ) , "::" ,
                stringify ! ( PWRDN ) ));
}
impl Clone for st_syscfg1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct st_psc {
    pub REVID: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 5usize],
    pub INTEVAL: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 9usize],
    pub MERRPR0: ::std::os::raw::c_ulong,
    pub Reserved3: [::std::os::raw::c_ulong; 3usize],
    pub MERRCR0: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 3usize],
    pub PERRPR: ::std::os::raw::c_ulong,
    pub Reserved5: ::std::os::raw::c_ulong,
    pub PERRCR: ::std::os::raw::c_ulong,
    pub Reserved6: [::std::os::raw::c_ulong; 45usize],
    pub PTCMD: ::std::os::raw::c_ulong,
    pub Reserved7: ::std::os::raw::c_ulong,
    pub PTSTAT: ::std::os::raw::c_ulong,
    pub Reserved8: [::std::os::raw::c_ulong; 53usize],
    pub PDSTAT0: ::std::os::raw::c_ulong,
    pub PDSTAT1: ::std::os::raw::c_ulong,
    pub Reserved9: [::std::os::raw::c_ulong; 62usize],
    pub PDCTL0: ::std::os::raw::c_ulong,
    pub PDCTL1: ::std::os::raw::c_ulong,
    pub Reserved10: [::std::os::raw::c_ulong; 62usize],
    pub PDCFG0: ::std::os::raw::c_ulong,
    pub PDCFG1: ::std::os::raw::c_ulong,
    pub Reserved11: [::std::os::raw::c_ulong; 254usize],
    pub MDSTAT: [::std::os::raw::c_ulong; 32usize],
    pub Reserved12: [::std::os::raw::c_ulong; 157usize],
    pub MDCTL: [::std::os::raw::c_ulong; 32usize],
}
#[test]
fn bindgen_test_layout_st_psc() {
    assert_eq!(::std::mem::size_of::<st_psc>() , 5864usize , concat ! (
               "Size of: " , stringify ! ( st_psc ) ));
    assert_eq! (::std::mem::align_of::<st_psc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_psc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . REVID as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved1 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . INTEVAL as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( INTEVAL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved2 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . MERRPR0 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( MERRPR0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved3 as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . MERRCR0 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( MERRCR0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved4 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PERRPR as * const _ as usize
                } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PERRPR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved5 as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PERRCR as * const _ as usize
                } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PERRCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved6 as * const _ as
                usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PTCMD as * const _ as usize
                } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PTCMD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved7 as * const _ as
                usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PTSTAT as * const _ as usize
                } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PTSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved8 as * const _ as
                usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PDSTAT0 as * const _ as
                usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PDSTAT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PDSTAT1 as * const _ as
                usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PDSTAT1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved9 as * const _ as
                usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PDCTL0 as * const _ as usize
                } , 1536usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PDCTL0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PDCTL1 as * const _ as usize
                } , 1544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PDCTL1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved10 as * const _ as
                usize } , 1552usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PDCFG0 as * const _ as usize
                } , 2048usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PDCFG0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . PDCFG1 as * const _ as usize
                } , 2056usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( PDCFG1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved11 as * const _ as
                usize } , 2064usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . MDSTAT as * const _ as usize
                } , 4096usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( MDSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . Reserved12 as * const _ as
                usize } , 4352usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( Reserved12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_psc ) ) . MDCTL as * const _ as usize
                } , 5608usize , concat ! (
                "Alignment of field: " , stringify ! ( st_psc ) , "::" ,
                stringify ! ( MDCTL ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_emif {
    pub MIDR: ::std::os::raw::c_ulong,
    pub AWCC: ::std::os::raw::c_ulong,
    pub SDCR: ::std::os::raw::c_ulong,
    pub SDRCR: ::std::os::raw::c_ulong,
    pub CE2CFG: ::std::os::raw::c_ulong,
    pub CE3CFG: ::std::os::raw::c_ulong,
    pub CE4CFG: ::std::os::raw::c_ulong,
    pub CE5CFG: ::std::os::raw::c_ulong,
    pub SDTIMR: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 6usize],
    pub SDSRETR: ::std::os::raw::c_ulong,
    pub INTRAW: ::std::os::raw::c_ulong,
    pub INTMSK: ::std::os::raw::c_ulong,
    pub INTMSKSET: ::std::os::raw::c_ulong,
    pub INTMSKCLR: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 4usize],
    pub NANDFCR: ::std::os::raw::c_ulong,
    pub NANDFSR: ::std::os::raw::c_ulong,
    pub PMCR: ::std::os::raw::c_ulong,
    pub Reserved3: ::std::os::raw::c_ulong,
    pub NANDF1ECC: ::std::os::raw::c_ulong,
    pub NANDF2ECC: ::std::os::raw::c_ulong,
    pub NANDF3ECC: ::std::os::raw::c_ulong,
    pub NANDF4ECC: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 15usize],
    pub NAND4BITECCLOAD: ::std::os::raw::c_ulong,
    pub NAND4BITECC1: ::std::os::raw::c_ulong,
    pub NAND4BITECC2: ::std::os::raw::c_ulong,
    pub NAND4BITECC3: ::std::os::raw::c_ulong,
    pub NAND4BITECC4: ::std::os::raw::c_ulong,
    pub NANDERRADD1: ::std::os::raw::c_ulong,
    pub NANDERRADD2: ::std::os::raw::c_ulong,
    pub NANDERRVAL1: ::std::os::raw::c_ulong,
    pub NANDERRVAL2: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_emif() {
    assert_eq!(::std::mem::size_of::<st_emif>() , 448usize , concat ! (
               "Size of: " , stringify ! ( st_emif ) ));
    assert_eq! (::std::mem::align_of::<st_emif>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_emif ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . MIDR as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( MIDR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . AWCC as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( AWCC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . SDCR as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( SDCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . SDRCR as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( SDRCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . CE2CFG as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( CE2CFG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . CE3CFG as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( CE3CFG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . CE4CFG as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( CE4CFG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . CE5CFG as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( CE5CFG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . SDTIMR as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( SDTIMR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . Reserved1 as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . SDSRETR as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( SDSRETR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . INTRAW as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( INTRAW ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . INTMSK as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( INTMSK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . INTMSKSET as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( INTMSKSET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . INTMSKCLR as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( INTMSKCLR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . Reserved2 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDFCR as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDFCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDFSR as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDFSR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . PMCR as * const _ as usize
                } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( PMCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . Reserved3 as * const _ as
                usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDF1ECC as * const _ as
                usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDF1ECC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDF2ECC as * const _ as
                usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDF2ECC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDF3ECC as * const _ as
                usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDF3ECC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDF4ECC as * const _ as
                usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDF4ECC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . Reserved4 as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NAND4BITECCLOAD as * const
                _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NAND4BITECCLOAD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NAND4BITECC1 as * const _
                as usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NAND4BITECC1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NAND4BITECC2 as * const _
                as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NAND4BITECC2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NAND4BITECC3 as * const _
                as usize } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NAND4BITECC3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NAND4BITECC4 as * const _
                as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NAND4BITECC4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDERRADD1 as * const _ as
                usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDERRADD1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDERRADD2 as * const _ as
                usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDERRADD2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDERRVAL1 as * const _ as
                usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDERRVAL1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_emif ) ) . NANDERRVAL2 as * const _ as
                usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( st_emif ) , "::" ,
                stringify ! ( NANDERRVAL2 ) ));
}
impl Clone for st_emif {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_ddr {
    pub REVID: ::std::os::raw::c_ulong,
    pub SDRSTAT: ::std::os::raw::c_ulong,
    pub SDCR: ::std::os::raw::c_ulong,
    pub SDRCR: ::std::os::raw::c_ulong,
    pub SDTIMR1: ::std::os::raw::c_ulong,
    pub SDTIMR2: ::std::os::raw::c_ulong,
    pub Reserved1: ::std::os::raw::c_ulong,
    pub SDCR2: ::std::os::raw::c_ulong,
    pub PBBPR: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 7usize],
    pub PC1: ::std::os::raw::c_ulong,
    pub PC2: ::std::os::raw::c_ulong,
    pub PCC: ::std::os::raw::c_ulong,
    pub PCMRS: ::std::os::raw::c_ulong,
    pub PCT: ::std::os::raw::c_ulong,
    pub Reserved3: [::std::os::raw::c_ulong; 3usize],
    pub DRPYRCR: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 23usize],
    pub IRR: ::std::os::raw::c_ulong,
    pub IMR: ::std::os::raw::c_ulong,
    pub IMSR: ::std::os::raw::c_ulong,
    pub IMCR: ::std::os::raw::c_ulong,
    pub Reserved5: [::std::os::raw::c_ulong; 5usize],
    pub DRPYC1R: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_ddr() {
    assert_eq!(::std::mem::size_of::<st_ddr>() , 464usize , concat ! (
               "Size of: " , stringify ! ( st_ddr ) ));
    assert_eq! (::std::mem::align_of::<st_ddr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_ddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . REVID as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . SDRSTAT as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( SDRSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . SDCR as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( SDCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . SDRCR as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( SDRCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . SDTIMR1 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( SDTIMR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . SDTIMR2 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( SDTIMR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . Reserved1 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . SDCR2 as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( SDCR2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . PBBPR as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( PBBPR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . Reserved2 as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . PC1 as * const _ as usize }
                , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( PC1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . PC2 as * const _ as usize }
                , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( PC2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . PCC as * const _ as usize }
                , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( PCC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . PCMRS as * const _ as usize
                } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( PCMRS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . PCT as * const _ as usize }
                , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( PCT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . Reserved3 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . DRPYRCR as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( DRPYRCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . Reserved4 as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . IRR as * const _ as usize }
                , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( IRR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . IMR as * const _ as usize }
                , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( IMR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . IMSR as * const _ as usize }
                , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( IMSR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . IMCR as * const _ as usize }
                , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( IMCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . Reserved5 as * const _ as
                usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( Reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ddr ) ) . DRPYC1R as * const _ as
                usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ddr ) , "::" ,
                stringify ! ( DRPYC1R ) ));
}
impl Clone for st_ddr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_uart {
    pub RBR_THR: ::std::os::raw::c_ulong,
    pub IER: ::std::os::raw::c_ulong,
    pub IIR_FCR: ::std::os::raw::c_ulong,
    pub LCR: ::std::os::raw::c_ulong,
    pub MCR: ::std::os::raw::c_ulong,
    pub LSR: ::std::os::raw::c_ulong,
    pub MSR: ::std::os::raw::c_ulong,
    pub SCR: ::std::os::raw::c_ulong,
    pub DLL: ::std::os::raw::c_ulong,
    pub DLH: ::std::os::raw::c_ulong,
    pub REVID1: ::std::os::raw::c_ulong,
    pub REVID2: ::std::os::raw::c_ulong,
    pub PWREMU_MGMT: ::std::os::raw::c_ulong,
    pub MDR: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_uart() {
    assert_eq!(::std::mem::size_of::<st_uart>() , 112usize , concat ! (
               "Size of: " , stringify ! ( st_uart ) ));
    assert_eq! (::std::mem::align_of::<st_uart>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_uart ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . RBR_THR as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( RBR_THR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . IER as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( IER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . IIR_FCR as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( IIR_FCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . LCR as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( LCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . MCR as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( MCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . LSR as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( LSR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . MSR as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( MSR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . SCR as * const _ as usize }
                , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( SCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . DLL as * const _ as usize }
                , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( DLL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . DLH as * const _ as usize }
                , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( DLH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . REVID1 as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( REVID1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . REVID2 as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( REVID2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . PWREMU_MGMT as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( PWREMU_MGMT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_uart ) ) . MDR as * const _ as usize }
                , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( st_uart ) , "::" ,
                stringify ! ( MDR ) ));
}
impl Clone for st_uart {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_spi {
    pub SPIGCR0: ::std::os::raw::c_ulong,
    pub SPIGCR1: ::std::os::raw::c_ulong,
    pub SPIINT0: ::std::os::raw::c_ulong,
    pub SPILVL: ::std::os::raw::c_ulong,
    pub SPIFLG: ::std::os::raw::c_ulong,
    pub SPIPC0: ::std::os::raw::c_ulong,
    pub SPIPC1: ::std::os::raw::c_ulong,
    pub SPIPC2: ::std::os::raw::c_ulong,
    pub SPIPC3: ::std::os::raw::c_ulong,
    pub SPIPC4: ::std::os::raw::c_ulong,
    pub SPIPC5: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 3usize],
    pub SPIDAT0: ::std::os::raw::c_ulong,
    pub SPIDAT1: ::std::os::raw::c_ulong,
    pub SPIBUF: ::std::os::raw::c_ulong,
    pub SPIEMU: ::std::os::raw::c_ulong,
    pub SPIDELAY: ::std::os::raw::c_ulong,
    pub SPIDEF: ::std::os::raw::c_ulong,
    pub SPIFMT0: ::std::os::raw::c_ulong,
    pub SPIFMT1: ::std::os::raw::c_ulong,
    pub SPIFMT2: ::std::os::raw::c_ulong,
    pub SPIFMT3: ::std::os::raw::c_ulong,
    pub Reserved2: ::std::os::raw::c_ulong,
    pub INTVEC1: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_spi() {
    assert_eq!(::std::mem::size_of::<st_spi>() , 208usize , concat ! (
               "Size of: " , stringify ! ( st_spi ) ));
    assert_eq! (::std::mem::align_of::<st_spi>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_spi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIGCR0 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIGCR0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIGCR1 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIGCR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIINT0 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIINT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPILVL as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPILVL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIFLG as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIFLG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIPC0 as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIPC0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIPC1 as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIPC1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIPC2 as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIPC2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIPC3 as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIPC3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIPC4 as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIPC4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIPC5 as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIPC5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . Reserved1 as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIDAT0 as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIDAT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIDAT1 as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIDAT1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIBUF as * const _ as usize
                } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIBUF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIEMU as * const _ as usize
                } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIEMU ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIDELAY as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIDELAY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIDEF as * const _ as usize
                } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIDEF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIFMT0 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIFMT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIFMT1 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIFMT1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIFMT2 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIFMT2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . SPIFMT3 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( SPIFMT3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . Reserved2 as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_spi ) ) . INTVEC1 as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_spi ) , "::" ,
                stringify ! ( INTVEC1 ) ));
}
impl Clone for st_spi {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct st_edma_cc {
    pub REVID: ::std::os::raw::c_ulong,
    pub CCCFG: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 126usize],
    pub QCHMAP0: ::std::os::raw::c_ulong,
    pub QCHMAP1: ::std::os::raw::c_ulong,
    pub QCHMAP2: ::std::os::raw::c_ulong,
    pub QCHMAP3: ::std::os::raw::c_ulong,
    pub QCHMAP4: ::std::os::raw::c_ulong,
    pub QCHMAP5: ::std::os::raw::c_ulong,
    pub QCHMAP6: ::std::os::raw::c_ulong,
    pub QCHMAP7: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 8usize],
    pub DMAQNUM0: ::std::os::raw::c_ulong,
    pub DMAQNUM1: ::std::os::raw::c_ulong,
    pub DMAQNUM2: ::std::os::raw::c_ulong,
    pub DMAQNUM3: ::std::os::raw::c_ulong,
    pub Reserved3: [::std::os::raw::c_ulong; 4usize],
    pub QDMAQNUM: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 8usize],
    pub QUEPRI: ::std::os::raw::c_ulong,
    pub Reserved5: [::std::os::raw::c_ulong; 30usize],
    pub EMR: ::std::os::raw::c_ulong,
    pub Reserved6: ::std::os::raw::c_ulong,
    pub EMCR: ::std::os::raw::c_ulong,
    pub Reserved7: ::std::os::raw::c_ulong,
    pub QEMR: ::std::os::raw::c_ulong,
    pub QEMCR: ::std::os::raw::c_ulong,
    pub CCERR: ::std::os::raw::c_ulong,
    pub CCERRCLR: ::std::os::raw::c_ulong,
    pub EEVAL: ::std::os::raw::c_ulong,
    pub Reserved8: [::std::os::raw::c_ulong; 7usize],
    pub DRAE0: ::std::os::raw::c_ulong,
    pub Reserved9: ::std::os::raw::c_ulong,
    pub DRAE1: ::std::os::raw::c_ulong,
    pub Reserved10: ::std::os::raw::c_ulong,
    pub DRAE2: ::std::os::raw::c_ulong,
    pub Reserved11: ::std::os::raw::c_ulong,
    pub DRAE3: ::std::os::raw::c_ulong,
    pub Reserved12: [::std::os::raw::c_ulong; 9usize],
    pub QRAE0: ::std::os::raw::c_ulong,
    pub QRAE1: ::std::os::raw::c_ulong,
    pub QRAE2: ::std::os::raw::c_ulong,
    pub QRAE3: ::std::os::raw::c_ulong,
    pub Reserved13: [::std::os::raw::c_ulong; 28usize],
    pub Q0E: [::std::os::raw::c_ulong; 16usize],
    pub Q1E: [::std::os::raw::c_ulong; 16usize],
    pub Reserved14: [::std::os::raw::c_ulong; 96usize],
    pub QSTAT0: ::std::os::raw::c_ulong,
    pub QSTAT1: ::std::os::raw::c_ulong,
    pub Reserved15: [::std::os::raw::c_ulong; 6usize],
    pub QWMTHRA: ::std::os::raw::c_ulong,
    pub Reserved16: [::std::os::raw::c_ulong; 7usize],
    pub CCSTAT: ::std::os::raw::c_ulong,
    pub Reserved17: [::std::os::raw::c_ulong; 623usize],
    pub ER: ::std::os::raw::c_ulong,
    pub Reserved18: ::std::os::raw::c_ulong,
    pub ECR: ::std::os::raw::c_ulong,
    pub Reserved19: ::std::os::raw::c_ulong,
    pub ESR: ::std::os::raw::c_ulong,
    pub Reserved20: ::std::os::raw::c_ulong,
    pub CER: ::std::os::raw::c_ulong,
    pub Reserved21: ::std::os::raw::c_ulong,
    pub EER: ::std::os::raw::c_ulong,
    pub Reserved22: ::std::os::raw::c_ulong,
    pub EECR: ::std::os::raw::c_ulong,
    pub Reserved23: ::std::os::raw::c_ulong,
    pub EESR: ::std::os::raw::c_ulong,
    pub Reserved24: ::std::os::raw::c_ulong,
    pub SER: ::std::os::raw::c_ulong,
    pub Reserved25: ::std::os::raw::c_ulong,
    pub SECR: ::std::os::raw::c_ulong,
    pub Reserved26: [::std::os::raw::c_ulong; 3usize],
    pub IER: ::std::os::raw::c_ulong,
    pub Reserved27: ::std::os::raw::c_ulong,
    pub IECR: ::std::os::raw::c_ulong,
    pub Reserved28: ::std::os::raw::c_ulong,
    pub IESR: ::std::os::raw::c_ulong,
    pub Reserved29: ::std::os::raw::c_ulong,
    pub IPR: ::std::os::raw::c_ulong,
    pub Reserved30: ::std::os::raw::c_ulong,
    pub ICR: ::std::os::raw::c_ulong,
    pub Reserved31: ::std::os::raw::c_ulong,
    pub IEVAL: ::std::os::raw::c_ulong,
    pub Reserved32: ::std::os::raw::c_ulong,
    pub QER: ::std::os::raw::c_ulong,
    pub QEER: ::std::os::raw::c_ulong,
    pub QEECR: ::std::os::raw::c_ulong,
    pub QEESR: ::std::os::raw::c_ulong,
    pub QSER: ::std::os::raw::c_ulong,
    pub QSECR: ::std::os::raw::c_ulong,
    pub Reserved33: [::std::os::raw::c_ulong; 986usize],
    pub ER_S0: ::std::os::raw::c_ulong,
    pub Reserved34: ::std::os::raw::c_ulong,
    pub ECR_S0: ::std::os::raw::c_ulong,
    pub Reserved35: ::std::os::raw::c_ulong,
    pub ESR_S0: ::std::os::raw::c_ulong,
    pub Reserved36: ::std::os::raw::c_ulong,
    pub CER_S0: ::std::os::raw::c_ulong,
    pub Reserved37: ::std::os::raw::c_ulong,
    pub EER_S0: ::std::os::raw::c_ulong,
    pub Reserved38: ::std::os::raw::c_ulong,
    pub EECR_S0: ::std::os::raw::c_ulong,
    pub Reserved39: ::std::os::raw::c_ulong,
    pub EESR_S0: ::std::os::raw::c_ulong,
    pub Reserved40: ::std::os::raw::c_ulong,
    pub SER_S0: ::std::os::raw::c_ulong,
    pub Reserved41: ::std::os::raw::c_ulong,
    pub SECR_S0: ::std::os::raw::c_ulong,
    pub Reserved42: [::std::os::raw::c_ulong; 3usize],
    pub IER_S0: ::std::os::raw::c_ulong,
    pub Reserved43: ::std::os::raw::c_ulong,
    pub IECR_S0: ::std::os::raw::c_ulong,
    pub Reserved44: ::std::os::raw::c_ulong,
    pub IESR_S0: ::std::os::raw::c_ulong,
    pub Reserved45: ::std::os::raw::c_ulong,
    pub IPR_S0: ::std::os::raw::c_ulong,
    pub Reserved46: ::std::os::raw::c_ulong,
    pub ICR_S0: ::std::os::raw::c_ulong,
    pub Reserved47: ::std::os::raw::c_ulong,
    pub IEVAL_S0: ::std::os::raw::c_ulong,
    pub Reserved48: ::std::os::raw::c_ulong,
    pub QER_S0: ::std::os::raw::c_ulong,
    pub QEER_S0: ::std::os::raw::c_ulong,
    pub QEECR_S0: ::std::os::raw::c_ulong,
    pub QEESR_S0: ::std::os::raw::c_ulong,
    pub QSER_S0: ::std::os::raw::c_ulong,
    pub QSECR_S0: ::std::os::raw::c_ulong,
    pub Reserved49: [::std::os::raw::c_ulong; 90usize],
    pub ER_S1: ::std::os::raw::c_ulong,
    pub Reserved50: ::std::os::raw::c_ulong,
    pub ECR_S1: ::std::os::raw::c_ulong,
    pub Reserved51: ::std::os::raw::c_ulong,
    pub ESR_S1: ::std::os::raw::c_ulong,
    pub Reserved52: ::std::os::raw::c_ulong,
    pub CER_S1: ::std::os::raw::c_ulong,
    pub Reserved53: ::std::os::raw::c_ulong,
    pub EER_S1: ::std::os::raw::c_ulong,
    pub Reserved54: ::std::os::raw::c_ulong,
    pub EECR_S1: ::std::os::raw::c_ulong,
    pub Reserved55: ::std::os::raw::c_ulong,
    pub EESR_S1: ::std::os::raw::c_ulong,
    pub Reserved56: ::std::os::raw::c_ulong,
    pub SER_S1: ::std::os::raw::c_ulong,
    pub Reserved57: ::std::os::raw::c_ulong,
    pub SECR_S1: ::std::os::raw::c_ulong,
    pub Reserved58: [::std::os::raw::c_ulong; 3usize],
    pub IER_S1: ::std::os::raw::c_ulong,
    pub Reserved59: ::std::os::raw::c_ulong,
    pub IECR_S1: ::std::os::raw::c_ulong,
    pub Reserved60: ::std::os::raw::c_ulong,
    pub IESR_S1: ::std::os::raw::c_ulong,
    pub Reserved61: ::std::os::raw::c_ulong,
    pub IPR_S1: ::std::os::raw::c_ulong,
    pub Reserved62: ::std::os::raw::c_ulong,
    pub ICR_S1: ::std::os::raw::c_ulong,
    pub Reserved63: ::std::os::raw::c_ulong,
    pub IEVAL_S1: ::std::os::raw::c_ulong,
    pub Reserved64: ::std::os::raw::c_ulong,
    pub QER_S1: ::std::os::raw::c_ulong,
    pub QEER_S1: ::std::os::raw::c_ulong,
    pub QEECR_S1: ::std::os::raw::c_ulong,
    pub QEESR_S1: ::std::os::raw::c_ulong,
    pub QSER_S1: ::std::os::raw::c_ulong,
    pub QSECR_S1: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_edma_cc() {
    assert_eq!(::std::mem::size_of::<st_edma_cc>() , 17712usize , concat ! (
               "Size of: " , stringify ! ( st_edma_cc ) ));
    assert_eq! (::std::mem::align_of::<st_edma_cc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_edma_cc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . REVID as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . CCCFG as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( CCCFG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved1 as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QCHMAP0 as * const _ as
                usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QCHMAP0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QCHMAP1 as * const _ as
                usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QCHMAP1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QCHMAP2 as * const _ as
                usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QCHMAP2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QCHMAP3 as * const _ as
                usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QCHMAP3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QCHMAP4 as * const _ as
                usize } , 1056usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QCHMAP4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QCHMAP5 as * const _ as
                usize } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QCHMAP5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QCHMAP6 as * const _ as
                usize } , 1072usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QCHMAP6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QCHMAP7 as * const _ as
                usize } , 1080usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QCHMAP7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved2 as * const _
                as usize } , 1088usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . DMAQNUM0 as * const _ as
                usize } , 1152usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( DMAQNUM0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . DMAQNUM1 as * const _ as
                usize } , 1160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( DMAQNUM1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . DMAQNUM2 as * const _ as
                usize } , 1168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( DMAQNUM2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . DMAQNUM3 as * const _ as
                usize } , 1176usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( DMAQNUM3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved3 as * const _
                as usize } , 1184usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QDMAQNUM as * const _ as
                usize } , 1216usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QDMAQNUM ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved4 as * const _
                as usize } , 1224usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QUEPRI as * const _ as
                usize } , 1288usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QUEPRI ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved5 as * const _
                as usize } , 1296usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EMR as * const _ as
                usize } , 1536usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EMR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved6 as * const _
                as usize } , 1544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EMCR as * const _ as
                usize } , 1552usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EMCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved7 as * const _
                as usize } , 1560usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEMR as * const _ as
                usize } , 1568usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEMR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEMCR as * const _ as
                usize } , 1576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEMCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . CCERR as * const _ as
                usize } , 1584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( CCERR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . CCERRCLR as * const _ as
                usize } , 1592usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( CCERRCLR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EEVAL as * const _ as
                usize } , 1600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EEVAL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved8 as * const _
                as usize } , 1608usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . DRAE0 as * const _ as
                usize } , 1664usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( DRAE0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved9 as * const _
                as usize } , 1672usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . DRAE1 as * const _ as
                usize } , 1680usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( DRAE1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved10 as * const _
                as usize } , 1688usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . DRAE2 as * const _ as
                usize } , 1696usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( DRAE2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved11 as * const _
                as usize } , 1704usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . DRAE3 as * const _ as
                usize } , 1712usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( DRAE3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved12 as * const _
                as usize } , 1720usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QRAE0 as * const _ as
                usize } , 1792usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QRAE0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QRAE1 as * const _ as
                usize } , 1800usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QRAE1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QRAE2 as * const _ as
                usize } , 1808usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QRAE2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QRAE3 as * const _ as
                usize } , 1816usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QRAE3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved13 as * const _
                as usize } , 1824usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Q0E as * const _ as
                usize } , 2048usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Q0E ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Q1E as * const _ as
                usize } , 2176usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Q1E ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved14 as * const _
                as usize } , 2304usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QSTAT0 as * const _ as
                usize } , 3072usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QSTAT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QSTAT1 as * const _ as
                usize } , 3080usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QSTAT1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved15 as * const _
                as usize } , 3088usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QWMTHRA as * const _ as
                usize } , 3136usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QWMTHRA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved16 as * const _
                as usize } , 3144usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . CCSTAT as * const _ as
                usize } , 3200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( CCSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved17 as * const _
                as usize } , 3208usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved17 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ER as * const _ as usize
                } , 8192usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved18 as * const _
                as usize } , 8200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved18 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ECR as * const _ as
                usize } , 8208usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ECR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved19 as * const _
                as usize } , 8216usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved19 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ESR as * const _ as
                usize } , 8224usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ESR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved20 as * const _
                as usize } , 8232usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved20 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . CER as * const _ as
                usize } , 8240usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( CER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved21 as * const _
                as usize } , 8248usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved21 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EER as * const _ as
                usize } , 8256usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved22 as * const _
                as usize } , 8264usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved22 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EECR as * const _ as
                usize } , 8272usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EECR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved23 as * const _
                as usize } , 8280usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved23 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EESR as * const _ as
                usize } , 8288usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EESR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved24 as * const _
                as usize } , 8296usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved24 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . SER as * const _ as
                usize } , 8304usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( SER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved25 as * const _
                as usize } , 8312usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved25 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . SECR as * const _ as
                usize } , 8320usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( SECR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved26 as * const _
                as usize } , 8328usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved26 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IER as * const _ as
                usize } , 8352usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved27 as * const _
                as usize } , 8360usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved27 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IECR as * const _ as
                usize } , 8368usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IECR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved28 as * const _
                as usize } , 8376usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved28 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IESR as * const _ as
                usize } , 8384usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IESR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved29 as * const _
                as usize } , 8392usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved29 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IPR as * const _ as
                usize } , 8400usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IPR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved30 as * const _
                as usize } , 8408usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved30 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ICR as * const _ as
                usize } , 8416usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ICR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved31 as * const _
                as usize } , 8424usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved31 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IEVAL as * const _ as
                usize } , 8432usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IEVAL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved32 as * const _
                as usize } , 8440usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QER as * const _ as
                usize } , 8448usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEER as * const _ as
                usize } , 8456usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEECR as * const _ as
                usize } , 8464usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEECR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEESR as * const _ as
                usize } , 8472usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEESR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QSER as * const _ as
                usize } , 8480usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QSER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QSECR as * const _ as
                usize } , 8488usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QSECR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved33 as * const _
                as usize } , 8496usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved33 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ER_S0 as * const _ as
                usize } , 16384usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ER_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved34 as * const _
                as usize } , 16392usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved34 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ECR_S0 as * const _ as
                usize } , 16400usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ECR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved35 as * const _
                as usize } , 16408usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved35 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ESR_S0 as * const _ as
                usize } , 16416usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ESR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved36 as * const _
                as usize } , 16424usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved36 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . CER_S0 as * const _ as
                usize } , 16432usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( CER_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved37 as * const _
                as usize } , 16440usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved37 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EER_S0 as * const _ as
                usize } , 16448usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EER_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved38 as * const _
                as usize } , 16456usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved38 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EECR_S0 as * const _ as
                usize } , 16464usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EECR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved39 as * const _
                as usize } , 16472usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved39 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EESR_S0 as * const _ as
                usize } , 16480usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EESR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved40 as * const _
                as usize } , 16488usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved40 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . SER_S0 as * const _ as
                usize } , 16496usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( SER_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved41 as * const _
                as usize } , 16504usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved41 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . SECR_S0 as * const _ as
                usize } , 16512usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( SECR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved42 as * const _
                as usize } , 16520usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved42 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IER_S0 as * const _ as
                usize } , 16544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IER_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved43 as * const _
                as usize } , 16552usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved43 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IECR_S0 as * const _ as
                usize } , 16560usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IECR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved44 as * const _
                as usize } , 16568usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved44 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IESR_S0 as * const _ as
                usize } , 16576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IESR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved45 as * const _
                as usize } , 16584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved45 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IPR_S0 as * const _ as
                usize } , 16592usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IPR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved46 as * const _
                as usize } , 16600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved46 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ICR_S0 as * const _ as
                usize } , 16608usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ICR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved47 as * const _
                as usize } , 16616usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved47 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IEVAL_S0 as * const _ as
                usize } , 16624usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IEVAL_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved48 as * const _
                as usize } , 16632usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved48 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QER_S0 as * const _ as
                usize } , 16640usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QER_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEER_S0 as * const _ as
                usize } , 16648usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEER_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEECR_S0 as * const _ as
                usize } , 16656usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEECR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEESR_S0 as * const _ as
                usize } , 16664usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEESR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QSER_S0 as * const _ as
                usize } , 16672usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QSER_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QSECR_S0 as * const _ as
                usize } , 16680usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QSECR_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved49 as * const _
                as usize } , 16688usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved49 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ER_S1 as * const _ as
                usize } , 17408usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ER_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved50 as * const _
                as usize } , 17416usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved50 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ECR_S1 as * const _ as
                usize } , 17424usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ECR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved51 as * const _
                as usize } , 17432usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved51 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ESR_S1 as * const _ as
                usize } , 17440usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ESR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved52 as * const _
                as usize } , 17448usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved52 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . CER_S1 as * const _ as
                usize } , 17456usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( CER_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved53 as * const _
                as usize } , 17464usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved53 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EER_S1 as * const _ as
                usize } , 17472usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EER_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved54 as * const _
                as usize } , 17480usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved54 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EECR_S1 as * const _ as
                usize } , 17488usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EECR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved55 as * const _
                as usize } , 17496usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved55 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . EESR_S1 as * const _ as
                usize } , 17504usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( EESR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved56 as * const _
                as usize } , 17512usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved56 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . SER_S1 as * const _ as
                usize } , 17520usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( SER_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved57 as * const _
                as usize } , 17528usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved57 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . SECR_S1 as * const _ as
                usize } , 17536usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( SECR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved58 as * const _
                as usize } , 17544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved58 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IER_S1 as * const _ as
                usize } , 17568usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IER_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved59 as * const _
                as usize } , 17576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved59 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IECR_S1 as * const _ as
                usize } , 17584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IECR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved60 as * const _
                as usize } , 17592usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved60 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IESR_S1 as * const _ as
                usize } , 17600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IESR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved61 as * const _
                as usize } , 17608usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved61 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IPR_S1 as * const _ as
                usize } , 17616usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IPR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved62 as * const _
                as usize } , 17624usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved62 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . ICR_S1 as * const _ as
                usize } , 17632usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( ICR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved63 as * const _
                as usize } , 17640usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved63 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . IEVAL_S1 as * const _ as
                usize } , 17648usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( IEVAL_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . Reserved64 as * const _
                as usize } , 17656usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( Reserved64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QER_S1 as * const _ as
                usize } , 17664usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QER_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEER_S1 as * const _ as
                usize } , 17672usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEER_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEECR_S1 as * const _ as
                usize } , 17680usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEECR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QEESR_S1 as * const _ as
                usize } , 17688usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QEESR_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QSER_S1 as * const _ as
                usize } , 17696usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QSER_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc ) ) . QSECR_S1 as * const _ as
                usize } , 17704usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc ) , "::" ,
                stringify ! ( QSECR_S1 ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_edma_cc_param {
    pub OPT: ::std::os::raw::c_ulong,
    pub SRC: ::std::os::raw::c_ulong,
    pub A_B_CNT: ::std::os::raw::c_ulong,
    pub DST: ::std::os::raw::c_ulong,
    pub SRC_DST_BIDX: ::std::os::raw::c_ulong,
    pub LINK_BCNTRLD: ::std::os::raw::c_ulong,
    pub SRC_DST_CIDX: ::std::os::raw::c_ulong,
    pub CCNT: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_edma_cc_param() {
    assert_eq!(::std::mem::size_of::<st_edma_cc_param>() , 64usize , concat !
               ( "Size of: " , stringify ! ( st_edma_cc_param ) ));
    assert_eq! (::std::mem::align_of::<st_edma_cc_param>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( st_edma_cc_param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc_param ) ) . OPT as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc_param ) ,
                "::" , stringify ! ( OPT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc_param ) ) . SRC as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc_param ) ,
                "::" , stringify ! ( SRC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc_param ) ) . A_B_CNT as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc_param ) ,
                "::" , stringify ! ( A_B_CNT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc_param ) ) . DST as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc_param ) ,
                "::" , stringify ! ( DST ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc_param ) ) . SRC_DST_BIDX as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc_param ) ,
                "::" , stringify ! ( SRC_DST_BIDX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc_param ) ) . LINK_BCNTRLD as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc_param ) ,
                "::" , stringify ! ( LINK_BCNTRLD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc_param ) ) . SRC_DST_CIDX as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc_param ) ,
                "::" , stringify ! ( SRC_DST_CIDX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_cc_param ) ) . CCNT as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_cc_param ) ,
                "::" , stringify ! ( CCNT ) ));
}
impl Clone for st_edma_cc_param {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct st_edma_tc {
    pub REVID: ::std::os::raw::c_ulong,
    pub TCCFG: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 62usize],
    pub TCSTAT: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 7usize],
    pub ERRSTAT: ::std::os::raw::c_ulong,
    pub ERREN: ::std::os::raw::c_ulong,
    pub ERRCLR: ::std::os::raw::c_ulong,
    pub ERRDET: ::std::os::raw::c_ulong,
    pub ERRCMD: ::std::os::raw::c_ulong,
    pub Reserved3: [::std::os::raw::c_ulong; 3usize],
    pub RDRATE: ::std::os::raw::c_ulong,
    pub Reserved4: [::std::os::raw::c_ulong; 63usize],
    pub SAOPT: ::std::os::raw::c_ulong,
    pub SASRC: ::std::os::raw::c_ulong,
    pub SACNT: ::std::os::raw::c_ulong,
    pub SADST: ::std::os::raw::c_ulong,
    pub SABIDX: ::std::os::raw::c_ulong,
    pub SAMPPRXY: ::std::os::raw::c_ulong,
    pub SACNTRLD: ::std::os::raw::c_ulong,
    pub SASRCBREF: ::std::os::raw::c_ulong,
    pub SADSTBREF: ::std::os::raw::c_ulong,
    pub Reserved5: [::std::os::raw::c_ulong; 7usize],
    pub DFCNTRLD: ::std::os::raw::c_ulong,
    pub DFSRCBREF: ::std::os::raw::c_ulong,
    pub DFDSTBREF: ::std::os::raw::c_ulong,
    pub Reserved6: [::std::os::raw::c_ulong; 29usize],
    pub DFOPT0: ::std::os::raw::c_ulong,
    pub DFSRC0: ::std::os::raw::c_ulong,
    pub DFCNT0: ::std::os::raw::c_ulong,
    pub DFDST0: ::std::os::raw::c_ulong,
    pub DFBIDX0: ::std::os::raw::c_ulong,
    pub DFMPPRXY0: ::std::os::raw::c_ulong,
    pub Reserved7: [::std::os::raw::c_ulong; 10usize],
    pub DFOPT1: ::std::os::raw::c_ulong,
    pub DFSRC1: ::std::os::raw::c_ulong,
    pub DFCNT1: ::std::os::raw::c_ulong,
    pub DFDST1: ::std::os::raw::c_ulong,
    pub DFBIDX1: ::std::os::raw::c_ulong,
    pub DFMPPRXY1: ::std::os::raw::c_ulong,
    pub Reserved8: [::std::os::raw::c_ulong; 10usize],
    pub DFOPT2: ::std::os::raw::c_ulong,
    pub DFSRC2: ::std::os::raw::c_ulong,
    pub DFCNT2: ::std::os::raw::c_ulong,
    pub DFDST2: ::std::os::raw::c_ulong,
    pub DFBIDX2: ::std::os::raw::c_ulong,
    pub DFMPPRXY2: ::std::os::raw::c_ulong,
    pub Reserved9: [::std::os::raw::c_ulong; 10usize],
    pub DFOPT3: ::std::os::raw::c_ulong,
    pub DFSRC3: ::std::os::raw::c_ulong,
    pub DFCNT3: ::std::os::raw::c_ulong,
    pub DFDST3: ::std::os::raw::c_ulong,
    pub DFBIDX3: ::std::os::raw::c_ulong,
    pub DFMPPRXY3: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_edma_tc() {
    assert_eq!(::std::mem::size_of::<st_edma_tc>() , 1968usize , concat ! (
               "Size of: " , stringify ! ( st_edma_tc ) ));
    assert_eq! (::std::mem::align_of::<st_edma_tc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_edma_tc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . REVID as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . TCCFG as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( TCCFG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved1 as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . TCSTAT as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( TCSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved2 as * const _
                as usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . ERRSTAT as * const _ as
                usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( ERRSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . ERREN as * const _ as
                usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( ERREN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . ERRCLR as * const _ as
                usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( ERRCLR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . ERRDET as * const _ as
                usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( ERRDET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . ERRCMD as * const _ as
                usize } , 608usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( ERRCMD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved3 as * const _
                as usize } , 616usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . RDRATE as * const _ as
                usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( RDRATE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved4 as * const _
                as usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SAOPT as * const _ as
                usize } , 1152usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SAOPT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SASRC as * const _ as
                usize } , 1160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SASRC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SACNT as * const _ as
                usize } , 1168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SACNT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SADST as * const _ as
                usize } , 1176usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SADST ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SABIDX as * const _ as
                usize } , 1184usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SABIDX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SAMPPRXY as * const _ as
                usize } , 1192usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SAMPPRXY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SACNTRLD as * const _ as
                usize } , 1200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SACNTRLD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SASRCBREF as * const _
                as usize } , 1208usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SASRCBREF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . SADSTBREF as * const _
                as usize } , 1216usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( SADSTBREF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved5 as * const _
                as usize } , 1224usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFCNTRLD as * const _ as
                usize } , 1280usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFCNTRLD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFSRCBREF as * const _
                as usize } , 1288usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFSRCBREF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFDSTBREF as * const _
                as usize } , 1296usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFDSTBREF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved6 as * const _
                as usize } , 1304usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFOPT0 as * const _ as
                usize } , 1536usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFOPT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFSRC0 as * const _ as
                usize } , 1544usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFSRC0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFCNT0 as * const _ as
                usize } , 1552usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFCNT0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFDST0 as * const _ as
                usize } , 1560usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFDST0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFBIDX0 as * const _ as
                usize } , 1568usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFBIDX0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFMPPRXY0 as * const _
                as usize } , 1576usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFMPPRXY0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved7 as * const _
                as usize } , 1584usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFOPT1 as * const _ as
                usize } , 1664usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFOPT1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFSRC1 as * const _ as
                usize } , 1672usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFSRC1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFCNT1 as * const _ as
                usize } , 1680usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFCNT1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFDST1 as * const _ as
                usize } , 1688usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFDST1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFBIDX1 as * const _ as
                usize } , 1696usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFBIDX1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFMPPRXY1 as * const _
                as usize } , 1704usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFMPPRXY1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved8 as * const _
                as usize } , 1712usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFOPT2 as * const _ as
                usize } , 1792usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFOPT2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFSRC2 as * const _ as
                usize } , 1800usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFSRC2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFCNT2 as * const _ as
                usize } , 1808usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFCNT2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFDST2 as * const _ as
                usize } , 1816usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFDST2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFBIDX2 as * const _ as
                usize } , 1824usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFBIDX2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFMPPRXY2 as * const _
                as usize } , 1832usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFMPPRXY2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . Reserved9 as * const _
                as usize } , 1840usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( Reserved9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFOPT3 as * const _ as
                usize } , 1920usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFOPT3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFSRC3 as * const _ as
                usize } , 1928usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFSRC3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFCNT3 as * const _ as
                usize } , 1936usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFCNT3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFDST3 as * const _ as
                usize } , 1944usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFDST3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFBIDX3 as * const _ as
                usize } , 1952usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFBIDX3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_edma_tc ) ) . DFMPPRXY3 as * const _
                as usize } , 1960usize , concat ! (
                "Alignment of field: " , stringify ! ( st_edma_tc ) , "::" ,
                stringify ! ( DFMPPRXY3 ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_timer {
    pub REVID: ::std::os::raw::c_ulong,
    pub EMUMGT: ::std::os::raw::c_ulong,
    pub GPINTGPEN: ::std::os::raw::c_ulong,
    pub GPDATGPDIR: ::std::os::raw::c_ulong,
    pub TIM12: ::std::os::raw::c_ulong,
    pub TIM34: ::std::os::raw::c_ulong,
    pub PRD12: ::std::os::raw::c_ulong,
    pub PRD34: ::std::os::raw::c_ulong,
    pub TCR: ::std::os::raw::c_ulong,
    pub TGCR: ::std::os::raw::c_ulong,
    pub WDTCR: ::std::os::raw::c_ulong,
    pub Reserved1: [::std::os::raw::c_ulong; 2usize],
    pub REL12: ::std::os::raw::c_ulong,
    pub REL34: ::std::os::raw::c_ulong,
    pub CAP12: ::std::os::raw::c_ulong,
    pub CAP34: ::std::os::raw::c_ulong,
    pub INTCTLSTAT: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 6usize],
    pub CMP0: ::std::os::raw::c_ulong,
    pub CMP1: ::std::os::raw::c_ulong,
    pub CMP2: ::std::os::raw::c_ulong,
    pub CMP3: ::std::os::raw::c_ulong,
    pub CMP4: ::std::os::raw::c_ulong,
    pub CMP5: ::std::os::raw::c_ulong,
    pub CMP6: ::std::os::raw::c_ulong,
    pub CMP7: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_timer() {
    assert_eq!(::std::mem::size_of::<st_timer>() , 256usize , concat ! (
               "Size of: " , stringify ! ( st_timer ) ));
    assert_eq! (::std::mem::align_of::<st_timer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . REVID as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( REVID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . EMUMGT as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( EMUMGT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . GPINTGPEN as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( GPINTGPEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . GPDATGPDIR as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( GPDATGPDIR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . TIM12 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( TIM12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . TIM34 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( TIM34 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . PRD12 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( PRD12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . PRD34 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( PRD34 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . TCR as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( TCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . TGCR as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( TGCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . WDTCR as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( WDTCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . Reserved1 as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . REL12 as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( REL12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . REL34 as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( REL34 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CAP12 as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CAP12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CAP34 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CAP34 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . INTCTLSTAT as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( INTCTLSTAT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . Reserved2 as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CMP0 as * const _ as usize
                } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CMP0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CMP1 as * const _ as usize
                } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CMP1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CMP2 as * const _ as usize
                } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CMP2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CMP3 as * const _ as usize
                } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CMP3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CMP4 as * const _ as usize
                } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CMP4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CMP5 as * const _ as usize
                } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CMP5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CMP6 as * const _ as usize
                } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CMP6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_timer ) ) . CMP7 as * const _ as usize
                } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( st_timer ) , "::" ,
                stringify ! ( CMP7 ) ));
}
impl Clone for st_timer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mmcsd {
    pub MMCCTL: ::std::os::raw::c_ulong,
    pub MMCCLK: ::std::os::raw::c_ulong,
    pub MMCST0: ::std::os::raw::c_ulong,
    pub MMCST1: ::std::os::raw::c_ulong,
    pub MMCIM: ::std::os::raw::c_ulong,
    pub MMCTOR: ::std::os::raw::c_ulong,
    pub MMCTOD: ::std::os::raw::c_ulong,
    pub MMCBLEN: ::std::os::raw::c_ulong,
    pub MMCNBLK: ::std::os::raw::c_ulong,
    pub MMCNBLC: ::std::os::raw::c_ulong,
    pub MMCDRR: ::std::os::raw::c_ulong,
    pub MMCDXR: ::std::os::raw::c_ulong,
    pub MMCCMD: ::std::os::raw::c_ulong,
    pub MMCARGHL: ::std::os::raw::c_ulong,
    pub MMCRSP01: ::std::os::raw::c_ulong,
    pub MMCRSP23: ::std::os::raw::c_ulong,
    pub MMCRSP45: ::std::os::raw::c_ulong,
    pub MMCRSP67: ::std::os::raw::c_ulong,
    pub MMCDRSP: ::std::os::raw::c_ulong,
    pub Reserved1: ::std::os::raw::c_ulong,
    pub MMCCIDX: ::std::os::raw::c_ulong,
    pub Reserved2: [::std::os::raw::c_ulong; 4usize],
    pub SDIOCTL: ::std::os::raw::c_ulong,
    pub SDIOST0: ::std::os::raw::c_ulong,
    pub SDIOIEN: ::std::os::raw::c_ulong,
    pub SDIOIST: ::std::os::raw::c_ulong,
    pub MMCFIFOCTL: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_mmcsd() {
    assert_eq!(::std::mem::size_of::<st_mmcsd>() , 240usize , concat ! (
               "Size of: " , stringify ! ( st_mmcsd ) ));
    assert_eq! (::std::mem::align_of::<st_mmcsd>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_mmcsd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCCTL as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCCTL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCCLK as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCCLK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCST0 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCST0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCST1 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCST1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCIM as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCIM ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCTOR as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCTOR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCTOD as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCTOD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCBLEN as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCBLEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCNBLK as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCNBLK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCNBLC as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCNBLC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCDRR as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCDRR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCDXR as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCDXR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCCMD as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCCMD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCARGHL as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCARGHL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCRSP01 as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCRSP01 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCRSP23 as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCRSP23 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCRSP45 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCRSP45 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCRSP67 as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCRSP67 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCDRSP as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCDRSP ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . Reserved1 as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( Reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCCIDX as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCCIDX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . Reserved2 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( Reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . SDIOCTL as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( SDIOCTL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . SDIOST0 as * const _ as
                usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( SDIOST0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . SDIOIEN as * const _ as
                usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( SDIOIEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . SDIOIST as * const _ as
                usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( SDIOIST ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mmcsd ) ) . MMCFIFOCTL as * const _ as
                usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mmcsd ) , "::" ,
                stringify ! ( MMCFIFOCTL ) ));
}
impl Clone for st_mmcsd {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_ecap {
    pub TSCTR: u32,
    pub CTRPHS: u32,
    pub CAP1: u32,
    pub CAP2: u32,
    pub CAP3: u32,
    pub CAP4: u32,
    pub Rev0: [u8; 16usize],
    pub ECCTL1: u16,
    pub ECCTL2: u16,
    pub ECEINT: u16,
    pub ECFLG: u16,
    pub ECCLR: u16,
    pub ECFRC: u16,
}
#[test]
fn bindgen_test_layout_st_ecap() {
    assert_eq!(::std::mem::size_of::<st_ecap>() , 52usize , concat ! (
               "Size of: " , stringify ! ( st_ecap ) ));
    assert_eq! (::std::mem::align_of::<st_ecap>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( st_ecap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . TSCTR as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( TSCTR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . CTRPHS as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( CTRPHS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . CAP1 as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( CAP1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . CAP2 as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( CAP2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . CAP3 as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( CAP3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . CAP4 as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( CAP4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . Rev0 as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( Rev0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . ECCTL1 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( ECCTL1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . ECCTL2 as * const _ as
                usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( ECCTL2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . ECEINT as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( ECEINT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . ECFLG as * const _ as usize
                } , 46usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( ECFLG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . ECCLR as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( ECCLR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_ecap ) ) . ECFRC as * const _ as usize
                } , 50usize , concat ! (
                "Alignment of field: " , stringify ! ( st_ecap ) , "::" ,
                stringify ! ( ECFRC ) ));
}
impl Clone for st_ecap {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn mmu_init();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct exc_frame_t {
    pub excno: u32,
    pub nest_count: u32,
    pub ipm: u32,
    pub r0: u32,
    pub r1: u32,
    pub r2: u32,
    pub r3: u32,
    pub r12: u32,
    pub lr: u32,
    pub pc: u32,
    pub cpsr: u32,
}
#[test]
fn bindgen_test_layout_exc_frame_t() {
    assert_eq!(::std::mem::size_of::<exc_frame_t>() , 44usize , concat ! (
               "Size of: " , stringify ! ( exc_frame_t ) ));
    assert_eq! (::std::mem::align_of::<exc_frame_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( exc_frame_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . excno as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( excno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . nest_count as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( nest_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . ipm as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( ipm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . r0 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( r0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . r1 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( r1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . r2 as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( r2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . r3 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( r3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . r12 as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . lr as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( lr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . pc as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( pc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exc_frame_t ) ) . cpsr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( exc_frame_t ) , "::" ,
                stringify ! ( cpsr ) ));
}
impl Clone for exc_frame_t {
    fn clone(&self) -> Self { *self }
}
pub type TEXPTN = uint_t;
pub type FLGPTN = uint_t;
pub type OVRTIM = ulong_t;
pub type INTNO = uint_t;
pub type INHNO = uint_t;
pub type EXCNO = uint_t;
pub type TASK = ::std::option::Option<unsafe extern "C" fn(exinf: isize)>;
pub type TEXRTN =
    ::std::option::Option<unsafe extern "C" fn(texptn: TEXPTN, exinf: isize)>;
pub type CYCHDR = ::std::option::Option<unsafe extern "C" fn(exinf: isize)>;
pub type ALMHDR = ::std::option::Option<unsafe extern "C" fn(exinf: isize)>;
pub type OVRHDR =
    ::std::option::Option<unsafe extern "C" fn(tskid: ID, exinf: isize)>;
pub type ISR = ::std::option::Option<unsafe extern "C" fn(exinf: isize)>;
pub type INTHDR = ::std::option::Option<unsafe extern "C" fn()>;
pub type EXCHDR =
    ::std::option::Option<unsafe extern "C" fn(p_excinf:
                                                   *mut ::std::os::raw::c_void)>;
pub type EXTSVC =
    ::std::option::Option<unsafe extern "C" fn(par1: isize, par2: isize,
                                               par3: isize, par4: isize,
                                               par5: isize, cdmid: ID)
                              -> ER_UINT>;
pub type INIRTN = ::std::option::Option<unsafe extern "C" fn(exinf: isize)>;
pub type TERRTN = ::std::option::Option<unsafe extern "C" fn(exinf: isize)>;
pub type STK_T = ::std::os::raw::c_longlong;
pub type MPF_T = isize;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_ctsk {
    pub tskatr: ATR,
    pub exinf: isize,
    pub task: TASK,
    pub itskpri: PRI,
    pub stksz: SIZE,
    pub stk: *mut STK_T,
    pub sstksz: SIZE,
    pub sstk: *mut STK_T,
}
#[test]
fn bindgen_test_layout_t_ctsk() {
    assert_eq!(::std::mem::size_of::<t_ctsk>() , 64usize , concat ! (
               "Size of: " , stringify ! ( t_ctsk ) ));
    assert_eq! (::std::mem::align_of::<t_ctsk>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_ctsk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ctsk ) ) . tskatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ctsk ) , "::" ,
                stringify ! ( tskatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ctsk ) ) . exinf as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ctsk ) , "::" ,
                stringify ! ( exinf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ctsk ) ) . task as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ctsk ) , "::" ,
                stringify ! ( task ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ctsk ) ) . itskpri as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ctsk ) , "::" ,
                stringify ! ( itskpri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ctsk ) ) . stksz as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ctsk ) , "::" ,
                stringify ! ( stksz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ctsk ) ) . stk as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ctsk ) , "::" ,
                stringify ! ( stk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ctsk ) ) . sstksz as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ctsk ) , "::" ,
                stringify ! ( sstksz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ctsk ) ) . sstk as * const _ as usize }
                , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ctsk ) , "::" ,
                stringify ! ( sstk ) ));
}
impl Clone for t_ctsk {
    fn clone(&self) -> Self { *self }
}
pub type T_CTSK = t_ctsk;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rtsk {
    pub tskstat: STAT,
    pub tskpri: PRI,
    pub tskbpri: PRI,
    pub tskwait: STAT,
    pub wobjid: ID,
    pub lefttmo: TMO,
    pub actcnt: uint_t,
    pub wupcnt: uint_t,
    pub texmsk: bool_t,
    pub waifbd: bool_t,
    pub svclevel: uint_t,
}
#[test]
fn bindgen_test_layout_t_rtsk() {
    assert_eq!(::std::mem::size_of::<t_rtsk>() , 44usize , concat ! (
               "Size of: " , stringify ! ( t_rtsk ) ));
    assert_eq! (::std::mem::align_of::<t_rtsk>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rtsk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . tskstat as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( tskstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . tskpri as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( tskpri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . tskbpri as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( tskbpri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . tskwait as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( tskwait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . wobjid as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( wobjid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . lefttmo as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( lefttmo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . actcnt as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( actcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . wupcnt as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( wupcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . texmsk as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( texmsk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . waifbd as * const _ as usize
                } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( waifbd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtsk ) ) . svclevel as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtsk ) , "::" ,
                stringify ! ( svclevel ) ));
}
impl Clone for t_rtsk {
    fn clone(&self) -> Self { *self }
}
pub type T_RTSK = t_rtsk;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_dtex {
    pub texatr: ATR,
    pub texrtn: TEXRTN,
}
#[test]
fn bindgen_test_layout_t_dtex() {
    assert_eq!(::std::mem::size_of::<t_dtex>() , 16usize , concat ! (
               "Size of: " , stringify ! ( t_dtex ) ));
    assert_eq! (::std::mem::align_of::<t_dtex>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_dtex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_dtex ) ) . texatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_dtex ) , "::" ,
                stringify ! ( texatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_dtex ) ) . texrtn as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_dtex ) , "::" ,
                stringify ! ( texrtn ) ));
}
impl Clone for t_dtex {
    fn clone(&self) -> Self { *self }
}
pub type T_DTEX = t_dtex;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rtex {
    pub texstat: STAT,
    pub pndptn: TEXPTN,
}
#[test]
fn bindgen_test_layout_t_rtex() {
    assert_eq!(::std::mem::size_of::<t_rtex>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_rtex ) ));
    assert_eq! (::std::mem::align_of::<t_rtex>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rtex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtex ) ) . texstat as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtex ) , "::" ,
                stringify ! ( texstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rtex ) ) . pndptn as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rtex ) , "::" ,
                stringify ! ( pndptn ) ));
}
impl Clone for t_rtex {
    fn clone(&self) -> Self { *self }
}
pub type T_RTEX = t_rtex;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_csem {
    pub sematr: ATR,
    pub isemcnt: uint_t,
    pub maxsem: uint_t,
}
#[test]
fn bindgen_test_layout_t_csem() {
    assert_eq!(::std::mem::size_of::<t_csem>() , 12usize , concat ! (
               "Size of: " , stringify ! ( t_csem ) ));
    assert_eq! (::std::mem::align_of::<t_csem>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_csem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_csem ) ) . sematr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_csem ) , "::" ,
                stringify ! ( sematr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_csem ) ) . isemcnt as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_csem ) , "::" ,
                stringify ! ( isemcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_csem ) ) . maxsem as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_csem ) , "::" ,
                stringify ! ( maxsem ) ));
}
impl Clone for t_csem {
    fn clone(&self) -> Self { *self }
}
pub type T_CSEM = t_csem;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rsem {
    pub wtskid: ID,
    pub semcnt: uint_t,
}
#[test]
fn bindgen_test_layout_t_rsem() {
    assert_eq!(::std::mem::size_of::<t_rsem>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_rsem ) ));
    assert_eq! (::std::mem::align_of::<t_rsem>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rsem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rsem ) ) . wtskid as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rsem ) , "::" ,
                stringify ! ( wtskid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rsem ) ) . semcnt as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rsem ) , "::" ,
                stringify ! ( semcnt ) ));
}
impl Clone for t_rsem {
    fn clone(&self) -> Self { *self }
}
pub type T_RSEM = t_rsem;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_cflg {
    pub flgatr: ATR,
    pub iflgptn: FLGPTN,
}
#[test]
fn bindgen_test_layout_t_cflg() {
    assert_eq!(::std::mem::size_of::<t_cflg>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_cflg ) ));
    assert_eq! (::std::mem::align_of::<t_cflg>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_cflg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cflg ) ) . flgatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cflg ) , "::" ,
                stringify ! ( flgatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cflg ) ) . iflgptn as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cflg ) , "::" ,
                stringify ! ( iflgptn ) ));
}
impl Clone for t_cflg {
    fn clone(&self) -> Self { *self }
}
pub type T_CFLG = t_cflg;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rflg {
    pub wtskid: ID,
    pub flgptn: FLGPTN,
}
#[test]
fn bindgen_test_layout_t_rflg() {
    assert_eq!(::std::mem::size_of::<t_rflg>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_rflg ) ));
    assert_eq! (::std::mem::align_of::<t_rflg>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rflg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rflg ) ) . wtskid as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rflg ) , "::" ,
                stringify ! ( wtskid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rflg ) ) . flgptn as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rflg ) , "::" ,
                stringify ! ( flgptn ) ));
}
impl Clone for t_rflg {
    fn clone(&self) -> Self { *self }
}
pub type T_RFLG = t_rflg;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_cdtq {
    pub dtqatr: ATR,
    pub dtqcnt: uint_t,
    pub dtqmb: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_t_cdtq() {
    assert_eq!(::std::mem::size_of::<t_cdtq>() , 16usize , concat ! (
               "Size of: " , stringify ! ( t_cdtq ) ));
    assert_eq! (::std::mem::align_of::<t_cdtq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_cdtq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cdtq ) ) . dtqatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cdtq ) , "::" ,
                stringify ! ( dtqatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cdtq ) ) . dtqcnt as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cdtq ) , "::" ,
                stringify ! ( dtqcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cdtq ) ) . dtqmb as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cdtq ) , "::" ,
                stringify ! ( dtqmb ) ));
}
impl Clone for t_cdtq {
    fn clone(&self) -> Self { *self }
}
pub type T_CDTQ = t_cdtq;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rdtq {
    pub stskid: ID,
    pub rtskid: ID,
    pub sdtqcnt: uint_t,
}
#[test]
fn bindgen_test_layout_t_rdtq() {
    assert_eq!(::std::mem::size_of::<t_rdtq>() , 12usize , concat ! (
               "Size of: " , stringify ! ( t_rdtq ) ));
    assert_eq! (::std::mem::align_of::<t_rdtq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rdtq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rdtq ) ) . stskid as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rdtq ) , "::" ,
                stringify ! ( stskid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rdtq ) ) . rtskid as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rdtq ) , "::" ,
                stringify ! ( rtskid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rdtq ) ) . sdtqcnt as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rdtq ) , "::" ,
                stringify ! ( sdtqcnt ) ));
}
impl Clone for t_rdtq {
    fn clone(&self) -> Self { *self }
}
pub type T_RDTQ = t_rdtq;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_cpdq {
    pub pdqatr: ATR,
    pub pdqcnt: uint_t,
    pub maxdpri: PRI,
    pub pdqmb: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_t_cpdq() {
    assert_eq!(::std::mem::size_of::<t_cpdq>() , 24usize , concat ! (
               "Size of: " , stringify ! ( t_cpdq ) ));
    assert_eq! (::std::mem::align_of::<t_cpdq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_cpdq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cpdq ) ) . pdqatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cpdq ) , "::" ,
                stringify ! ( pdqatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cpdq ) ) . pdqcnt as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cpdq ) , "::" ,
                stringify ! ( pdqcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cpdq ) ) . maxdpri as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cpdq ) , "::" ,
                stringify ! ( maxdpri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cpdq ) ) . pdqmb as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cpdq ) , "::" ,
                stringify ! ( pdqmb ) ));
}
impl Clone for t_cpdq {
    fn clone(&self) -> Self { *self }
}
pub type T_CPDQ = t_cpdq;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rpdq {
    pub stskid: ID,
    pub rtskid: ID,
    pub spdqcnt: uint_t,
}
#[test]
fn bindgen_test_layout_t_rpdq() {
    assert_eq!(::std::mem::size_of::<t_rpdq>() , 12usize , concat ! (
               "Size of: " , stringify ! ( t_rpdq ) ));
    assert_eq! (::std::mem::align_of::<t_rpdq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rpdq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rpdq ) ) . stskid as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rpdq ) , "::" ,
                stringify ! ( stskid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rpdq ) ) . rtskid as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rpdq ) , "::" ,
                stringify ! ( rtskid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rpdq ) ) . spdqcnt as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rpdq ) , "::" ,
                stringify ! ( spdqcnt ) ));
}
impl Clone for t_rpdq {
    fn clone(&self) -> Self { *self }
}
pub type T_RPDQ = t_rpdq;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_cmtx {
    pub mtxatr: ATR,
    pub ceilpri: PRI,
}
#[test]
fn bindgen_test_layout_t_cmtx() {
    assert_eq!(::std::mem::size_of::<t_cmtx>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_cmtx ) ));
    assert_eq! (::std::mem::align_of::<t_cmtx>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_cmtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cmtx ) ) . mtxatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cmtx ) , "::" ,
                stringify ! ( mtxatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cmtx ) ) . ceilpri as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cmtx ) , "::" ,
                stringify ! ( ceilpri ) ));
}
impl Clone for t_cmtx {
    fn clone(&self) -> Self { *self }
}
pub type T_CMTX = t_cmtx;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rmtx {
    pub htskid: ID,
    pub wtskid: ID,
}
#[test]
fn bindgen_test_layout_t_rmtx() {
    assert_eq!(::std::mem::size_of::<t_rmtx>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_rmtx ) ));
    assert_eq! (::std::mem::align_of::<t_rmtx>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rmtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rmtx ) ) . htskid as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rmtx ) , "::" ,
                stringify ! ( htskid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rmtx ) ) . wtskid as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rmtx ) , "::" ,
                stringify ! ( wtskid ) ));
}
impl Clone for t_rmtx {
    fn clone(&self) -> Self { *self }
}
pub type T_RMTX = t_rmtx;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_cmpf {
    pub mpfatr: ATR,
    pub blkcnt: uint_t,
    pub blksz: uint_t,
    pub mpf: *mut MPF_T,
    pub mpfmb: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_t_cmpf() {
    assert_eq!(::std::mem::size_of::<t_cmpf>() , 32usize , concat ! (
               "Size of: " , stringify ! ( t_cmpf ) ));
    assert_eq! (::std::mem::align_of::<t_cmpf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_cmpf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cmpf ) ) . mpfatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cmpf ) , "::" ,
                stringify ! ( mpfatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cmpf ) ) . blkcnt as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cmpf ) , "::" ,
                stringify ! ( blkcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cmpf ) ) . blksz as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cmpf ) , "::" ,
                stringify ! ( blksz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cmpf ) ) . mpf as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cmpf ) , "::" ,
                stringify ! ( mpf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cmpf ) ) . mpfmb as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cmpf ) , "::" ,
                stringify ! ( mpfmb ) ));
}
impl Clone for t_cmpf {
    fn clone(&self) -> Self { *self }
}
pub type T_CMPF = t_cmpf;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rmpf {
    pub wtskid: ID,
    pub fblkcnt: uint_t,
}
#[test]
fn bindgen_test_layout_t_rmpf() {
    assert_eq!(::std::mem::size_of::<t_rmpf>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_rmpf ) ));
    assert_eq! (::std::mem::align_of::<t_rmpf>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rmpf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rmpf ) ) . wtskid as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rmpf ) , "::" ,
                stringify ! ( wtskid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rmpf ) ) . fblkcnt as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rmpf ) , "::" ,
                stringify ! ( fblkcnt ) ));
}
impl Clone for t_rmpf {
    fn clone(&self) -> Self { *self }
}
pub type T_RMPF = t_rmpf;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_ccyc {
    pub cycatr: ATR,
    pub exinf: isize,
    pub cychdr: CYCHDR,
    pub cyctim: RELTIM,
    pub cycphs: RELTIM,
}
#[test]
fn bindgen_test_layout_t_ccyc() {
    assert_eq!(::std::mem::size_of::<t_ccyc>() , 32usize , concat ! (
               "Size of: " , stringify ! ( t_ccyc ) ));
    assert_eq! (::std::mem::align_of::<t_ccyc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_ccyc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ccyc ) ) . cycatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ccyc ) , "::" ,
                stringify ! ( cycatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ccyc ) ) . exinf as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ccyc ) , "::" ,
                stringify ! ( exinf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ccyc ) ) . cychdr as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ccyc ) , "::" ,
                stringify ! ( cychdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ccyc ) ) . cyctim as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ccyc ) , "::" ,
                stringify ! ( cyctim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ccyc ) ) . cycphs as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ccyc ) , "::" ,
                stringify ! ( cycphs ) ));
}
impl Clone for t_ccyc {
    fn clone(&self) -> Self { *self }
}
pub type T_CCYC = t_ccyc;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rcyc {
    pub cycstat: STAT,
    pub lefttim: RELTIM,
}
#[test]
fn bindgen_test_layout_t_rcyc() {
    assert_eq!(::std::mem::size_of::<t_rcyc>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_rcyc ) ));
    assert_eq! (::std::mem::align_of::<t_rcyc>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_rcyc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rcyc ) ) . cycstat as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rcyc ) , "::" ,
                stringify ! ( cycstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rcyc ) ) . lefttim as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rcyc ) , "::" ,
                stringify ! ( lefttim ) ));
}
impl Clone for t_rcyc {
    fn clone(&self) -> Self { *self }
}
pub type T_RCYC = t_rcyc;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_calm {
    pub almatr: ATR,
    pub exinf: isize,
    pub almhdr: ALMHDR,
}
#[test]
fn bindgen_test_layout_t_calm() {
    assert_eq!(::std::mem::size_of::<t_calm>() , 24usize , concat ! (
               "Size of: " , stringify ! ( t_calm ) ));
    assert_eq! (::std::mem::align_of::<t_calm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_calm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_calm ) ) . almatr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_calm ) , "::" ,
                stringify ! ( almatr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_calm ) ) . exinf as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_calm ) , "::" ,
                stringify ! ( exinf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_calm ) ) . almhdr as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( t_calm ) , "::" ,
                stringify ! ( almhdr ) ));
}
impl Clone for t_calm {
    fn clone(&self) -> Self { *self }
}
pub type T_CALM = t_calm;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_ralm {
    pub almstat: STAT,
    pub lefttim: RELTIM,
}
#[test]
fn bindgen_test_layout_t_ralm() {
    assert_eq!(::std::mem::size_of::<t_ralm>() , 8usize , concat ! (
               "Size of: " , stringify ! ( t_ralm ) ));
    assert_eq! (::std::mem::align_of::<t_ralm>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_ralm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ralm ) ) . almstat as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ralm ) , "::" ,
                stringify ! ( almstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_ralm ) ) . lefttim as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_ralm ) , "::" ,
                stringify ! ( lefttim ) ));
}
impl Clone for t_ralm {
    fn clone(&self) -> Self { *self }
}
pub type T_RALM = t_ralm;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_rovr {
    pub ovrstat: STAT,
    pub leftotm: OVRTIM,
}
#[test]
fn bindgen_test_layout_t_rovr() {
    assert_eq!(::std::mem::size_of::<t_rovr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( t_rovr ) ));
    assert_eq! (::std::mem::align_of::<t_rovr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_rovr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rovr ) ) . ovrstat as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rovr ) , "::" ,
                stringify ! ( ovrstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_rovr ) ) . leftotm as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_rovr ) , "::" ,
                stringify ! ( leftotm ) ));
}
impl Clone for t_rovr {
    fn clone(&self) -> Self { *self }
}
pub type T_ROVR = t_rovr;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_cisr {
    pub isratr: ATR,
    pub exinf: isize,
    pub intno: INTNO,
    pub isr: ISR,
    pub isrpri: PRI,
}
#[test]
fn bindgen_test_layout_t_cisr() {
    assert_eq!(::std::mem::size_of::<t_cisr>() , 40usize , concat ! (
               "Size of: " , stringify ! ( t_cisr ) ));
    assert_eq! (::std::mem::align_of::<t_cisr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( t_cisr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cisr ) ) . isratr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cisr ) , "::" ,
                stringify ! ( isratr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cisr ) ) . exinf as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cisr ) , "::" ,
                stringify ! ( exinf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cisr ) ) . intno as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cisr ) , "::" ,
                stringify ! ( intno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cisr ) ) . isr as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cisr ) , "::" ,
                stringify ! ( isr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_cisr ) ) . isrpri as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( t_cisr ) , "::" ,
                stringify ! ( isrpri ) ));
}
impl Clone for t_cisr {
    fn clone(&self) -> Self { *self }
}
pub type T_CISR = t_cisr;
extern "C" {
    pub fn _kernel_act_tsk(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_iact_tsk(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_can_act(tskid: ID) -> ER_UINT;
}
extern "C" {
    pub fn _kernel_ext_tsk() -> ER;
}
extern "C" {
    pub fn _kernel_ter_tsk(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_chg_pri(tskid: ID, tskpri: PRI) -> ER;
}
extern "C" {
    pub fn _kernel_get_pri(tskid: ID, p_tskpri: *mut PRI) -> ER;
}
extern "C" {
    pub fn _kernel_get_inf(p_exinf: *mut isize) -> ER;
}
extern "C" {
    pub fn _kernel_slp_tsk() -> ER;
}
extern "C" {
    pub fn _kernel_tslp_tsk(tmout: TMO) -> ER;
}
extern "C" {
    pub fn _kernel_wup_tsk(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_iwup_tsk(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_can_wup(tskid: ID) -> ER_UINT;
}
extern "C" {
    pub fn _kernel_rel_wai(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_irel_wai(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_dis_wai(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_idis_wai(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_ena_wai(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_iena_wai(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_sus_tsk(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_rsm_tsk(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_dly_tsk(dlytim: RELTIM) -> ER;
}
extern "C" {
    pub fn _kernel_ras_tex(tskid: ID, rasptn: TEXPTN) -> ER;
}
extern "C" {
    pub fn _kernel_iras_tex(tskid: ID, rasptn: TEXPTN) -> ER;
}
extern "C" {
    pub fn _kernel_dis_tex() -> ER;
}
extern "C" {
    pub fn _kernel_ena_tex() -> ER;
}
extern "C" {
    pub fn _kernel_sns_tex() -> bool_t;
}
extern "C" {
    pub fn _kernel_ref_tex(tskid: ID, pk_rtex: *mut T_RTEX) -> ER;
}
extern "C" {
    pub fn _kernel_sig_sem(semid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_isig_sem(semid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_wai_sem(semid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_pol_sem(semid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_twai_sem(semid: ID, tmout: TMO) -> ER;
}
extern "C" {
    pub fn _kernel_set_flg(flgid: ID, setptn: FLGPTN) -> ER;
}
extern "C" {
    pub fn _kernel_iset_flg(flgid: ID, setptn: FLGPTN) -> ER;
}
extern "C" {
    pub fn _kernel_clr_flg(flgid: ID, clrptn: FLGPTN) -> ER;
}
extern "C" {
    pub fn _kernel_wai_flg(flgid: ID, waiptn: FLGPTN, wfmode: MODE,
                           p_flgptn: *mut FLGPTN) -> ER;
}
extern "C" {
    pub fn _kernel_pol_flg(flgid: ID, waiptn: FLGPTN, wfmode: MODE,
                           p_flgptn: *mut FLGPTN) -> ER;
}
extern "C" {
    pub fn _kernel_twai_flg(flgid: ID, waiptn: FLGPTN, wfmode: MODE,
                            p_flgptn: *mut FLGPTN, tmout: TMO) -> ER;
}
extern "C" {
    pub fn _kernel_snd_dtq(dtqid: ID, data: isize) -> ER;
}
extern "C" {
    pub fn _kernel_psnd_dtq(dtqid: ID, data: isize) -> ER;
}
extern "C" {
    pub fn _kernel_ipsnd_dtq(dtqid: ID, data: isize) -> ER;
}
extern "C" {
    pub fn _kernel_tsnd_dtq(dtqid: ID, data: isize, tmout: TMO) -> ER;
}
extern "C" {
    pub fn _kernel_fsnd_dtq(dtqid: ID, data: isize) -> ER;
}
extern "C" {
    pub fn _kernel_ifsnd_dtq(dtqid: ID, data: isize) -> ER;
}
extern "C" {
    pub fn _kernel_rcv_dtq(dtqid: ID, p_data: *mut isize) -> ER;
}
extern "C" {
    pub fn _kernel_prcv_dtq(dtqid: ID, p_data: *mut isize) -> ER;
}
extern "C" {
    pub fn _kernel_trcv_dtq(dtqid: ID, p_data: *mut isize, tmout: TMO) -> ER;
}
extern "C" {
    pub fn _kernel_snd_pdq(pdqid: ID, data: isize, datapri: PRI) -> ER;
}
extern "C" {
    pub fn _kernel_psnd_pdq(pdqid: ID, data: isize, datapri: PRI) -> ER;
}
extern "C" {
    pub fn _kernel_ipsnd_pdq(pdqid: ID, data: isize, datapri: PRI) -> ER;
}
extern "C" {
    pub fn _kernel_tsnd_pdq(pdqid: ID, data: isize, datapri: PRI, tmout: TMO)
     -> ER;
}
extern "C" {
    pub fn _kernel_rcv_pdq(pdqid: ID, p_data: *mut isize, p_datapri: *mut PRI)
     -> ER;
}
extern "C" {
    pub fn _kernel_prcv_pdq(pdqid: ID, p_data: *mut isize,
                            p_datapri: *mut PRI) -> ER;
}
extern "C" {
    pub fn _kernel_trcv_pdq(pdqid: ID, p_data: *mut isize,
                            p_datapri: *mut PRI, tmout: TMO) -> ER;
}
extern "C" {
    pub fn _kernel_loc_mtx(mtxid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_ploc_mtx(mtxid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_tloc_mtx(mtxid: ID, tmout: TMO) -> ER;
}
extern "C" {
    pub fn _kernel_unl_mtx(mtxid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_get_mpf(mpfid: ID, p_blk: *mut *mut ::std::os::raw::c_void)
     -> ER;
}
extern "C" {
    pub fn _kernel_pget_mpf(mpfid: ID,
                            p_blk: *mut *mut ::std::os::raw::c_void) -> ER;
}
extern "C" {
    pub fn _kernel_tget_mpf(mpfid: ID,
                            p_blk: *mut *mut ::std::os::raw::c_void,
                            tmout: TMO) -> ER;
}
extern "C" {
    pub fn _kernel_rel_mpf(mpfid: ID, blk: *mut ::std::os::raw::c_void) -> ER;
}
extern "C" {
    pub fn _kernel_get_tim(p_systim: *mut SYSTIM) -> ER;
}
extern "C" {
    pub fn _kernel_get_utm(p_sysutm: *mut SYSUTM) -> ER;
}
extern "C" {
    pub fn _kernel_ref_ovr(tskid: ID, pk_rovr: *mut T_ROVR) -> ER;
}
extern "C" {
    pub fn _kernel_sta_cyc(cycid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_stp_cyc(cycid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_sta_alm(almid: ID, almtim: RELTIM) -> ER;
}
extern "C" {
    pub fn _kernel_ista_alm(almid: ID, almtim: RELTIM) -> ER;
}
extern "C" {
    pub fn _kernel_stp_alm(almid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_istp_alm(almid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_sta_ovr(tskid: ID, ovrtim: OVRTIM) -> ER;
}
extern "C" {
    pub fn _kernel_ista_ovr(tskid: ID, ovrtim: OVRTIM) -> ER;
}
extern "C" {
    pub fn _kernel_stp_ovr(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_istp_ovr(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_rot_rdq(tskpri: PRI) -> ER;
}
extern "C" {
    pub fn _kernel_irot_rdq(tskpri: PRI) -> ER;
}
extern "C" {
    pub fn _kernel_get_did(p_domid: *mut ID) -> ER;
}
extern "C" {
    pub fn _kernel_get_tid(p_tskid: *mut ID) -> ER;
}
extern "C" {
    pub fn _kernel_iget_tid(p_tskid: *mut ID) -> ER;
}
extern "C" {
    pub fn _kernel_loc_cpu() -> ER;
}
extern "C" {
    pub fn _kernel_iloc_cpu() -> ER;
}
extern "C" {
    pub fn _kernel_unl_cpu() -> ER;
}
extern "C" {
    pub fn _kernel_iunl_cpu() -> ER;
}
extern "C" {
    pub fn _kernel_dis_dsp() -> ER;
}
extern "C" {
    pub fn _kernel_ena_dsp() -> ER;
}
extern "C" {
    pub fn _kernel_sns_ctx() -> bool_t;
}
extern "C" {
    pub fn _kernel_sns_loc() -> bool_t;
}
extern "C" {
    pub fn _kernel_sns_dsp() -> bool_t;
}
extern "C" {
    pub fn _kernel_sns_dpn() -> bool_t;
}
extern "C" {
    pub fn _kernel_sns_ker() -> bool_t;
}
extern "C" {
    pub fn _kernel_ext_ker() -> ER;
}
extern "C" {
    pub fn _kernel_prb_mem(base: *const ::std::os::raw::c_void, size: SIZE,
                           tskid: ID, pmmode: MODE) -> ER;
}
extern "C" {
    pub fn _kernel_dis_int(intno: INTNO) -> ER;
}
extern "C" {
    pub fn _kernel_ena_int(intno: INTNO) -> ER;
}
extern "C" {
    pub fn _kernel_chg_ipm(intpri: PRI) -> ER;
}
extern "C" {
    pub fn _kernel_get_ipm(p_intpri: *mut PRI) -> ER;
}
extern "C" {
    pub fn _kernel_xsns_dpn(p_excinf: *mut ::std::os::raw::c_void) -> bool_t;
}
extern "C" {
    pub fn _kernel_xsns_xpn(p_excinf: *mut ::std::os::raw::c_void) -> bool_t;
}
extern "C" {
    pub fn _kernel_ini_sem(semid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_ini_flg(flgid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_ini_dtq(dtqid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_ini_pdq(pdqid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_ini_mtx(mtxid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_ini_mpf(mpfid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_ref_tsk(tskid: ID, pk_rtsk: *mut T_RTSK) -> ER;
}
extern "C" {
    pub fn _kernel_ref_sem(semid: ID, pk_rsem: *mut T_RSEM) -> ER;
}
extern "C" {
    pub fn _kernel_ref_flg(flgid: ID, pk_rflg: *mut T_RFLG) -> ER;
}
extern "C" {
    pub fn _kernel_ref_dtq(dtqid: ID, pk_rdtq: *mut T_RDTQ) -> ER;
}
extern "C" {
    pub fn _kernel_ref_pdq(pdqid: ID, pk_rpdq: *mut T_RPDQ) -> ER;
}
extern "C" {
    pub fn _kernel_ref_mtx(mtxid: ID, pk_rmtx: *mut T_RMTX) -> ER;
}
extern "C" {
    pub fn _kernel_ref_mpf(mpfid: ID, pk_rmpf: *mut T_RMPF) -> ER;
}
extern "C" {
    pub fn _kernel_ref_cyc(cycid: ID, pk_rcyc: *mut T_RCYC) -> ER;
}
extern "C" {
    pub fn _kernel_ref_alm(almid: ID, pk_ralm: *mut T_RALM) -> ER;
}
extern "C" {
    pub fn _kernel_acre_tsk(pk_ctsk: *const T_CTSK) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_sem(pk_csem: *const T_CSEM) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_flg(pk_cflg: *const T_CFLG) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_dtq(pk_cdtq: *const T_CDTQ) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_pdq(pk_cpdq: *const T_CPDQ) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_mtx(pk_cmtx: *const T_CMTX) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_mpf(pk_cmpf: *const T_CMPF) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_cyc(pk_ccyc: *const T_CCYC) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_alm(pk_calm: *const T_CALM) -> ER_ID;
}
extern "C" {
    pub fn _kernel_acre_isr(pk_cisr: *const T_CISR) -> ER_ID;
}
extern "C" {
    pub fn _kernel_del_tsk(tskid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_sem(semid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_flg(flgid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_dtq(dtqid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_pdq(pdqid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_mtx(mtxid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_mpf(mpfid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_cyc(cycid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_alm(almid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_del_isr(isrid: ID) -> ER;
}
extern "C" {
    pub fn _kernel_sac_tsk(tskid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_sem(semid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_flg(flgid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_dtq(dtqid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_pdq(pdqid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_mtx(mtxid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_mpf(mpfid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_cyc(cycid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_alm(almid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_sac_isr(isrid: ID, p_acvct: *const ACVCT) -> ER;
}
extern "C" {
    pub fn _kernel_def_tex(tskid: ID, pk_dtex: *const T_DTEX) -> ER;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SYSLOG {
    pub logtype: uint_t,
    pub logtim: SYSTIM,
    pub loginfo: [isize; 6usize],
}
#[test]
fn bindgen_test_layout_SYSLOG() {
    assert_eq!(::std::mem::size_of::<SYSLOG>() , 64usize , concat ! (
               "Size of: " , stringify ! ( SYSLOG ) ));
    assert_eq! (::std::mem::align_of::<SYSLOG>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SYSLOG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SYSLOG ) ) . logtype as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SYSLOG ) , "::" ,
                stringify ! ( logtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SYSLOG ) ) . logtim as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SYSLOG ) , "::" ,
                stringify ! ( logtim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SYSLOG ) ) . loginfo as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SYSLOG ) , "::" ,
                stringify ! ( loginfo ) ));
}
impl Clone for SYSLOG {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct t_syslog_rlog {
    pub count: uint_t,
    pub lost: uint_t,
    pub logmask: uint_t,
    pub lowmask: uint_t,
}
#[test]
fn bindgen_test_layout_t_syslog_rlog() {
    assert_eq!(::std::mem::size_of::<t_syslog_rlog>() , 16usize , concat ! (
               "Size of: " , stringify ! ( t_syslog_rlog ) ));
    assert_eq! (::std::mem::align_of::<t_syslog_rlog>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( t_syslog_rlog ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_syslog_rlog ) ) . count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( t_syslog_rlog ) , "::"
                , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_syslog_rlog ) ) . lost as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( t_syslog_rlog ) , "::"
                , stringify ! ( lost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_syslog_rlog ) ) . logmask as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( t_syslog_rlog ) , "::"
                , stringify ! ( logmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const t_syslog_rlog ) ) . lowmask as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( t_syslog_rlog ) , "::"
                , stringify ! ( lowmask ) ));
}
impl Clone for t_syslog_rlog {
    fn clone(&self) -> Self { *self }
}
pub type T_SYSLOG_RLOG = t_syslog_rlog;
extern "C" {
    pub fn _syslog_wri_log(prio: uint_t, p_syslog: *const SYSLOG, cdmid: ID)
     -> ER;
}
extern "C" {
    pub fn _syslog_fwri_log(ercd: ER, p_syslog: *const SYSLOG, cdmid: ID)
     -> ER;
}
extern "C" {
    pub fn syslog(prio: uint_t, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn itron_strerror(ercd: ER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn t_perror(prio: uint_t, file: *const ::std::os::raw::c_char,
                    line: int_t, expr: *const ::std::os::raw::c_char,
                    ercd: ER);
}
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int,
                    arg4: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(arg1: *const ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char,
                      arg3: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(arg1: ::std::os::raw::c_int,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_int,
                        arg4: *const ::std::os::raw::c_char,
                        arg5: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(::std::mem::size_of::<__sbuf>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sbuf ) ));
    assert_eq! (::std::mem::align_of::<__sbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _base as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _size as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _size ) ));
}
impl Clone for __sbuf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    pub _read: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2:
                                                              *mut ::std::os::raw::c_char,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int>,
    pub _seek: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2: fpos_t,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> fpos_t>,
    pub _write: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void,
                                                           arg2:
                                                               *const ::std::os::raw::c_char,
                                                           arg3:
                                                               ::std::os::raw::c_int)
                                          -> ::std::os::raw::c_int>,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(::std::mem::size_of::<__sFILE>() , 152usize , concat ! (
               "Size of: " , stringify ! ( __sFILE ) ));
    assert_eq! (::std::mem::align_of::<__sFILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sFILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _p as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _r as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _w as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _file as * const _ as usize
                } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _bf as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _bf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lbfsize as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lbfsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _cookie as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _close as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _read as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _seek as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _write as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ub as * const _ as usize }
                , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ub ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _extra as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _extra ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ur as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ubuf as * const _ as usize
                } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ubuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _nbuf as * const _ as usize
                } , 119usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _nbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lb as * const _ as usize }
                , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _blksize as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _blksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _offset ) ));
}
impl Clone for __sFILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = __sFILE;
extern "C" {
    #[link_name = "__stdinp"]
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    #[link_name = "__stdoutp"]
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    #[link_name = "__stderrp"]
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(arg1: *mut ::std::os::raw::c_char,
                 arg2: ::std::os::raw::c_int, arg3: *mut FILE)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __nitems: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn freopen(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: *mut FILE)
     -> *mut FILE;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: ::std::os::raw::c_long,
                 arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __nitems: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int, arg4: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int,
                  arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                      arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __prefix: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __offset: off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(__str: *mut ::std::os::raw::c_char, __size: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char,
                   arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__str: *mut ::std::os::raw::c_char, __size: usize,
                     __format: *const ::std::os::raw::c_char,
                     arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__str: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(arg1: ::std::os::raw::c_int,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(__linep: *mut *mut ::std::os::raw::c_char,
                    __linecapp: *mut usize,
                    __delimiter: ::std::os::raw::c_int, __stream: *mut FILE)
     -> isize;
}
extern "C" {
    pub fn getline(__linep: *mut *mut ::std::os::raw::c_char,
                   __linecapp: *mut usize, __stream: *mut FILE) -> isize;
}
extern "C" {
    pub fn fmemopen(__buf: *mut ::std::os::raw::c_void, __size: usize,
                    __mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufp: *mut *mut ::std::os::raw::c_char,
                          __sizep: *mut usize) -> *mut FILE;
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(arg1: *mut *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(arg1: *const ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                     arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zopen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char,
                 arg3: ::std::os::raw::c_int) -> *mut FILE;
}
extern "C" {
    pub fn funopen(arg1: *const ::std::os::raw::c_void,
                   arg2:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *mut ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg3:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg4:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      fpos_t,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> fpos_t>,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(arg1: *mut ::std::os::raw::c_char,
                         arg2: ::std::os::raw::c_int, arg3: usize,
                         arg4: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                          arg3: ::std::os::raw::c_int, arg4: usize,
                          arg5: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(arg1: *mut ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int, arg3: usize,
                          arg4: *const ::std::os::raw::c_char,
                          arg5: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                           arg3: ::std::os::raw::c_int, arg4: usize,
                           arg5: *const ::std::os::raw::c_char,
                           arg6: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
#[repr(u32)]
/**
 * \~English
 * \brief Enumeration type for buttons
 *
 * \~Japanese
 * \brief 
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum button_t {
    LEFT_BUTTON = 0,
    RIGHT_BUTTON = 1,
    UP_BUTTON = 2,
    DOWN_BUTTON = 3,
    ENTER_BUTTON = 4,
    BACK_BUTTON = 5,
    TNUM_BUTTON = 6,
}
extern "C" {
    /**
 * \~English
 * \brief         Get the pressed state of the button.
 * \details       When an invalid button number is specified , always returns \a false  [TODO: check - error log is output]
 * \param  button Button number
 * \retval true   Pressed state
 * \retval false  Unpressed state
 *
 * \~Japanese
 * \brief         
 * \details        \a false 
 * \param  button 
 * \retval true   
 * \retval false  
 */
    pub fn ev3_button_is_pressed(button: button_t) -> bool_t;
}
extern "C" {
    /**
 * \~English
 * [TODO: sync with jp version]
 * \brief 		  Attach a click event handler for a button.
 * \details		  The button handler executes in the task contest. The default is called from the wait disabled state.
 * \param button  the button to be set
 * \param handler the handler to be attached, NULL for clearing the current handler
 * \param exinf   extra information passed to the \a handler when it is called
 * \retval E_OK   Successful completion
 * \retval E_ID   Invalid button number
 *
 * \~Japanese
 * \brief          
 * \details        
 * \param  button  
 * \param  handler NULL
 * \param  exinf   
 * \retval E_OK    
 * \retval E_ID    
 */
    pub fn ev3_button_set_on_clicked(button: button_t, handler: ISR,
                                     exinf: isize) -> ER;
}
/**
 * \~English
 * \brief A memory file is a file stored in RAM rather than on the SD card.
 *
 * \~Japanese
 * \brief SD
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct memfile_t {
    //< \~English Pointer of the buffer where this file is stored. NULL means a invalid memory file. \~Japanese NULL
    pub buffer: *mut ::std::os::raw::c_void,
    //< \~English Actual size of this file	 					                                     \~Japanese 
    pub filesz: u32,
    //< \~English Maximum size of the buffer to store this file   									 \~Japanese 
    pub buffersz: u32,
}
#[test]
fn bindgen_test_layout_memfile_t() {
    assert_eq!(::std::mem::size_of::<memfile_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( memfile_t ) ));
    assert_eq! (::std::mem::align_of::<memfile_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( memfile_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memfile_t ) ) . buffer as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( memfile_t ) , "::" ,
                stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memfile_t ) ) . filesz as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( memfile_t ) , "::" ,
                stringify ! ( filesz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memfile_t ) ) . buffersz as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( memfile_t ) , "::" ,
                stringify ! ( buffersz ) ));
}
impl Clone for memfile_t {
    fn clone(&self) -> Self { *self }
}
/**
 * \~English
 * \brief Structure of file information.
 *
 * \~Japanese
 * \brief 
 */
#[repr(C)]
pub struct fileinfo_t {
    //< \~English File size          \~Japanese 
    pub size: u32,
    //< \~English Last modified date \~Japanese Last modified date
    pub date: u16,
    //< \~English Last modified time \~Japanese Last modified time
    pub time: u16,
    //< \~English Flag of a folder   \~Japanese 
    pub is_dir: bool_t,
    //< \~English Flag of read-only  \~Japanese 
    pub is_readonly: bool_t,
    //< \~English Flag of hidden     \~Japanese 
    pub is_hidden: bool_t,
    //< \~English File name          \~Japanese 
    pub name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_fileinfo_t() {
    assert_eq!(::std::mem::size_of::<fileinfo_t>() , 276usize , concat ! (
               "Size of: " , stringify ! ( fileinfo_t ) ));
    assert_eq! (::std::mem::align_of::<fileinfo_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( fileinfo_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileinfo_t ) ) . size as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fileinfo_t ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileinfo_t ) ) . date as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( fileinfo_t ) , "::" ,
                stringify ! ( date ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileinfo_t ) ) . time as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( fileinfo_t ) , "::" ,
                stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileinfo_t ) ) . is_dir as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( fileinfo_t ) , "::" ,
                stringify ! ( is_dir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileinfo_t ) ) . is_readonly as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( fileinfo_t ) , "::" ,
                stringify ! ( is_readonly ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileinfo_t ) ) . is_hidden as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( fileinfo_t ) , "::" ,
                stringify ! ( is_hidden ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileinfo_t ) ) . name as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( fileinfo_t ) , "::" ,
                stringify ! ( name ) ));
}
extern "C" {
    /**
 * \~English
 * \brief      Open a directory for reading.
 * \details    If it succeeds, it returns the ID of the opened directory as a return value. This ID can be used to obtain file information in the directory.
 * \param path Path of the directory to be opened
 * \retval >0     ID of the opened directory
 * \retval E_CTX  Call from non-task contest
 * \retval E_MACV Memory access violation (path)
 * \retval E_NOID Insufficient ID number
 * \retval E_PAR  Invalid path name
 * \retval E_SYS  I/O error occurred (High possibility of SD card failure)
 *
 * \~Japanese
 * \brief         
 * \details       IDID
 * \param  path   
 * \retval >0     ID
 * \retval E_CTX  
 * \retval E_MACV path
 * \retval E_NOID ID
 * \retval E_PAR  
 * \retval E_SYS  I/OSD
 */
    pub fn ev3_sdcard_opendir(path: *const ::std::os::raw::c_char) -> ER_ID;
}
extern "C" {
    /**
 * \~English
 * \brief             Read file information in the directory.
 * \details   	      Return information on the next file from the opened directory. [TODO: check]
 * \param  dirid      ID of an opened directory
 * \param  p_fileinfo Pointer to structure with information of storing file [TODO: check].
 * \retval E_OK       Success
 * \retval E_CTX      Call from non-task contest
 * \retval E_ID       Invalid ID number
 * \retval E_MACV     Memory access violation (p_fileinfo)
 * \retval E_OBJ      There is no information on files that can be read any more
 * \retval E_SYS      I/O error occurred (High possibility of SD card failure)
 *
 * \~Japanese
 * \brief             
 * \details           
 * \param  dirid      ID
 * \param  p_fileinfo 
 * \retval E_OK       
 * \retval E_CTX      
 * \retval E_ID       ID
 * \retval E_MACV     p_fileinfo
 * \retval E_OBJ      
 * \retval E_SYS  I/OSD
 */
    pub fn ev3_sdcard_readdir(dirid: ID, p_fileinfo: *mut fileinfo_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief             Close a directory.
 * \details           If it succeeds, it releases the resource of the opened directory, and its ID can not be used.
 * \param  dirid      ID of an opened directory
 * \retval E_OK       Success
 * \retval E_CTX      Call from non-task contest
 * \retval E_ID       Invalid ID number
 * \retval E_SYS      I/O error occurred (High possibility of SD card failure)
 *
 * \~Japanese
 * \brief          
 * \details        ID
 * \param  dirid   ID
 * \retval E_OK    
 * \retval E_CTX   
 * \retval E_ID    ID
 * \retval E_SYS   I/OSD
 */
    pub fn ev3_sdcard_closedir(dirid: ID) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief            Create a memory file and load a specific file into it from the SD card.
 * \details          Generates an object of the memory file and reads the specified file from the SD card into this memory file. If an error occurs , clear buffer in \a p_memfile to \a NULL.
 * \param  path      Path of the file to be loaded
 * \param  p_memfile Pointer of save the created memory file
 * \retval E_OK      Success
 * \retval E_MACV    Memory access violation (path or p_memfile)
 * \retval E_NOMEM   No enough free memory to create the memory file, or \a p_memfile is NULL. The \a buffer of \a p_memfile will be set to NULL if this happens.
 * \retval E_PAR     The \a path does not point to a valid file. The \a buffer of \a p_memfile will be set to NULL if this happens.
 * \retval E_SYS     I/O failure, which might be caused by a corrupted SD card. The \a buffer of \a p_memfile will be set to NULL if this happens.
 *
 * \~Japanese
 * \brief            SD
 * \details          SD\a p_memfile  \a buffer NULL.
 * \param  path      
 * \param  p_memfile 
 * \retval E_OK      
 * \retval E_MACV    pathp_memfile
 * \retval E_NOMEM   
 * \retval E_PAR     
 * \retval E_SYS     I/OSD
 */
    pub fn ev3_memfile_load(path: *const ::std::os::raw::c_char,
                            p_memfile: *mut memfile_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief            Free the resource (memory) allocated to a memory file.
  * \details         The \a buffer of \a p_memfile will be set to NULL on success.
 * \param  p_memfile Pointer of a memory file to release
 * \retval E_OK      Success
 * \retval E_PAR     The \a p_memfile is NULL. [TODO: check - inconsistent with Jp version -> E_MACV]
 * \retval E_OBJ     The \a p_memfile does not point to a valid memory file.
 *
 * \~Japanese
 * \brief            
 * \details          \a p_memfile  \a buffer NULL
 * \param  p_memfile 
 * \retval E_OK      
 * \retval E_MACV    p_memfile
 * \retval E_OBJ     \a p_memfile 
 */
    pub fn ev3_memfile_free(p_memfile: *mut memfile_t) -> ER;
}
#[repr(u32)]
/**
 * \~English
 * \brief Numbers representing serial ports
 *
 * \~Japanese
 * \brief 
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum serial_port_t {
    EV3_SERIAL_DEFAULT = 0,
    EV3_SERIAL_UART = 1,
    EV3_SERIAL_BT = 2,
}
extern "C" {
    /**
 * \~English
 * \brief 	     Open the serial port as a file.
 * \details      In case of failure, NULL is returned (error log is output).
 * \param port   Serial port number
 * \returns      Serial port file
 *
 * \~Japanese
 * \brief 	     
 * \details      NULL
 * \param port   
 * \returns      
 */
    pub fn ev3_serial_open_file(port: serial_port_t) -> *mut FILE;
}
extern "C" {
    /**
 * \~English
 * \brief            It is checked whether Bluetooth (Serial Port Profile) is connected.
 * \retval true      Connected. It can communicate with the Bluetooth virtual serial port.
 * \retval false     Unconnected.
 *
 * \~Japanese
 * \brief            Bluetooth (Serial Port Profile)
 * \retval true      Bluetooth
 * \retval false     
 */
    pub fn ev3_bluetooth_is_connected() -> bool_t;
}
#[repr(u32)]
/**
 * \~English
 * \brief Enumeration type for font size
 *
 * \~Japanese
 * \brief 
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcdfont_t { EV3_FONT_SMALL = 0, EV3_FONT_MEDIUM = 1, }
#[repr(u32)]
/**
 * \~English
 * \brief Enumeration type for LCD color
 *
 * \~Japanese
 * \brief LCD
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcdcolor_t { EV3_LCD_WHITE = 0, EV3_LCD_BLACK = 1, }
extern "C" {
    /**
 * \~English
 * \brief        Set the default font.
 * \param font   Font number
 * \retval E_OK  Successful completion
 * \retval E_ID  Invalid font number
 *
 * \~Japanese
 * \brief        
 * \param  font  
 * \retval E_OK  
 * \retval E_ID  ID
 */
    pub fn ev3_lcd_set_font(font: lcdfont_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief           Get font size.
 * \param  font     Font number
 * \param  p_width  Pointer to a place to store the acquired font width. If it is NULL, it is not stored.
 * \param  p_height Pointer to the place to store the height of the acquired font. If it is NULL, it is not stored.
 * \retval E_OK     Successful completion
 * \retval E_ID     Invalid fomt number
 *
 * \~Japanese
 * \brief           
 * \param  font     
 * \param  p_width  NULL
 * \param  p_height NULL
 * \retval E_OK     
 * \retval E_ID     ID
 */
    pub fn ev3_font_get_size(font: lcdfont_t, p_width: *mut i32,
                             p_height: *mut i32) -> ER;
}
/**
 * \~English
 * \brief Structure of the image object.
 *
 * \~Japanese
 * \brief 
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct image_t {
    pub width: i32,
    pub height: i32,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_image_t() {
    assert_eq!(::std::mem::size_of::<image_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( image_t ) ));
    assert_eq! (::std::mem::align_of::<image_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( image_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const image_t ) ) . width as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( image_t ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const image_t ) ) . height as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( image_t ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const image_t ) ) . data as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( image_t ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for image_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * \~English
 * \brief            Load images from memory file.
 * \details          Create an image object from the specified memory file. Currently, it only supports monochrome image files in BMP format. If an error occurs , clear the data of \a p_image to NULL.
 * \param  p_memfile Object of memory file where image file is stored
 * \param  p_image   Pointer to the place to store the object of the generated image
 * \retval E_OK      Successful completion
 * \retval E_NOMEM   Insufficient memory
 * \retval E_NOSPT   Image file format is not supported
 * \retval E_OBJ     Image file is damaged
 * \retval E_PAR     Invalid memory file
 *
 * \~Japanese
 * \brief            
 * \details          BMP
 *                   \a p_image  \a data NULL.
 * \param  p_memfile 
 * \param  p_image   
 * \retval E_OK      
 * \retval E_NOMEM   
 * \retval E_NOSPT   
 * \retval E_OBJ     
 * \retval E_PAR     
 */
    pub fn ev3_image_load(p_memfile: *const memfile_t, p_image: *mut image_t)
     -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief            Release the image object.
 * \details          Free resources (memory area) secured by the object of the image. In case of normal \a termination , data of \a p_image is cleared to NULL.
 * \param  p_image   Pointer to released object
 * \retval E_OK      Successful completion
 * \retval E_PAR     \a p_image is NULL
 *
 * \~Japanese
 * \brief            
 * \details          \a p_image  \a data NULL
 * \param  p_image   
 * \retval E_OK      
 * \retval E_PAR     \a p_image NULL
 */
    pub fn ev3_image_free(p_image: *mut image_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief             Draws a character string at the specified position.
 * \param  x          Horizontal position of upper left corner
 * \param  y          Vertical position of upper left corner
 * \param  str        String (pointer to array of characters)
 * \retval E_OK       Successful completion
 *
 * \~Japanese
 * \brief             
 * \param  x          
 * \param  y          
 * \param  str        
 * \retval E_OK       
 */
    pub fn ev3_lcd_draw_string(str: *const ::std::os::raw::c_char, x: i32,
                               y: i32) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief             Draw a line at specified coordinates.
 * \param  x0         Horizontal position of start point
 * \param  y0         Vertical position of start point
 * \param  x1         Horizontal position of the end point
 * \param  y1         Vertical position of the end point
 * \retval E_OK       Successful completion
 *
 * \~Japanese
 * \brief             
 * \param  x0         
 * \param  y0         
 * \param  x1         
 * \param  y1         
 * \retval E_OK       
 */
    pub fn ev3_lcd_draw_line(x0: i32, y0: i32, x1: i32, y1: i32) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief            Draw a rectangle
 * \param  x         Horizontal position of upper left corner
 * \param  y         Vertical position of upper left corner
 * \param  w         Width of the rectangle
 * \param  h         Height of the rectangle
 * \param  color     Color [TODO: color of filling?]
 * \retval E_OK      Successful completion
 *
 * \~Japanese
 * \brief            
 * \param  x         
 * \param  y         
 * \param  w         
 * \param  h         
 * \param  color     
 * \retval E_OK      
 */
    pub fn ev3_lcd_fill_rect(x: i32, y: i32, w: i32, h: i32,
                             color: lcdcolor_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief            Display the image at specified coordinates.
 * \param  p_image   Image object
 * \param  x         Horizontal position of upper left corner
 * \param  y         Vertical position of upper left corner
 * \retval E_OK      Successful completion
 * \retval E_PAR     Image object invalid
 *
 * \~Japanese
 * \brief            
 * \param  p_image   
 * \param  x         
 * \param  y         
 * \retval E_OK      
 * \retval E_PAR     
 */
    pub fn ev3_lcd_draw_image(p_image: *const image_t, x: i32, y: i32) -> ER;
}
#[repr(u32)]
/**
 * \~English
 * \brief Enumeration type for supported LED colors
 *
 * \~Japanese
 * \brief LED
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ledcolor_t {
    LED_OFF = 0,
    LED_RED = 1,
    LED_GREEN = 2,
    LED_ORANGE = 3,
}
extern "C" {
    /**
 * \~English
 * \brief 		 Control the color of LED lights.
 * \details      When specifying an incorrect setting value, do not change the color of the LED light.
 * \param color  The color to set
 * \retval E_OK  Successful completion
 * \retval E_PAR Incorrect setting value
 *
 * \~Japanese
 * \brief 		 LED
 * \details      LED
 * \param  color LED
 * \retval E_OK  
 * \retval E_PAR 
 */
    pub fn ev3_led_set_color(color: ledcolor_t) -> ER;
}
#[repr(u32)]
/**
 * \~English
 * \brief ID for supported motor ports
 *
 * \~Japanese
 * \brief 
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum motor_port_t {
    EV3_PORT_A = 0,
    EV3_PORT_B = 1,
    EV3_PORT_C = 2,
    EV3_PORT_D = 3,
    TNUM_MOTOR_PORT = 4,
}
#[repr(u32)]
/**
 * \~English
 * \brief Enumeration type for supported motor types
 *
 * \~Japanese
 * \brief 
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum motor_type_t {
    NONE_MOTOR = 0,
    MEDIUM_MOTOR = 1,
    LARGE_MOTOR = 2,
    UNREGULATED_MOTOR = 3,
    TNUM_MOTOR_TYPE = 4,
}
extern "C" {
    /**
 * \~English
 * \brief 	   Configure a motor port.
 * \details	   Set the type of motor connected to the motor port. You can also specify a new motor type even if you have already set it.
 * \param port Motor port to be configured
 * \param type Motor type for the specified motor port
 * \retval E_OK  Successful completion
 * \retval E_ID  Illegal motor port number
 * \retval E_PAR Illegal motor type
 *
 * \~Japanese
 * \brief 	     
 * \details      
 * \param  port  
 * \param  type  
 * \retval E_OK  
 * \retval E_ID  
 * \retval E_PAR 
 */
    pub fn ev3_motor_config(port: motor_port_t, type_: motor_type_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief 	    Get the type of a motor port.
 * \param port  Motor port to be inquired
 * \retval >=0  Motor type of specified motor port
 * \retval E_ID Illegal motor port number
 *
 * \~Japanese
 * \brief 	    
 * \param  port 
 * \retval >=0  
 * \retval E_ID 
 */
    pub fn ev3_motor_get_type(port: motor_port_t) -> ER_UINT;
}
extern "C" {
    /**
 * \~English
 * \brief 	   Get the angular position of a motor port.
 * \details    When an incorrect motor port number is specified, it always returns 0.
 * \param port Motor port to be inquired
 * \return     Angular position in degrees. A negative value means the motor rotate has rotated backwards. [TODO: number of degrees per one revolution of motor]

 *
 * \~Japanese
 * \brief 	   
 * \details    0
 * \param port 
 * \return     
 */
    pub fn ev3_motor_get_counts(port: motor_port_t) -> i32;
}
extern "C" {
    /**
 * \~English
 * \brief 	   Reset the angular position of the motor to zero
 * \details    Setting the value of the angular position sensor of the motor does not affect the actual power and position of the motor.
 * \param port Motor port to be inquired
 * \retval E_OK   Successful completion
 * \retval E_ID   Illegal motor port number
 * \retval E_OBJ  Motor port has not been initialized.
 *
 * \~Japanese
 * \brief 	      
 * \details       
 * \param  port   
 * \retval E_OK   
 * \retval E_ID   
 * \retval E_OBJ  
 */
    pub fn ev3_motor_reset_counts(port: motor_port_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief 	    Set the unregulated power for a motor port.
 * \param port  Motor port to be set
 * \param power The percentage of full power, ranging from -100 to +100. A negative value makes the motor rotate backwards.
 * \retval E_OK     Successful completion
 * \retval E_ID     Illegal motor port number
 * \retval E_OBJ    Motor port has not been initialized.
 *
 * \~Japanese
 * \brief 	     
 * \param  port  
 * \param  power -100+100
 * \retval E_OK  
 * \retval E_ID  
 * \retval E_OBJ 
 */
    pub fn ev3_motor_set_power(port: motor_port_t,
                               power: ::std::os::raw::c_int) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief 	    Get the actual power of a motor port.
 * \details     When an incorrect motor port number is specified, it always returns 0.
 * \param port  Motor port to be set
 * \return      Motor power [TODO: range?]
 *
 * \~Japanese
 * \brief 	   
 * \details    0
 * \param port 
 * \return     
 */
    pub fn ev3_motor_get_power(port: motor_port_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \~English
 * \brief 	    Stop a motor port.
 * \param port  Motor port to be stopped
 * \param brake Brake mode, \a true for braking, \a false for coasting.
 * \retval E_OK     Successful completion
 * \retval E_ID     Illegal motor port number
 * \retval E_OBJ    Motor port has not been initialized.
 *
 * \~Japanese
 * \brief 	     
 * \param  port  
 * \param  brake \a true , \a false 
 * \retval E_OK  
 * \retval E_ID  
 * \retval E_OBJ 
 */
    pub fn ev3_motor_stop(port: motor_port_t, brake: bool_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief 	        Rotate a motor port for specified degrees.
 * \param port      Motor port to be rotated
 * \param degrees   Degrees to be rotated. A negative value makes the motor rotate backwards.
 * \param speed_abs Speed for rotating. The value is a percentage of full speed, ranging from 0 to +100.
 * \param blocking  \a true (The function will be blocked until the rotation is finished), or \a false (The function will not be blocked).
 * \retval E_OK     Successful completion
 * \retval E_ID     Illegal motor port number
 * \retval E_OBJ    Motor port has not been initialized.
 *
 * \~Japanese
 * \brief 	         
 * \param  port      
 * \param  degrees   
 * \param  speed_abs 0+100
 * \param  blocking  \a true ()\a false ()
 * \retval E_OK      
 * \retval E_ID      
 * \retval E_OBJ     
 */
    pub fn ev3_motor_rotate(port: motor_port_t,
                            degrees: ::std::os::raw::c_int, speed_abs: u32,
                            blocking: bool_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief              Move the robot along a curved path using two motors.
 * \param  left_motor  ID of the left motor port
 * \param  right_motor ID of the right motor port
 * \param  power       Power of motors. Range: -100 to +100. A negative value moves the robot backwards.
 * \param  turn_ratio  The sharpness of the turn. Range: -100 to +100. If \a turn_ratio is negative, the robot will turn left.
 *                     If \a turn_ratio is positive, the robot will turn right. More specifically, \a turn_ratio determines the ratio of
 *                     inner wheel speed as a percent. For example, if \a turn_ratio is +25, the right motor will move at 75% of the \a power,
 *                     which makes the robot turn right.
 * \retval E_OK        Success
 * \retval E_ID        Invalid ID of motor port
 * \retval E_OBJ       Motor port has not been initialized.
 *
 * \~Japanese
 * \brief              
 * \param  left_motor  
 * \param  right_motor 
 * \param  power       -100+100
 * \param  turn_ratio  -100+100
 *                     \a turn_ratio +25
 *                     \a power \a power 75\%
 * \retval E_OK        
 * \retval E_ID        ID
 * \retval E_OBJ       
 */
    pub fn ev3_motor_steer(left_motor: motor_port_t,
                           right_motor: motor_port_t,
                           power: ::std::os::raw::c_int,
                           turn_ratio: ::std::os::raw::c_int) -> ER;
}
#[repr(u32)]
/**
 * \~English
 * \brief Enumeration type for supported sensor ports
 *
 * \~Japanese
 * \brief 
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sensor_port_t {
    EV3_PORT_1 = 0,
    EV3_PORT_2 = 1,
    EV3_PORT_3 = 2,
    EV3_PORT_4 = 3,
    TNUM_SENSOR_PORT = 4,
}
#[repr(u32)]
/**
 * \~English
 * \brief Enumeration type for supported sensor types
 *
 * \~Japanese
 * \brief 
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sensor_type_t {
    NONE_SENSOR = 0,
    ULTRASONIC_SENSOR = 1,
    GYRO_SENSOR = 2,
    TOUCH_SENSOR = 3,
    COLOR_SENSOR = 4,
    INFRARED_SENSOR = 5,
    HT_NXT_ACCEL_SENSOR = 6,
    HT_NXT_COLOR_SENSOR = 7,
    NXT_TEMP_SENSOR = 8,
    TNUM_SENSOR_TYPE = 9,
}
#[repr(u32)]
/**
 * \~English
 * \brief Enumeration type for colors that can be detected by color sensor
 *
 * \~Japanese
 * \brief 
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum colorid_t {
    COLOR_NONE = 0,
    COLOR_BLACK = 1,
    COLOR_BLUE = 2,
    COLOR_GREEN = 3,
    COLOR_YELLOW = 4,
    COLOR_RED = 5,
    COLOR_WHITE = 6,
    COLOR_BROWN = 7,
    TNUM_COLOR = 8,
}
/**
 * \~English
 * \brief Structure for an RGB raw value
 *
 * \~Japanese
 * \brief RGB Raw
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rgb_raw_t {
    //< \~English Red value   \~Japanese 
    pub r: u16,
    //< \~English Green value \~Japanese 
    pub g: u16,
    //< \~English Blue value  \~Japanese 
    pub b: u16,
}
#[test]
fn bindgen_test_layout_rgb_raw_t() {
    assert_eq!(::std::mem::size_of::<rgb_raw_t>() , 6usize , concat ! (
               "Size of: " , stringify ! ( rgb_raw_t ) ));
    assert_eq! (::std::mem::align_of::<rgb_raw_t>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( rgb_raw_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rgb_raw_t ) ) . r as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rgb_raw_t ) , "::" ,
                stringify ! ( r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rgb_raw_t ) ) . g as * const _ as usize }
                , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rgb_raw_t ) , "::" ,
                stringify ! ( g ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rgb_raw_t ) ) . b as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rgb_raw_t ) , "::" ,
                stringify ! ( b ) ));
}
impl Clone for rgb_raw_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * \~English
 * \brief 	     Configure a sensor port.
 * \details      Always returns 0  when an invalid sensor number is specified.
 * \param port   Sensor port to be configured
 * \param type   Sensor type for the specified sensor port
 * \retval E_OK  Successful completion
 * \retval E_ID  Illegal sensor port number
 * \retval E_PAR Illegal sensor type
 *
 * \~Japanese
 * \brief 	     
 * \details      
 * \param  port  
 * \param  type  
 * \retval E_OK  
 * \retval E_ID  
 * \retval E_PAR 
 */
    pub fn ev3_sensor_config(port: sensor_port_t, type_: sensor_type_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief 	    Get the type of a sensor port.
 * \param port  Sensor port to be inquired
 * \retval >=0  Specified sensor type of supported sensor
 * \retval E_ID Incorrect sensor port number
 *
 * \~Japanese
 * \brief 	    
 * \param  port 
 * \retval >=0  
 * \retval E_ID 
 */
    pub fn ev3_sensor_get_type(port: sensor_port_t) -> ER_UINT;
}
extern "C" {
    /**
 * \~English
 * \brief 	   Get the color by a color sensor.
 * \details    Always return COLOR_NONE (error  is outputted) when an incorrect sensor number is specified.
 * \param port Sensor port to be inquired
 * \return     Color detected
 *
 * \~Japanese
 * \brief 	    
 * \details     COLOR_NONE
 * \param  port 
 * \return      
 */
    pub fn ev3_color_sensor_get_color(port: sensor_port_t) -> colorid_t;
}
extern "C" {
    /**
 * \~English
 * \brief 	   Get the reflect light intensity by a color sensor.
 * \details    Always returns 0 (error log is outputted) when an invalid sensor number is specified.
 * \param port Sensor port to be inquired
 * \return     Reflect light intensity, ranging from 0 to 100
 *
 * \~Japanese
 * \brief 	    
 * \details     0
 * \param port  
 * \return      0100
 */
    pub fn ev3_color_sensor_get_reflect(port: sensor_port_t) -> u8;
}
extern "C" {
    /**
 * \~English
 * \brief 	   Get the ambient light intensity by a color sensor.
 * \details    Always returns 0 (error log is outputted) when an invalid sensor number is specified.
 * \param port Sensor port to be inquired
 * \return     Ambient light intensity, ranging from 0 to 100
 *
 * \~Japanese
 * \brief 	    
 * \details     0
 * \param port  
 * \return      0100
 */
    pub fn ev3_color_sensor_get_ambient(port: sensor_port_t) -> u8;
}
extern "C" {
    /**
 * \~English
 * \brief 	   Get the RGB raw value by a color sensor.
 * \details    If an invalid sensor number is specified, val is not updated (error log is output).
 * \param port Sensor port to be inquired
 * \param val  Pointer for storing sensor value
 *
 * \~Japanese
 * \brief 	    RGB Raw
 * \details     val
 * \param port  
 * \param val   
 */
    pub fn ev3_color_sensor_get_rgb_raw(port: sensor_port_t,
                                        val: *mut rgb_raw_t);
}
extern "C" {
    /**
 * \~English
 * \brief 	   Get the angular position by a gyroscope sensor.
 * \details    Always returns 0 (error log is outputted) when an invalid sensor number is specified.
 * \param port Sensor port to be inquired
 * \return     Angular position in degrees
 *
 * \~Japanese
 * \brief 	    
 * \details     0
 * \param port  
 * \return      
 */
    pub fn ev3_gyro_sensor_get_angle(port: sensor_port_t) -> i16;
}
extern "C" {
    /**
 * \~English
 * \brief 	   Get the angular speed by a gyroscope sensor.
 * \details    Always returns 0 (error log is outputted) when an invalid sensor number is specified.
 * \param port Sensor port to be inquired
 * \return     Angular speed in degrees/second.
 *
 * \~Japanese
 * \brief 	    
 * \details     0
 * \param  port 
 * \return      /
 */
    pub fn ev3_gyro_sensor_get_rate(port: sensor_port_t) -> i16;
}
extern "C" {
    /**
 * \~English
 * \brief 	    Reset the angular position of a gyroscope sensor to zero.
 * \param port  Sensor port to be reset
 * \retval E_OK Successful completion
 * \retval E_ID Illegal sensor port number
 *
 * \~Japanese
 * \brief 	   
 * \param port 
 * \retval E_OK 
 * \retval E_ID 
 */
    pub fn ev3_gyro_sensor_reset(port: sensor_port_t) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief 	   Get the distance by a ultrasonic sensor.
 * \details    Always returns 0 (error log is outputted) when an invalid sensor number is specified.
 * \param port Sensor port to be inquired
 * \return     Distance in centimeters.
 *
 * \~Japanese
 * \brief 	    
 * \details     0
 * \param  port 
 * \return      
 */
    pub fn ev3_ultrasonic_sensor_get_distance(port: sensor_port_t) -> i16;
}
extern "C" {
    /**
 * \~English
 * \brief 	     Get a ultrasonic signal by a ultrasonic sensor.
 * \details      When an invalid sensor support number is specified, always returns false (error log is output).
 * \param port   Sensor port to be inquired
 * \retval true  A signal has been received
 * \retval false No signal has been received
 *
 * \~Japanese
 * \brief 	     
 * \details       \a false 
 * \param  port  
 * \retval true  
 * \retval false 
 */
    pub fn ev3_ultrasonic_sensor_listen(port: sensor_port_t) -> bool_t;
}
/**
 * \~English
 * \brief Structure for IR Seek values for all 4 channels
 *
 * \~Japanese
 * \brief IR
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ir_seek_t {
    //< \~English Heading  for channels 1-4 (-25 to 25)           \~Japanese -2525
    pub heading: [i8; 4usize],
    //< \~English Distance for channels 1-4 (-128 and 0 to 100)   \~Japanese 0100-128
    pub distance: [i8; 4usize],
}
#[test]
fn bindgen_test_layout_ir_seek_t() {
    assert_eq!(::std::mem::size_of::<ir_seek_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( ir_seek_t ) ));
    assert_eq! (::std::mem::align_of::<ir_seek_t>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ir_seek_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ir_seek_t ) ) . heading as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ir_seek_t ) , "::" ,
                stringify ! ( heading ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ir_seek_t ) ) . distance as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ir_seek_t ) , "::" ,
                stringify ! ( distance ) ));
}
impl Clone for ir_seek_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ir_remote_t {
    //< \~English IR Remote controller data for channels 1-4   \~Japanese 
    pub channel: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_ir_remote_t() {
    assert_eq!(::std::mem::size_of::<ir_remote_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( ir_remote_t ) ));
    assert_eq! (::std::mem::align_of::<ir_remote_t>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ir_remote_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ir_remote_t ) ) . channel as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ir_remote_t ) , "::" ,
                stringify ! ( channel ) ));
}
impl Clone for ir_remote_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * \~English
 * \brief      Get the distance using the infrared sensor.
 * \details    Always returns 0 (error log is outputted) when an invalid sensor number is specified.
 * \param port Sensor port to be inquired.
 * \return     Distance in percentage (0-100).
 *
 * \~Japanese
 * \brief      IR
 * \details    0
 * \param port 
 * \return     
 */
    pub fn ev3_infrared_sensor_get_distance(port: sensor_port_t) -> i8;
}
extern "C" {
    /**
 * \~English
 * \brief      Gets values to seek a remote controller in beacon mode.
 * \details    When an invalid sensor support number is specified, always return 0 direction and distance of -128 (error log is output).
 * \param port Sensor port to be inquired.
 * \return     Struct with heading/distance for all (4) channels.
 *
 * \~Japanese
 * \brief      IRIR
 * \details    0-128
 * \param port 
 * \return     
 */
    pub fn ev3_infrared_sensor_seek(port: sensor_port_t) -> ir_seek_t;
}
extern "C" {
    /**
 * \~English
 * \brief      Gets commands from IR remote controllers.
 * \details    When an invalid sensor support number is specified, always return 0 pattern (error log is output).
 * \param port Sensor port to be inquired.
 * \return     Struct with details of the IR remote buttons pressed.
 *
 * \~Japanese
 * \brief      IRIR
 * \details    0
 * \param port 
 * \return     
 */
    pub fn ev3_infrared_sensor_get_remote(port: sensor_port_t) -> ir_remote_t;
}
extern "C" {
    /**
 * \~English
 * \brief 	     Get the status of a touch sensor.
 * \details      When an invalid sensor support number is specified, always returns false (error log is output)
 * \param port   Sensor port to be inquired
 * \retval true  Pressed  pressed
 * \retval false Unpressed pressed
 *
 * \~Japanese
 * \brief 	     
 * \details       \a false 
 * \param port   
 * \retval true  
 * \retval false 
 */
    pub fn ev3_touch_sensor_is_pressed(port: sensor_port_t) -> bool_t;
}
extern "C" {
    /**
 * \~English
 * \brief 	     Measure acceleration with a HiTechnic NXT acceleration sensor.
 * \details      When an invalid sensor support number is specified, always returns false (error log is output)
 * \param port   Sensor port to be inquired
 * \param axes   Array to store the x/y/z axes data
 * \retval true  Axes [] is  updated
 * \retval false Axes[] is unchanged due to I2C busy
 *
 * \~Japanese
 * \brief 	     HiTechnic
 * \details       \a false 
 * \param  port  
 * \param  axes  xyz3
 * \retval true  axes[]
 * \retval false axes[]I2C
 */
    pub fn ht_nxt_accel_sensor_measure(port: sensor_port_t, axes: *mut i16)
     -> bool_t;
}
extern "C" {
    /**
 * \~English
 * \brief        Measure color with a HiTechnic NXT color sensor (NCO1038).
 * \details      When an invalid sensor support number is specified, always returns false (error log is output)
 * \param port   Sensor port to be inquired
 * \param color  Pointer to store color number (0-17)
 * \retval true  color is updated
 * \retval false color is unchanged due to I2C busy
 *
 * \~Japanese
 * \brief        HiTechnic
 * \details       \a false 
 * \param  port  
 * \param  color 0-17
 * \retval true  color
 * \retval false colorI2C
 */
    pub fn ht_nxt_color_sensor_measure_color(port: sensor_port_t,
                                             color: *mut u8) -> bool_t;
}
extern "C" {
    /**
 * \~English
 * \brief        Measure RGB raw value with a HiTechnic NXT color sensor (NCO1038).
 * \details      When an invalid sensor support number is specified, always returns false (error log is output)
 * \param port   Sensor port to be inquired
 * \param val    Pointer to store RGB raw value
 * \retval true  val is updated
 * \retval false val is unchanged due to I2C busy
 *
 * \~Japanese
 * \brief        HiTechnicRGB Raw
 * \details       \a false 
 * \param  port  
 * \param  val   RGB Raw
 * \retval true  val
 * \retval false valI2C
 */
    pub fn ht_nxt_color_sensor_measure_rgb(port: sensor_port_t,
                                           val: *mut rgb_raw_t) -> bool_t;
}
extern "C" {
    /**
 * \~English
 * \brief 	     Measure temperature with a NXT temperature sensor (9749).
 * \details      When an invalid sensor support number is specified, always returns false (error log is output)
 * \param port   Sensor port to be inquired
 * \param temp   Variable to store the temperature value
 * \retval true  Temp is updated)
 * \retval false Temp is unchanged due to I2C busy
 *
 * \~Japanese
 * \brief 	     NXT9749
 * \details       \a false 
 * \param  port  
 * \param  temp  C
 * \retval true  temp
 * \retval false tempI2C
 */
    pub fn nxt_temp_sensor_measure(port: sensor_port_t, temp: *mut f32)
     -> bool_t;
}
extern "C" {
    /**
 * \~English
 * \brief          Set the volume level of speaker.
 * \param  volume  The percentage of max volume level. Range: 0 to +100. 0 means mute. If an out-of-range value is given, i.e. larger than 100,
 * 	               it will be clipped to 100, the maximum value.
 * \retval E_OK    Success
 * \retval E_CTX   Not called from task context.
 * \retval E_NORES Failed to acquire the sound device.
 *
 * \~Japanese
 * \brief          
 * \param  volume  0+1000+100+100
 * \retval E_OK    
 * \retval E_CTX   
 * \retval E_NORES 
 */
    pub fn ev3_speaker_set_volume(volume: u8) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief           Play a tone. Any sound being played will be stopped by calling this function.
 * \param frequency Frequency of the note, in Hertz (Hz). Range: 250 - 10000. If a out-of-range value is given, it will be clipped to the minimum or maximum value.
 * \param duration  Duration to play, in milliseconds (ms). If a negative value is given, it will keep playing until stopped manually.
 * 				    If 0 is given, it will just stop the sound being played.
 * \retval E_OK     Success. The note is now being played.
 * \retval E_CTX    Not called from task context.
 * \retval E_NORES  Failed to acquire the sound device.
 *
 * \~Japanese
 * \brief           
 * \param frequency 
 * \param duration  SOUND_MANUAL_STOP
 * \retval E_OK     
 * \retval E_CTX    
 * \retval E_NORES  
 */
    pub fn ev3_speaker_play_tone(frequency: u16, duration: i32) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief            Play a WAV file stored in memory. Only 8-bit 8kHz mono WAV file is supported by now. Any sound being played will be stopped by calling this function.
 * \param  p_memfile Pointer of a memory file which holds the content of the WAV file to be played.
 * \param  duration  Duration to play, in milliseconds (ms). If SOUND_MANUAL_STOP is specified,it will keep playing until stopped manually or finished.
 * 			         If 0 is given, it will just stop the sound being played.
 * \retval E_OK      Success. The WAV file is now being played.
 * \retval E_CTX     Not called from task context.
 * \retval E_PAR     Not a valid or supported WAV file.
 * \retval E_NORES   Failed to acquire the sound device.
 *
 * \~Japanese
 * \brief            WAV8-bit 8kHz mono
 * \param  p_memfile WAV
 * \param  duration  SOUND_MANUAL_STOP
 * \retval E_OK      
 * \retval E_CTX     
 * \retval E_NORES   
 */
    pub fn ev3_speaker_play_file(p_memfile: *const memfile_t, duration: i32)
     -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief           The sound being played will be stopped by calling this function.
 * \retval E_OK     Success
 * \retval E_CTX    Not called from task context.
 * \retval E_NORES  Failed to acquire the sound device.
 *
 * \~Japanese
 * \brief            
 * \retval E_OK      
 * \retval E_CTX     
 * \retval E_NORES   
 */
    pub fn ev3_speaker_stop() -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief            Start an EV3 cyclic handler.
 * \param  ev3cycid  ID number of cyclic handler for EV 3 (specified by EV3_CRE_CYC
 * \retval E_OK      Successful completion
 * \retval E_CTX     Call from non-task context
 * \retval E_ID      Invalid ID number
 *
 * \~Japanese
 * \brief            EV3
 * \param  ev3cycid  EV3IDEV3_CRE_CYC
 * \retval E_OK      
 * \retval E_CTX     
 * \retval E_ID      ID
 */
    pub fn ev3_sta_cyc(ev3cycid: ID) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief            Stop an EV3 cyclic handler.
 * \param  ev3cycid  ID number of cyclic handler for EV 3 (specified by EV3_CRE_CYC
 * \retval E_OK      Successful completion
 * \retval E_CTX     Call from non-task context
 * \retval E_ID      Invalid ID number
 *
 * \~Japanese
 * \brief            EV3
 * \param  ev3cycid  EV3IDEV3_CRE_CYC
 * \retval E_OK      
 * \retval E_CTX     
 * \retval E_ID      ID
 */
    pub fn ev3_stp_cyc(ev3cycid: ID) -> ER;
}
extern "C" {
    /**
 * \~English
 * \brief         Get the current of battery.
 * \returns       Battery current in mA
 *
 * \~Japanese
 * \brief         
 * \returns       mA
 */
    pub fn ev3_battery_current_mA() -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * \~English
 * \brief         Get the voltage of battery.
 * \returns       Battery voltage in mV
 *
 * \~Japanese
 * \brief         
 * \returns       mV
 */
    pub fn ev3_battery_voltage_mV() -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Application initialize task
 */
    pub fn _app_init_task(unused: isize);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
